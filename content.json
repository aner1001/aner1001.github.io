{"meta":{"title":"Tang's blog.","subtitle":"Tang","description":"个人博客。记录个人的成长心得。学习的技术。各类技巧。生活。好啊好啊O(∩_∩)O哈哈~S","author":"汤晔飞","url":"http://aner1001.gitee.io","root":"/"},"pages":[{"title":"","date":"2022-08-07T08:14:02.016Z","updated":"2022-08-07T08:14:02.016Z","comments":true,"path":"sw.js","permalink":"http://aner1001.gitee.io/sw.js","excerpt":"","text":"importScripts('https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.3/workbox/workbox-sw.js'); workbox.setConfig({ modulePathPrefix: 'https://cdn.jsdelivr.net/npm/workbox-cdn@5.1.3/workbox/' }); const { core, precaching, routing, strategies, expiration, cacheableResponse, backgroundSync } = workbox; const { CacheFirst, NetworkFirst, NetworkOnly, StaleWhileRevalidate } = strategies; const { ExpirationPlugin } = expiration; const { CacheableResponsePlugin } = cacheableResponse; const cacheSuffixVersion = '-000010', // 缓存版本号 极端重要，修改静态文件后发布网页一定要修改缓存版本号 maxEntries = 100; self.addEventListener('activate', (event) => { event.waitUntil( caches.keys().then((keys) => { return Promise.all(keys.map((key) => { if (!key.includes(cacheSuffixVersion)) return caches.delete(key); })); }) ); }); core.setCacheNameDetails({ prefix: 'volantis', // 极端重要 自己拟定一个名字 suffix: cacheSuffixVersion }); core.skipWaiting(); core.clientsClaim(); precaching.cleanupOutdatedCaches(); /* * Precache * - Static Assets */ precaching.precacheAndRoute( // 极端重要 定义首次缓存的静态文件 如果开启CDN需要修改为CDN链接 [ { url: '/css/first.css', revision: null }, { url: '/css/style.css', revision: null }, { url: '/js/app.js', revision: null }, ], ); /* * Cache File From CDN * * Method: CacheFirst * cacheName: static-immutable * cacheTime: 30d */ // cdn.jsdelivr.net - cors enabled routing.registerRoute( /.*cdn\\.jsdelivr\\.net/, new CacheFirst({ cacheName: 'static-immutable' + cacheSuffixVersion, fetchOptions: { mode: 'cors', credentials: 'omit' }, plugins: [ new ExpirationPlugin({ maxAgeSeconds: 30 * 24 * 60 * 60, purgeOnQuotaError: true }) ] }) ); // m7.music.126.net - cors enabled routing.registerRoute( /.*m7\\.music\\.126\\.net/, new CacheFirst({ cacheName: 'static-immutable' + cacheSuffixVersion, fetchOptions: { mode: 'cors', credentials: 'omit' }, plugins: [ new ExpirationPlugin({ maxAgeSeconds: 30 * 24 * 60 * 60, purgeOnQuotaError: true }) ] }) ); /* * No Cache * * Method: networkOnly */ routing.registerRoute( /.*baidu\\.com.*/, new NetworkOnly() ); /* * Others img fonts * Method: staleWhileRevalidate */ routing.registerRoute( // Cache image fonts files /.*\\.(?:png|jpg|jpeg|svg|gif|webp|ico|eot|ttf|woff|woff2|mp3)/, new StaleWhileRevalidate() ); /* * Static Assets * Method: staleWhileRevalidate */ routing.registerRoute( // Cache CSS files /.*\\.(css|js)/, // Use cache but update in the background ASAP new StaleWhileRevalidate() ); /* * sw.js - Revalidate every time * staleWhileRevalidate */ routing.registerRoute( '/sw.js', // 本文件名 new StaleWhileRevalidate() ); /* * Default - Serve as it is * networkFirst */ routing.setDefaultHandler( new NetworkFirst({ networkTimeoutSeconds: 3 }) );"},{"title":"","date":"2022-08-07T08:14:02.004Z","updated":"2022-08-07T08:14:02.004Z","comments":true,"path":"404/index.html","permalink":"http://aner1001.gitee.io/404/index.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 请在下方评论留言告诉我您要访问哪个页面找不到了。"},{"title":"","date":"2022-08-07T08:14:02.016Z","updated":"2022-08-07T08:14:02.016Z","comments":true,"path":"about/index.html","permalink":"http://aner1001.gitee.io/about/index.html","excerpt":"","text":"你的一生，除了自己谁也不能为你负责：相信自己能做好决定。 养成自己思考的习惯，不要随意附和别人，别人的意见只能供你参考。 大胆地承担失败的后果。只要你认真做了，只要你比昨天做得好，就该为自己喝彩，为自己加油鼓掌。 否则，你永远体会不到成功后的喜悦。 你不会的东西，觉得难的东西，一定不要躲。 先搞明白，后精湛，你就比别人优秀了。 因为大部分人都不舍得花力气去钻研，自动淘汰，所以你执着的努力，就占了大便宜。 奋斗就是每一天都很难，可一年比一年容易。不奋斗就是每一天都很容易，可一年比一年越难。 怕吃苦的人吃苦一辈子，不怕吃苦的人吃苦一阵子。 拼一个春夏秋冬，赢一个无悔人生。 简洁是天才的姐妹。 乐于坚持的男人是这个世界上最靓的仔。 Don’t afraid of injury. 愿你的行程顺风顺水，愿你的灵魂永不迷惘。"},{"title":"","date":"2022-08-07T08:14:02.016Z","updated":"2022-08-07T08:14:02.016Z","comments":true,"path":"catchTheCat/index.html","permalink":"http://aner1001.gitee.io/catchTheCat/index.html","excerpt":"","text":".github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}} #catch-the-cat{width:100%;margin-top:32px;text-align:center} 游戏玩法： 🌟点击小圆点，围住小猫。 🌟你点击一次，小猫走一次。 🌟直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。"},{"title":"所有分类","date":"2022-08-07T08:14:02.016Z","updated":"2022-08-07T08:14:02.016Z","comments":true,"path":"categories/index.html","permalink":"http://aner1001.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-08-07T08:14:02.016Z","updated":"2022-08-07T08:14:02.016Z","comments":true,"path":"tags/index.html","permalink":"http://aner1001.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"洗车","slug":"生活知识/经验感悟/洗车","date":"2022-01-31T01:53:06.000Z","updated":"2022-01-31T01:53:06.000Z","comments":true,"path":"posts/2022/01/31/0493f7c5a2da/","link":"","permalink":"http://aner1001.gitee.io/posts/2022/01/31/0493f7c5a2da/","excerpt":"","text":"☀一、道具 ☀(1)洗车手套 珊瑚绒超细纤维 清洗车身漆面 洗轮胎和轮毂 纤维如果开始硬化需要更换。 羊毛款最柔软，但是车太脏容易洗不动车。车比较干净的情况下使用。 ☀(2)纤维毛巾 有商标要拿掉 超细 ☀汽车收水 THE RAG COMPANY GAUNTLET TRC铁手套收水毛巾最新款 作用：吸水 ☀(3)清洗液 ☀预洗/正洗液 ☀PA(预洗) 它可以分解车漆上的污迹，沙子，有效减少洗车时对车漆的磨伤，喷了PA切勿使用毛巾抹擦，因为会带动车漆上的沙子而刮伤到漆面，先用毛刷把车面的夹缝清洗干净即可。冲水，动作是最关键，一定要先从下往上冲，因为沙子大多数都是在车的底下，如果从上往下冲的话，沙子还是会停留在车身上，会导致下一步清洗的划伤！ 阿达姆斯 Mega Foam巨泡洗车液 PA预洗 正洗 高泡——发泡比较好，稀释比例高。PA1：16-- 卡赫PA(0.3L) 18.75 正洗1：256 阿达姆斯水桶(13.2L)51.56 Adam’s Polishes阿达姆斯Strip Wash脱脂洗车液——脱脂洗车液很好的产品，可以把车洗的更干净。强力污渍可以直接涂手套上，抹车身。 PA稀释比例 1:8 卡赫PA(0.3L) 37.5 ​ 两桶水稀释比例 1:128 阿达姆斯水桶(13.2L) 103.125 阿达姆斯 Car Shampoo 阳光野莓洗车液 莓果清香 中性洗车液包邮——很不错，比较滑，价格合适。 阿达姆斯 SiO2 Infused陶瓷镀晶洗车液 237ml——洗完后，可以保护、光泽、优化车辆，形成保护层，润滑外部表面。 ☀外部多效清洁剂 阿达姆斯 APC外部多效清洁剂473ml 473ml——各个部位，多用途，强力污渍清洁。轮毂、轮胎、塑料件、橡胶件、镀铬件、金厚件、低盘、发动机。 美国3D公司进口 APC浓缩多功能清洗剂 内饰清洁剂 强力去污 洗车用品 多功能清洗剂 227ML+946ML稀释壶——可用于预洗前，喷洒全车，软化顽固泥沙，外部加油孔，镀铬件，橡胶，后视镜，内饰皮革等，洗轮胎，发动机舱，下蜡预洗正洗必兑。每次用多少稀释多少，没用完尽快用完，最好用蒸馏水，纯净水稀释。稀释比例1：45，稀释一罐满大概20ml即可。 ☀外部养护药剂 阿达姆斯（Adam’s Polishes）KIT1315 Detail Spray外部多功能养护喷雾473ml 汽车蜡喷蜡QD汽车用品——万精油，视觉效果，味道，润滑，亮度，使用方便程度。能接受味道也可以擦内饰。 阿达姆斯 石墨烯多功能养护喷雾 QD之王 收水上光 ☀轮胎轮毂药剂 美国阿达姆斯 轮胎轮毂多合一清洁液 Wheel &amp; Tire Cleaner 阿达姆斯Tire Rubber Cleaner轮胎橡胶清洁剂TRC——刷轮胎最好的产品。 阿达姆斯 Wheel Cleaner轮毂铁粉清洁剂 473ml——清洁力强，适合长时间做一次深度清洁。 ☀橡胶、塑料养护药剂 阿达姆斯Tire Shine轮胎光亮护理剂 轮胎蜡上光新款–适合轮胎。搭配：阿达姆斯闪耀 轮胎魔控 波浪纹手柄 上蜡绵 阿达姆斯闪耀 VRT超级橡胶塑料封体 防紫外线 亚光不油腻光亮乳——哑光，适合车身其他身上的塑料件，机舱等。 ☀内饰养护药剂 ☀日常综合养护 阿达姆斯 Microban内饰多功能清洁养护喷雾 内饰多功能清洁养护喷雾（杏仁）473ml 带一点点的清洁功能，带一点养护上光，清洁力较低，擦擦灰、新鲜的污渍适合。不太适合织物。 ☀皮革养护 Leather Conditioner 阿达姆斯皮革内饰养护剂——缎面和哑光，缎面视觉效果明显，皮革味道大。哑光自然亮。 化学小子 皮革滋润养护剂 473毫升 汽车清洁剂内饰沙发真皮清洁滋润保养护理平衡配方新能源车用汽车用品 ☀内饰深度清洁药剂 ☀织物清洁剂 阿达姆斯Carpet &amp; Upholstery Cleaner地毯织物翻毛皮清洁剂 无泡 ☀皮革清洁剂 阿达姆斯内饰真皮清洁剂皮革塑料去污清洗剂温和去污 化学小子 中性皮革清洁剂 473毫升 汽车清洁剂内饰沙发真皮深度清洁保护皮革车用清洁剂新能源汽车用品 ——渗透皮革内部，有效将皮革内的汗水、油污、各种赃物分解的能力，真皮材质很安全，会快速挥发。中性清洁剂无需进行任何稀释。 ☀毛巾清洁剂 阿达姆斯 Revitalizer重度毛巾清洁焕活剂 3.78L——最好用的毛巾清洁剂。 婴儿洗衣液可以代替。 ☀异味清洁剂 阿达姆斯 Odor内部除味清新剂 内部除味香氛（菠萝兰花香型）473ml——有一些分解气味的能力。 ☀柏油清洁剂 柏油清洗剂沥青清洁剂汽车用车外漆面去泊油板油去除强力漆面去污 ☀铁粉去除剂 美国阿达姆斯 铁粉去除剂 Iron Remover 车身适用无氨水味新品 ☀漆面清洁剂 AutoFinesse清洁上光多合一 车漆改色膜车衣漆清养护填纹养护去污 ☀粘土+润滑剂 日本原装正品进口JOYBOND洁朋洗车泥杰鹏粘土去污飞漆火山泥去污 一般情况下，一块粘土可以施工8~9台车。 保存：冲洗，甩干，装盒，避光保存。 ☀(4)洗车桶 配备沙石隔离网 ☀(5)喷水工具 KARCHER德国卡赫高压清洗机 洗车水枪洗车机 自带水箱家用锂电 IPX5级防水 K2 Follow Me Plus双枪版 ☀(6)发泡工具 MJJC-PRO ☀(7)刷子 ☀轮胎刷 TUF刷子 ☀轮毂清洁刷 Speed Master/EZ Wheel Brush 速度大师/EZ轮毂细节清洁刷 ☀轮毂刷 阿达姆斯 Wheel轮毂短柄刷 柔弹长毛高密纤维轮毂洗车刷汽车用品 ☀外部细节刷 花猪鬃洗车细节刷三支装 汽车美容空调出风口内饰轮毂钢圈边缝刷定制 褐色 ☀软毛刷 汽车美容细节刷 车用软刷丝灰尘缝隙清理刷软毛刷 内饰空调出风口清洁刷定制 车用软刷 ☀(8)海绵 ☀洗车海绵 靠近底部裙边部分，使用专用洗车海绵。 海绵比较伤车漆。原因是没有足够的地方藏沙子。 ☀上蜡海绵 Autofinesse上蜡手柄打蜡棉手工3寸抛光盘粗中细内饰真皮清洗轮胎 ☀(9)洗车桶 阿达姆斯 3.5加仑洗车水桶砂石档密封桶盖套装 汽车用品 13.2L洗车水桶套装（砂石档+密封桶盖） ☀注意事项 洗车应该由上至下，先洗车顶和车身中部，最后清洗底部侧裙这些地方。 手法，直线往复擦洗，尽量平行，也不要井字。不要用力按洗车毛巾，也不要打圈，打圈容易产生太阳纹。让手套自己覆盖车身就好。 傍晚，阴凉处或者车库。 室外，晴天不要在中午洗车，会有很多水痕。 ☀洗车步骤 ☀1）内饰清洁 ☀1.除尘类QD养护清洁： 除尘 吸尘器，软毛刷。 从右往左朝一个方向刷，不要来回扫。 往左边扫，左手拿吸尘器，右手拿刷子。 内饰擦拭 毛巾(不掉毛的都可以)、内饰QD 将毛巾沾湿，拧干，拧到不滴水状态。 将内饰QD喷在毛巾上擦拭表面。 及时翻面。 座椅、门板、仪表。 玻璃清洁 玻璃清洁剂、无水洗车液 喷在干毛巾上，就可以擦玻璃了。 小技巧：判断没擦干净，外面采用横向擦拭，里面采用纵向擦拭。 织物部分清洁。 无泡、低泡清洁剂。 拧到不是特别潮湿的状态。 少喷一点点上去，轻轻擦拭织物表面。 ☀2.深度清洁 皮革造成污染原因：高温、紫外线、体脂、污染物、物理损伤 皮革清洁 使用皮革清洁剂，大部分情况下只要将药剂喷在擦车巾表面进行擦拭。对于长期不清洁的皮革，将药剂喷在皮革刷进行有效刷洗，或者直接喷在皮革上用手搓揉捏将要及渗透分解，乘着药剂未干，使用擦车巾将皮革表面擦拭干，用手推荐使用一次性手套。 皮革养护 使用皮革滋润养护剂 ☀2）清洗轮胎、轮毂 水枪冲洗轮胎轮毂表面的尘土泥沙。 刷轮胎 工具：轮胎刷、轮胎药剂 方法：第一遍刷完，水冲完后，确保干净可以再刷一遍。 刷轮毂 工具：轮毂清洁刷、轮毂刷、轮毂细节刷 方法：轮毂清洁刷，进的时候速度快一些，出的时候慢一些，带一些旋转，水少一些，减少飞溅。 最后冲洗轮胎。 ☀3）车身预洗 车身喷一遍APC。 工具：外部多效清洁剂 方法：尤其是在车身下部，泥土多一些的地方多喷。 使用PA壶进行预洗。 工具：预洗/正洗液 方法：PA结束后，需要等5分钟，流挂，软化污渍，方便用水冲掉颗粒物，使之后的洗更加安全。 冲洗泡沫。 工具：使用25°喷头。 方法：从下至上。冲的时候角度与车身保持45%。 ☀4）正洗 ☀♣两桶水洗车 准备： 两个洗车手套。一条洗车身上半部分，一条洗车身下半部分。 两个桶，一个桶带隔沙板装清水，一个桶打泡泡。 方法： 洗车漆的时候，每一个面，洗车手套换一个面。 两个面都用完后，放清水桶，将手套洗干净。如果不采用PA+冲洗的方式，手套换面和清洗频率要更高。勤换面，勤清洁。 不在要一个漆面上来回擦，沿着顺序过去，走直线，顺势带过去，把灰尘带掉，一定不要用力擦。 细节擦一下雨刮条。 ☀♣PA洗车 方法： 将泡沫PA到车身上，若干手套去擦，保持手套干净就可以。 要清洁哪里就喷哪里。在室外干得快，喷更少的区域。 沿着直线擦拭。 细小的部分看赃物程度，使用细节刷。 清洁完一个区域就换一副手套。 ☀5）最后冲水 工具：使用喷头，40°喷头。冲水效率更高，但是没有25°力气大。 方法：从上往下，效率更高。 ☀6）收水 工具：好的收水毛巾汽车收水。 方法：收正面水将毛巾铺上去，一拉就OK了。收侧面水，将毛巾折一下，不要来回拖。单方向走一遍就可以了。细节方面，也可以用厚一些的小毛巾，收细节反光镜细节的水。注意：不要用力，往复擦，只要放上去，等毛巾吸干。 ☀7）外部养护 先上车身养护 工具：外部养护药剂 方法：喷在车身上，或者毛巾上，擦就完事了。 等轮胎干了后，上轮胎养护。干了效果更加持久。 工具：橡胶、塑料养护药剂 方法：喷到轮胎棉，擦就完事了。 ☀8）漆面深度清洁 柏油清洁剂、粘土润滑剂+粘土、铁粉去除剂、漆面清洁剂、上蜡海绵、上拉手柄、毛巾块、擦车巾。 脱脂洗车液 车漆表面可能是油膜和铁粉，混合。 洗车，将车洗干净。脱脂洗车。收大水。 去铁粉。可以喷洒到车辆任何部位。至少等待3~5分钟。完成后，用水冲干净。 **喷洒诀窍：**不要以对点方式喷洒，离车漆30~40公分距离。一边甩手一边喷洒。让去除剂轻轻雾到表面。只要没有干，就会有一个很好的效果。如果在露天施工，或者天热，去除剂干得快，可以进行多喷或者1：1稀释。 去柏油。一般柏油出现在轮毂或者轮胎后方，车身下盘。 **诀窍：**对存在的区域进行收大水工作，然后再喷洒。等待30~60秒。使用黑色擦车巾对有柏油的地方进行擦拭。对于大的柏油颗粒，二次施工，不要用蛮力。遇到塑料件部位，喷到毛巾上再进行擦除。清洁完成之后，需要使用清洁剂，加上清水，给喷洒过柏油清洁剂的表面进行擦拭，将残留擦除。再进行粘土施工。 跑粘土。整辆车外部，除了橡胶塑料件都可以跑。粘土大小：三个手指1/3，新手可以一整块，分散压力。 **诀窍：**润滑剂雾化式喷洒，只要变得顺滑即可。以手腕进行活动，而不是手肘。轻轻进行横向擦拭，约1根手指压力轻轻擦拭，最为安全，最不容易遗漏，不容易产生细纹。擦拭完成后，需要将不干净的润滑剂水分擦拭干净。每次施工面积不要太大，1/3机盖为主，如果太大会导致来不及擦拭，导致赃物重新回到施工过的部位。每擦拭完半块钣金后，检查粘土，如果赃物严重重新揉捏粘土。跑的时候，听有没有摩擦声，如果有就说明有大颗粒。每施工完成一块板金，都需要重新翻折。经常为粘土翻面，保持柔软状态。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"车","slug":"车","permalink":"http://aner1001.gitee.io/tags/%E8%BD%A6/"}]},{"title":"泥小子帕萨特","slug":"生活知识/经验感悟/宠物/泥小子帕萨特","date":"2022-01-23T13:49:20.000Z","updated":"2022-01-23T13:49:20.000Z","comments":true,"path":"posts/2022/01/23/b5e949dd3b2c/","link":"","permalink":"http://aner1001.gitee.io/posts/2022/01/23/b5e949dd3b2c/","excerpt":"新车记录一些需要提升的地方。","text":"新车记录一些需要提升的地方。 ☀开车技巧加强点 熟悉车宽，左右两边所在的参照物位置。 熟悉车前方位置。 牢记后视镜可折叠，紧急状态下可收起来。 道路上开车时，更早得提前打灯。更早做出预判。 道路线转弯不能走错。 ☀用车知识学习点 靠边停车。 侧方停车。 倒车入库。 打方向盘。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"宠物","slug":"生活知识/宠物","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%AE%A0%E7%89%A9/"}],"tags":[]},{"title":"《心流》——米哈里·契克森米哈赖","slug":"生活知识/读书笔记/《心流》——米哈里·契克森米哈赖","date":"2021-10-13T13:45:59.000Z","updated":"2021-10-13T13:45:59.000Z","comments":true,"path":"posts/2021/10/13/a46f0229c79a/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/10/13/a46f0229c79a/","excerpt":"心流不是鸡汤，而是让你保持专注高效、幸福感翻倍的科学。📖","text":"心流不是鸡汤，而是让你保持专注高效、幸福感翻倍的科学。📖 ☀名句摘录 米哈里的方法是，面对太多的，包括负面的信息，你必须找到一项能长久地凝聚自己注意力的活动。❤ 上述造成心流的活动，比如攀岩、写诗、思考哥德巴赫猜想，哪能如此。一句话，能早就心流的活动，大多还需要当事者自觉自愿，乐在其中。 可以造就心流的活动中必有挑战，且挑战应该是动态的，即当挑战与你的技能匹配时，有了心流。当挑战的目标大大高过你的技能时，将产生焦虑，此时应降低挑战目标。当你的技能高过设定的目标，继续持续这种活动将产生厌倦，便要提升目标，以求挑战和心流的持续。正是在技巧提高、目标上调的过程中，当事者感受到了成长的乐趣。此为幸福之真谛。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"读书笔记","slug":"生活知识/读书笔记","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"开车技巧","slug":"生活知识/经验感悟/开车技巧","date":"2021-10-07T01:41:52.000Z","updated":"2021-10-07T01:41:52.000Z","comments":true,"path":"posts/2021/10/07/79305d637a9e/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/10/07/79305d637a9e/","excerpt":"","text":"反应要快，长得要帅！思路要清晰！ 开车🚗技术只是一个基础，意识才是关键。 ☀新手注意 1.刚开始，车速要在自己能够控制的范围内追求一个速度的上线。尽量不挡道。 2.上看红绿灯，下看斑马线箭头，左右看行人和车辆。 3.左转最好的状态是匀速，速度是自己控制范围之内的匀速。方便看左右。 99.9%的事故，都是因为车速过快，一般新手反而不容易出事，反倒是开了两三年的司机，自认为天下无敌，结果最容易出事。 少看一眼就可能出现事故，多看一眼就可能化险为夷。 熟悉刹车和油门踏板反馈。通过控制脚的力度，达到平等线性的状态。 正常转弯，以B柱子作为参考。过了B柱，就可以转弯了。 通过观察高度，来判断前车障碍物的距离。了解自己车的车距。 随时随地用余光看后视镜。 开车一定要记路。 看指示牌很重要，蓝底白字的牌，和地上白色的线，有时候导航不会说。 开车不只是一个人的事情，和其他参与交通行人车辆都是随时随地会发生关系的。所以要对别人负责，时时刻刻保持清醒。要知道在哪里，要去哪里，周围都有谁，他们要干嘛，他们要去哪，要时时刻刻关注。 开车最理想状态，不要觉得你在操控这个车，要觉得这个车就是我。 ☀开车意识 红绿灯路口，在红灯时，两旁的大车或者一连串的小车，遮挡左右两边视野，导致观察不到横向车辆。 **应对措施：**红路灯路口，红灯刚起步时，减速慢行，观察好左右车辆再下一步。 开车过斑马线，受到两边前车的影响，看不到斑马线行人。 **应对措施：**过斑马线，减速慢行。 超越被超车辆时，需要懂得预判被超车辆会不会突然变道过来，如果被超车辆前面有障碍物或者龟速行驶的车辆就很可能在超车的时候突然变道过来。 **应对措施：**超车时踩着油门，心理也要想着如果前车突然变道过来，脚要马上从油门切到刹车并踩下。提前有心理准备。超大货车时，提前两三秒左右闪灯鸣笛，提醒大货车再超过去。 跟车，新手容易出现1.跟车安全距离留了过大，容易被一辆接一辆加塞，增加了剐蹭事故发生的概率。2.对自己技术有信心，跟车跟得很紧，觉得和前车车速一样就不会撞上，前方如果有紧急状况突然急刹车容易追尾。 **应对措施：**开车要经常设想，前车如果突然急刹车，我能不能刹得住不追尾上去，至少要保证不追尾的安全距离。 跟车存在盲区，视线是被前车所遮挡住的，前方车辆能看到的，我们是看不到的。跟车太近，前车紧急变道，是来不及反应的。 **♣所以一定要保持安全车距。**设想前车如果突然变道能不能反应过来。 过没有红绿灯的路口，观察正前方没有车，油门上去，很容易与两边开出来的车相撞。 **应对措施：**1.过一些比较小的路口，除了减速慢行，还要提前几十米到100米，用余光扫射路口两边，可以停在路口观察，两边观察清除，确定安全再通过。 2.如果过一些比较大的路口，中间还有绿化带，很难一次性观察路口两边的情况，不要贸然开出去，可以分两次过，先观察左边确定这个方向没有来车，再开出去。不要马上冲到对面，来到中间，再观察，右边的车辆，如果有车开出来必须让，两车直行左要让右，停在绿化带中间位置等，确定安全再开出去。 超车，注意相对速度。小心龟速车辆，如果自己车速很快，他突然变道过来，根本没有反应时间，如果这辆车车速也很快，就算变道，因为相对速度不大，就不会一下就撞上去了，有时间反应。 **应对措施：**所有前后左右的车，如果速度有开的特别慢的车，就要适当减速。 让速不让道。遇到加塞，没有提前观察好左右后视镜，不要轻易变道，最正确的做法是降低车速。 跑夜路牢记，走灰不走白，见黑停下来。普通路面灯光照射是灰色。如果有积水，车灯照射会反射白色的光，要尽量提前避让，提前减速。前方有坑，灯光照射不到，所以开车看到是黑色的，这时候一定要提前降低车速。 转向灯提醒的是我要变道，而不是我正在变道。左转转大弯，右边的左转车道转弯后选择中间或者最右边的车道，左边的左转车道，转弯后选择最左边的车道。右转转小弯。往哪边转弯就提前看哪边的后视镜，提前打开这一侧的转向灯。 ☀开车习惯 ☀♣状态 时刻检查自身状态，不能疲劳驾驶。如果捆了，可以打开外循环，缓解。正确的做法时找个地方停车休息。 ☀♣开车之前 **检查车外：**绕车走一圈，检查四个轮胎，有没有气，有没有炸到钉子，有没有裂痕，有没有鼓包。检查车牌有没有被遮挡，遮挡拍照一次性扣12分。 检查车周围车辆障碍物情况，提前想好路线。 **检查车内：**灯光仪表，油，故障码。观察车内踏板是否有杂物。车内物品，是否容易掉落，造成安全隐患。脚垫不能选太厚，或者里面立起来太高的，容易影响踩踏板。 **检查自己：**鞋带不能太长，容易套住，影响踩踏板。 ☀♣起步 不能刚起步就挂档走，正确做法，等转速表稳定再挂档走。 冬天，热车，启动车辆后，原地怠速20秒到30秒，使机油充分润滑到每一个零件。或者到1000转以下。冷车启动高怠速，是让发送机快速暖机，尽快达到最佳工作温度。 ☀♣安全带 提醒后排乘客也需要带好安全带。 ☀♣安全气囊 坐椅上有安全气囊，不要套座椅套。 座椅侧边气囊，不要让小孩敲着玩。 副驾驶严禁坐小孩。 ☀♣开车时 头贴着靠背，不要探头开。 眼观六路，老司机开车时都会顾及150米开外的路况，随时随地应变紧急情况。 ☀♣待车 不准长时间，挂在D档，原地不走。否则会造成变速箱油温过高。 ☀♣跟车 **三秒法则：**跟车时一定要预留出3秒的距离。 ☀♣临时停车，等红绿灯 挡位挂N档。 省油。 车辆磨损小一点。 ☀♣车速 最安全车速，不要龟速行驶，尽量开到最高限速，或者接近最高限速。如果做不到，就靠近最右车道行驶，不能再中间或者快车道磨磨蹭蹭。 ☀♣前车博弈 通过观察前车的大小来判断，反应要快。前车变小，说明加速，踩油门跟上。前车变大，说明减速了，及时踩刹车，以防追尾。 ☀♣变道 主要注意力还是要放在车头的正前方。在确保前方安全的情况下，再看后视镜，眼光不能一直停留在后视镜上，看一下后视镜，马上切回正前方，确保前方安全，如果没有观察清楚，可以看一下后视镜，马上又切回正前方，视线在两个方向来回切换。老司机说的，变道要用余光看后视镜。变道要确保两个方向都安全。 小打方向慢慢变道，千万不可猛打方向。注意车速，至少要把车速提到和前车差不多，否则变道上后方车容易追上。 车速越快，打方向盘变道，打的要越少，微调一点就可以了。 提前3~5秒开启转向灯。 变道时机，需要把车速提起来，保证不追尾的情况下，紧跟前车。和其他车道车辆速度差不多，才有机会变道。 **最好的变道就是，在保证自身安全的前提下，不干扰到别人，**最忌讳的就是刹车减速变道出去，容易追尾。 堵车的时候，先打灯，再慢慢靠近打方向试探，让对方更加清除你的变道意图，这样后方的车也有更多反应时间。 ☀♣坐姿 至少离开方向盘25厘米。椅背15度。椅面3度。 上下，保证好的视野，不能太高，颠簸可能会撞车顶上。 前后主要以刹车来做标准和参考，刹车踏板完全踩到底，膝盖还有一点点的弯曲，腰间能够用到力。 方向盘，不能挡住看仪表盘，避免膝盖碰到方向盘。 靠背，保证身体和腿部夹角大于90度。肩膀靠在座椅上把手伸直，保证手腕能放到方向盘最顶端。 头枕，头靠上去，正好在正中心，上下左右都是正中心。。 ☀♣视线 任何时候眼睛都不能离开道路，离开道路都会增加危险性。 直行、拐弯，视线都要落在远处。 不需要太远，看广一点，把两边的线放在余光中。 ☀♣观察 随时随地用余光看车内，左右后视镜。来判断车距，以及周围车辆的动态。 ☀♣减速 要看好前方车流和车辆的情况来判断。收油、踩刹车。带刹车（轻踩刹车）和踩刹车。都需要提前预判。 经过路口，视野盲区，等有旁边可能会有车和人过来的横向道路，必须点刹车减速，注意瞭望。 ☀♣刹车 算好距离，刹车踩一般停车，会很舒服。 ☀♣转弯 提前3~5秒开启转向灯。进入弯道提前减速。城市道路，不要超过30码。 小区路口直角右转弯 观察顺序，先左后右，再左再右。两次观察。确定左边没问题，右边，确定左边没问题，右边整圈加半圈。 打完方向后，两侧都要观察，两侧都有障碍物。不要光往右拐，只往右看。最起码的行车常识。养成良好的驾驶习惯。 右转 观察后视镜，头侧转45度。开右转灯。左边也得看。先左后右，再左再右反复观察。 左转 侧身观察A柱盲区，看镜，侧转，开灯。 虽然是左转，右边也得看。 备刹车习惯。上路的时候经过人行道，路口这些地方，脚一定要备在刹车上。以免有行人或电瓶车突然冲出。不能把油门当刹车，特别是前方左右有停车的车辆，有盲区。感觉到有危险，第一时间，把脚从油门切到刹车踏板上，做好随时刹车的准备。确定确定，没有人，再稍微加点油门。 变道的时候不要突然猛打方向，开车想要来如自如，并不是靠打方向打得快来实现，而是要把握变道的时机，和创造变道的时机。变道的时机，主要是观察后视镜来把握。后视镜也存在盲区，扭头看侧边(转弯和变道都需要看)，保证没车，再变道。 如果只能看到一半车身说明距离很近，千万不能变道。 如果能看到整合车头，在堵车车速慢的时候，变道时相互对安全的。车速越快需要越大的安全距离。 当后车车头在后视镜中越小，说明后车离我们越远。 图片收藏：哪种大小适合高速变道，哪种大小适合堵车变道。都要提前了解清除。 变道或者转弯时，一定要记得提前三到五秒开启转向灯，变道的时候，要习惯性的看一眼侧窗，因为后视镜存在盲区，特别是右侧车道。 过闸道看后视镜： 转弯的时候，左侧A柱有很大盲区，要养成一个习惯，在转弯的时候稍微测一下身，看一下A柱后面的情况，确保安全以后再转弯。 开车眼睛不要只盯着前方，要利用车内的后视镜，以及左右的后视镜来判断车距，以及周围车辆的一个动态。这样遇到紧急情况，也不至于手忙脚乱。 养成备刹车的习惯。处于不加速的状态，右脚一定要放在刹车踏板上，备着。而且脚趾要做到，正脚踩刹车，斜脚踩油门。是避免错把油门当刹车的最好方式。 在刹车前，要养成，看一眼车内后视镜，以及左右后视镜的习惯。尤其是在高速开车的时候，不然很容易发生追尾。看后视镜以及左右后视镜，如果发现后车距离较近，那么我们就要以轻点刹车的方式利用这个刹车灯来提醒后方的车辆。 下车的时候用右手开车门，这样就有一个转身的动作，对后方的情况就一目了然了。特别是在马路边停车。 提前设置好导航，不要上路才设置导航，提前开启导航的语言唤醒功能。开车过程中想更换目的地，就不用低头打字了。和导航对话就可以了。、 雨天行驶时，每隔一段时间最好轻踩刹车。这样可以把刹车盘上的水挂掉，防止因为需要紧急刹车时，因为水增加刹车距离。 遇到大雨，大雾天气，一定要开雾灯，而不是双闪。雾灯穿透性更强。警惕后车。 脚刹一定要松在，手刹之后。自动驻车，电子手刹，推入P档或者熄火，手刹会自动拉起。 车子一定要完全停稳，才能将挡位挂入P档。 **标准D档停车：**先挂入空挡，再拉起手刹，再挂入P档，再放开脚刹，拔掉钥匙。 **便捷D档停车：**D档，停车，车辆彻底没有移动的时候，直接挂入P档，拉手刹，再放开脚刹。 如果车有自适应巡航，在高速上应该打开，这样会非常安全，自适应巡航会根据前车的车距调整车速，不会追尾，非常安全又省事。 导航提示，前方500米右转，就提前走最右车道。当导航提示还有五六十米右转，就会播报即将右转，在眼前路口右转就可以了。 遇到一分为二的道路，提前做好准备，并且看好后视镜，旁边的车辆。 踩刹车也要提前。 在复杂的地方开出去车，线路都要提前想好。 ☀♣停车前两分钟 到达目的地前两分钟，关闭A/C制冷。不关，风量开关，吹两分钟，干燥空调。 ☀♣雨天 关闭自动启停功能。避免遇水，发动机二次打火。 **前挡风玻璃起雾：**打开A/C制冷，打开前挡风玻璃除雾，切换外循环。 **内后视镜起雾：**打开方形的加热功能。 **侧窗玻璃水珠：**把它降到底，再升起来。 车身稳定系统不能关闭。 打开车子的前后雾灯。 ☀♣加油 雷雨天气，能不加油就不加油。 加油时，下车。 ☀♣减少积碳 积碳主要是因为燃烧不充分。 长时间原地热车。车子处于怠速工况。燃烧条件相当差。转速低，节气门全闭，供油量少，混合器浓度高，雾化不良，产生燃烧缓慢，燃烧不完全。 边走边热，比原地热车好。 经常短时间，短距离行驶，导致发动机燃烧不充分。冷启动喷油量更浓，导致烧不干净。 熄火导致积碳，不能避免。 经常在拥堵路面下开车，走走停停。 加劣质汽油。 可添加清洁型燃油宝。 ☀错误情况 一边开车，一边看手机。 空挡滑行。 车还没停稳直接挂P档，或者倒挡。 等红绿等，把挡位挂入P档。 开着车内阅读灯行驶。自动模式如果开车，说明车门没关好。 近距离跟车开远光。 会车不关远光灯。会车条件不好的路段，会车一定要关闭远光灯。 雨雾天气不开雾灯。 转弯才打转向。拐弯变道一定要提前打转向。 非雨雾天气开雾灯。 ☀日常技巧 ☀调整坐姿 先调高地，再调远近。 远近什么程度合适：手腕可以勾到方向盘顶端就是了。 方向盘如果挡住仪表，就要调整方向盘位置。 ☀后视镜调节： ☀车外后视镜 一定要调整完坐姿，再调整后视镜。少量天空，大量地面。 左后视镜： 后门把手，位于内测下方1/3-1/4处。 天地1：1，左3/4，右1/4。能看到后车门把手。 右后视镜： 上1/4，下4/3,左1/4,右3/4，能看到后车门把手。 开车可以将后视镜一分为二，左侧是危险区，右侧是安全区。车辆在左侧千万不能变道，车辆在右侧，安全，可以变道。 后视镜无论怎么调节都有盲区，可以增加小圆镜拓展视野。 ☀车内后视镜 使它的中心点与后窗的中心点正对。使后视镜，尽量保持对称的方式容纳整个后车窗。 保证右侧耳朵，在左后视镜边缘处可见。远处天地比例1：1。 ☀掉头 只要路口没有禁止掉头和禁止左转的标志，车辆都是可以进行掉头的。绿化带可能会挡住禁止掉头的标志，一定要仔细观察。 前方有专门的左转信号灯时，只有等左转信号灯变为绿灯时才可以掉头。 一定要越过斑马线进行掉头。 掉头要礼让对向的直行车辆。让前方的直行车辆先走完。 同方向有两条左转车道，车辆掉头，必须要在最左侧的左转车道进行掉头。 如果有专门的掉头车道，就最简单了。看信号灯行驶即可。 掉头如果左边路太小，往右边打方向的时候，记住不能压线。 ☀倒车入库 ☀步骤1：打方向 打方向时机：后视镜对其边线或者中线后，根据场地大小，场地越大，对其可以越往初始驶入的边线对其。场地越小，越往最后的边线对其，边线对其最多适合双行道。如果是单行道，最后的边线对其后，再往前开一点，再打方向。 停止时机：后视镜能看到裤脚。 ☀柱边出库 ☀开车出库 整个车身距离旁边柱子50公分左右时，打方向盘时机就在副驾车门中间的位置。 整个车身距离旁边柱子30公分左右时，副驾驶车门B柱对齐墙。 小技巧：先往左打点方向，再往右打方向就不会碰到。 ☀倒车出库 如果是倒车，车屁股出库，后视镜或者**A**柱超过旁边车头，怎么打方向都不会碰到旁边的车。 旁边车辆的车头，位于左右**A**柱就可以打方向。 ☀靠边停车 ☀有一辆车参考 距离旁车60厘米往前开。当驾驶者或A柱越过车灯时，方向盘向右打满。 当路牙子焦点在引擎盖1/3位置时，迅速往左侧打满。 车身摆正，回正方向。如果车身距离路牙子还有距离。 往右侧打满，当路牙子在后视镜消失。 抓紧反方向打满方向。车身正，回正方向盘。 ☀侧方停车 ☀前后有车情况下： 1.与旁边车辆保持50米左右距离。 2.当后视镜与旁边后视镜平行的时候停车。 3.停车以后挂入倒挡，往后倒车，方向右打满。打满方向后观察左后视镜。 当从左镜看到后车里面大灯露出的时候，回正方向盘。 4.继续往后倒车，看左后轮，左后轮碾压边线的时候，方向盘迅速左打满。 这样我们的车就会迅速进入车库了。 或者右边后视镜碰到路牙子，方向也可以向左打满。 5.当车身与裤线平行的时候，回正方向。 6.然后往前开20公分左右，与前车后车，都保持一个安全距离。 ☀无车有边线情况： 1.与旁边车道线保持在30公分左右。尽量右边留窄一些，左边留宽一些。 2.右后视镜看到左边库脚，停车。 最好库脚是在后视镜中间。 3.开始倒车，第一个点位，第一个库脚完全消失在右边后视镜。方向盘一把往右边打满。 4.打满后观察左后视镜。从左边后视镜看到最后边库脚出现的时候，回正方向盘。 5.继续观察左后视镜，继续倒车，看到左后轮即将碾压虚线的时候，方向盘往左边打满。 6.观察左右后视镜，车身与边线平行，停车。 ☀长度很大的停车位，正着进去。 ☀ 1.当肩膀与车头成一条直线时，方向盘向右打满，往前开。 2.当左前大灯，和裤线重合时，把方向盘向左打满，接着往前开。 3.观察左后视镜，刚好看到右侧车灯，把方向盘回正，往后倒车。 4.最后当左后轮压倒裤线，将方向盘向左打满。 ☀前有后无车情况： CBA侧方位停车教学： 两车距离50公分左右。 倒车，观察C柱，左后车窗能看到旁车车脚。刚一露出来两把方向打尽。 旁车左侧车位接近B柱，两把回正方向盘。 旁车左后角接近A柱，向左两把方向打尽。 观察右后视镜，道路边缘刚刚露出。两把方向回正。 前进档，调至前车保险杠上沿。距离1米。 ☀左侧侧方位停车： 靠近旁车50公分间距。 左侧车子右后角，在后车车窗中间位置，向左两把方向打尽。 右后角在B柱露出。两把方向回正。 后视镜边缘接近前车右后角，向右两把方向打尽。 后视镜道路边缘露出，两把方向回正。 ☀短距侧方停车： 拉近50公分间距，停车线位于风挡玻璃2/3，回正反打。 等车摆正，方向盘回正。 倒车观察，旁车后车脚位于C柱车窗露出，向右两把方向。 观察左后视镜，完整面貌露出。两把方向回正。 观察灯镜重合，向左两把方向打斤。 如果车身没正直，不能继续倒车，前进，向右两把方向打尽，尽快将车摆正。摆正后回方向。 ☀侧方出库 主要还是熟悉与前方的车距，什么时候可以一把打满不碰到。使用车头线作为参照。 出库时，当看到前车保险杠上沿以下时，方向盘打满就可以安全出库了。 **A**柱与障碍物重合的时候，就可以回正方向盘了。 ☀斜线停车位停车 沿着车位线，30~50往前开，当车辆后视镜与目标车位的角对齐，方向盘向右打满，当看到车身和车位线平行，回正方向盘。 ☀方向盘： ☀不正确习惯 掏方向盘。 搓轮。 建议：搓轮虽然快，车辆怠速行驶，倒车入库，侧方停车。而且脚是放在刹车上的。 走直线时。很用力握住方向盘。轻轻扶助就可以。 ☀正确打方向盘 解决各种角度转弯。 ♣握法 左手9点，右手3-4点位。大拇指自然落在顺应在方向盘边缘。如果是左右手端平，容易右手向下拉，造成车一路向右跑偏。 ♣90度、立把方向操作方法。 向左转弯的时候，右手推送，左手滑动，左手虚握滑动。右手推动，推到12点位置。 向右转道理类似。 ♣半把方向 左手还是虚的滑动，右手推送，推到9点位置，两手在9点位虎口相对。这样是半圈方向。 向右转道理类似： ♣360度、整把方向操作方法 正把方向，就是在半把方向的基础上，转了半圈的基础上， 如果这个弯没拐过来，左手换到上面变成一整圈。 方向盘完整一圈，360度。 右转同理。 ☀打灯： ☀遇障碍物远离 ♣前进的时候，遇到。 像障碍物一方打满方向后倒车。 ♣倒车的时候，遇到障碍物 朝障碍物相反方向打满，向前开车。 ☀省油 车子不能忽快忽慢。匀速最省油。多用巡航功能。 开自动挡车不要一直踩着油门，当发动机转速升到换挡区间的时候，3000转左右，变速箱会自动换挡。这时候再踩下油门，整个换挡过程会非常平顺。 如果想要超车，松开一点油门，然后再踩下去，这时候变速箱会自动降档，提速更快，车辆更有动力。 城市道路地板油，增加油耗。 等红灯时，挂**N**档，拉手刹，不要挂D档踩刹车。费油，离合器片也会磨损。‘ 超车先松开油门，再踩下去。深踩，不仅提速慢，油耗还很高。 精确预判，带档滑行。 小脚刹车，小脚油门。 如初恋般对待。 提前规划路况，避免拥堵。 保持合理车距，避免急刹车。 合理控制车速，避免无谓的加速。 长时间停车，请熄火，避免不必要的怠速工况。 短途行驶，最费油，避免不必要的短途行驶。 自动挡打开经济模式。 根据说明书，加注合适标号的燃油。过低过高都不好。 根据季节及时调整胎压，对省油和安全都有帮助。 移除车内，不必要的行李和车外装饰，能从车辆和风阻的角度为你省油。 正确保养爱车，良好的车况有利于节油。 ☀踩刹车 ☀停稳式刹车 ♣两脚刹车 轻轻脚放在刹车上，慢慢把刹车踩下去。车子有一个明显的减速过程。 慢慢线性把刹车踩深。 车子快停时候，把刹车往回退，把刹车慢慢松开。让车子平稳往前溜一点。再慢慢把刹车踩下去（第二脚）。 轻、重、轻 最开始踩刹车，轻。 逐渐向下加力，重。 等车快要停了，降低到人走的速度，再稍微放一点，轻。稍微当上太的动作是看不到的，能看到往上抬说明力度就大了。 ☀急刹车 瞻前顾后。多看一眼后车。养成看后车的习惯。 一旦有减速行为，一定要踩一下刹车踏板，触发刹车踏板开关。告诉后车，自己要刹车。 ☀上下陡坡 挂在M/L挡位，不可长时间D档。 ☀坡道起步 利用坡道辅助的3秒时间。 开启自动驻车辅助上坡。 利用电子手刹，开启电子手刹后，松开刹车，踩油门，动力大于电子手刹的制动力，电子手刹会自动解锁。 利用机械手刹，拉上机械手刹后，松开刹车，踩油门，当发动机转速到达1500~2000转，立即松开机械手刹，也能平稳起步。 操作熟练，从刹车踏板赶紧移到油门上，是绝对没有问题的。 ☀上下，有弯度的坡 右转上坡 不能一把往右。 左转下坡 不能一把往左。 遇到急陡坡转弯，不要想着一次性搞定。换个方向上坡，或者下坡。 ☀并线 不能影响旁边和后方的车辆。 真正危险的是你看不见的。新手可以利用并线辅助。 并线要有明确的目的，超车或者驶出。 并线不能大幅度打方向盘。 ☀上下马路牙子 上马路牙子： 胎面与马路牙子垂直，慢慢上，对地盘和轮胎都有好处。不能侧着上。 下马路牙子： 让车子斜一点，让轮胎一个个下，伤车最少。不能正着下。 ☀顶墙停车 **旁边的车辆参照物：**在旁边有车的情况下，以旁边车辆的后视镜作为基准。 **后视镜为参照物：**后视镜下沿和墙平齐时。车头距离1米。 **灯光参照物：**打开灯光，根据灯光能见程度和自身车况调节。衡量。 ☀过障碍物 至少与障碍物保持50公分间距。小于30公分就很危险。 ☀右侧障碍物 使障碍物位于风挡玻璃中间位置。 随着开进，障碍物会越来越向右靠。只要在右侧以外的位置都是安全的。至少要在中间，中间以外的位置越来越安全。 一直靠到窗脚处，说明这个车已经可以安全通过了。 ☀左侧障碍物 使障碍物对应到左侧窗脚。 ☀前方障碍物 高度和距离相结合。 半个车轮看不到，这个时候开始打方向。 打方向的时候，遮住对面的车在膝盖以下高度，80公分以下，都是安全的。 如果是正对着的车，看到保险杠一半的位置。两把方向打尽。保险杠一半的高度，就是半个车轮的位置。 ☀窄路会车 左下角刚好和对方车辆大灯重合时，距离在50公分左右，可以放心通过。 右下角和对方车辆大灯重合，也能安全通过。 ☀靠边停车 以雨刮器为中心点，扫着马路牙子走。 ☀培养车感 选择宽阔地带，注意行人。 ☀熟悉车宽 找点练习：将车开到一条白线上，左前轮压在白线上时，在车内看好点位，同理寻找右前轮的点位。加上后视镜的宽度，就可以知道车宽是多少。 对点练习：将车开到一边，慢慢将找准的点去和白线对。慢慢自然熟悉车宽。 在窄路会车，或者靠边停车，就明白自己能停到什么地方，不会和右边发生剐蹭。 ☀熟悉打方向转弯的感觉 手握3，9点位置。 一只手只翻半圈。另一只手配合再半圈，就是一圈。再翻半圈就是打满了。 回圈同样逻辑。回的手用力。 ☀转弯 2个因素： 横向距离。最好能保持足够宽的横向距离。 前面距离。 ☀日常练习 ☀油门和刹车 油门和刹车的切换要做到快，准，稳。刹车踏板，比油门踏板高。 正脚刹车，斜踩油门。 ☀判断车距 ☀前面是马路牙子 当后视镜下沿与马路牙子下沿重合时，立即踩刹车。此时距离刚好30公分。 ☀后面是马路牙子 盯住后视镜前门门把手，当前门门把手与马路牙子重合时，立即踩刹车。此时距离刚好50公分。 ☀靠边停车 盯住雨刮器骨节，慢慢打方向，以90度向右打方向往前开。 当雨刮器骨节或者车头中心点，和路边的马路牙子重合时回正方向盘。 再向左回转90度，微调一下往前开，此时距离刚好30公分。 ☀判断与前车距离 当看不到前车后保险杠上沿时，立即踩刹车，此时距离只有1米。 前车保险杠下沿，距离两米。堵车缓慢行驶，最适合的跟车距离。 看见前车后轮胎下沿–车距为3m。这时候稍微可以近一点，太远容易被加塞。 ☀判断与后车的距离 从右后视镜看车充满后视镜时，此时前后车差距为3米。 从左后视镜看车充满后视镜，实际距离只有1米。 当后车占左后视镜2/3时，实际距离只有3米。 后车站左后视镜1/2时，距离5米。 后车占左后视镜1/3时，距离10米。 ☀判断左轮的位置 车道线与车头结合点，距离左侧A柱20厘米左右。左侧车轮即将压线。 车道线与车头结合点，距离左侧A柱10厘米左右。距离左侧车道线60公分左右。 ☀判断右轮位置 车道线与机箱盖中间重合，基本就压线了。 保证路面白线，在车前盖偏右一些的位置就没问题。 根据每个人的身高，座椅差距不同，会有所差距。具体通过经验来修正。 ☀出库 等到B柱超过旁边车头再转向，这样不会碰到旁边的车。 ☀应急措施 ☀爆胎 数据统计，每年发生的交通事故，有50%都是由于爆胎引起的。 爆胎后正确的做法：双手紧握方向盘，反复大力点踩刹车。保持直线行驶，当车辆降下速后缓慢靠边停车。摆放好三脚架，拨打电话等待救援。 ☀车陂刮 外边停车场或者小区，第一时间联系物业调取监控，寻找肇事者，如果监控出现故障，应该由物业承担责任。 停在马路边，被刮碰，找不到肇事者，一定不要先自己维修，先找到交管部门，打122报警，让交管部门调取附件监控来找到肇事者，如果找不到肇事者，一定要让交管部门开一张事故证明，拿到这个事故证明，再到保险公司进行全额理赔。 ☀隧道到达限速被催 1.后面是大车，跟着大车过隧道不停在后面按喇叭闪灯，可能时大车发现了你没有发现的危险，比如大车刹车刹不住，而且正好是下坡，这个时候变道或者加速。 2.后面不是大车，看旁边车道车子的速度，大家都是排排开，都占了车道。后车可能有急事，可以稍微把速度开快一点点，控制在10%以内。 3.已经顶着限速跑，最多10%。后车还是催，先保证自己安全。轻点刹车一闪一闪告诉后车，不让。让他自己变道。也可以将双闪点一下。不想超速，不想实线变道。 ☀换备胎 在道路上，先放三脚架。150米以外的地方。 车子一定要开启手刹。 松螺丝，套住，用脚。 2.千金顶。车的大梁都有一个千斤顶的专用支撑点。两个点中间的部分。 将千斤顶对准好位置就可以了。 3.上轮胎，拧螺丝。锥面向里，平面朝外。 ☀三角牌放置 距离车子50~100米的地方。 ☀后车近距离开远光 加速拉开距离，或者减速让后方先行。 ☀交通规则 ☀闯红灯情况 红灯亮起没刹住，部分冲出停止线。 全部冲出停止线，属于越线停车。2分200。 越线停车又倒车，200 +100。 跟着大车误闯红灯，记6分+200。 ☀左转待转区 直行、转弯都为红灯，停在，停止线内。已进入待转区的车辆应继续左转通过，不可停留在待转区内，保持路口清空。 直行绿灯进入左待转区。 左转交通信号灯变绿，可以进行左转。 ☀车道 右侧为慢车道。 ☀日常装备 ☀急救包。 注意有效时间。 ☀反光背心 至少一件。 ☀香皂。 香皂盒中戳几个孔，放在车上就可以了。闻起来特别清新。 作用： 1.车门胶条老化导致，嘎吱异响。用香皂涂抹，异响会消失。 2.开关车门，存在异响。使用香皂在限位器上涂抹。 3.前挡玻璃刮不干净。用香皂在玻璃上来回刮几次，玻璃就容易干净。 4.雨天后视镜积水，用香皂涂抹几次，不容易积水。 5.车辆水管有泄露，使用香皂可以堵住沙眼。 ☀牙膏 可以修复，轻微的划痕。 ☀凡士林 天窗滑动异响，涂抹在滑轨上。 ☀风油精 除去年检胶印。 困了，疲劳了，涂抹一点，可以打起精神。安全驾驶。 ☀洗洁精 雨刮器永久，刮不干净玻璃。在玻璃上滴洗洁精。 ☀车内救生工具 救生锤。要砸侧面的玻璃，前挡风玻璃不宜敲碎。 视频演示链接：https://www.bilibili.com/video/BV1Zf4y197zg?from=search&amp;seid=11983733894389230310&amp;spm_id_from=333.337.0.0 ☀胎压表 测量胎压。夏天，22.5之间。22.3够用了。 1.冬天:以汽车轮胎标准气压为原则适当进行调高 0.2 bar左右。 2.夏天:按汽车轮胎标准气压下限。夏天车子露天停放,气压一般可以比标准低0. 1 bar左右,以免高温爆胎。 胎压高了，会比胎压低要好，高速行驶，车子爆胎可能是由于胎压低而引起的，是由于胎压过低，轮胎支撑不了。轮胎胎压在标准胎压之上，一般情况问题不大。建议胎压是2.3，打到2.4 2.5，没问题，车子还比较省油。天气冷，胎压降到2.2，跑起来就正常了。 保持4个胎压，胎压均衡，否则会出现异常磨损的情况。更应该关注。保持正确的胎压，而不是绝对的胎压。 冬天和夏天都始终保持标准胎压才最靠谱，最省油，最方便。 ☀小圆镜 安装看需求，对倒车，行驶侧边车道的观察。扩大视野范围。 正确安装方法：外下角。 贴在后排，可以帮助老人小孩，上下车。 ☀牙膏 车子小划痕，不露出底漆的情况下。浅度。 ☀可乐 清理大灯。 ☀电子器件使用 ☀启动按键 按一下，通电。可以使用中控屏幕，手机充电，放音乐。等姑娘😄. 通电后，再按一下，启动自检。自检是一个循环的过程，启动时，开车时，都会进行自检。 踩住离合器，按一下，启动！ ☀A/C ♣夏天快速制冷 开空调，打开A/C和内循环，制冷一级棒。 ♣冬天玻璃不结霜 冬天，关闭A/C,打开外循环，玻璃不容易结霜。 ♣下雨天玻璃不起雾 打开A/C和外循环。吹风模式调整到吹玻璃。 ♣外部废气不进入车内 堵车开空调，打开A/C,和内循环。 ♣停车关闭？ 停车，熄火前，提前关闭A/C，能够防止霉变异味，将空调管路吹吹干。大多数车子都有鼓风机延时关闭功能。自动会搞定。 所以比较新的车型，直接熄火走人就可以了。 ☀内外循环 能够使用内循环，尽量不用外循环。可以确保车内空气质量。 1、内外循环其实就是指的空气循环，如果你打开内循环，进气管道处就会有个挡板把管道给堵住，这个你只要打开车的引擎盖，在副驾驶位置就会发现。挡联通的管道被封住后，这就意味着车内是没有外部的空气进入的，仅仅是车子内部的空气进行循环使用，通常来说打开内循环后，人都会感觉比较闷，而且会瞬间感觉温度升高了不少。因此，一般是在夏天或者冬天的时候，你要迅速降温或者升温的话，打开内循环是最好的，因为空气不流通，所以空气也可以被短时间内降温或者升温。当然堵车情况下，最好也是使用内循环，以免尾气被吸入车内。 2、外循环，其实来说就是外部的空气通过风机被吸入到车内部，打开后，你会感觉呼吸比较顺畅，而且会明显感觉有异样的空气进入，比如周围空气恶劣，或者化工厂排出的废气。都会随着风机进入到车内，因此通常来说，外循环主要是为了通风换气去打开的，假如周围环境恶劣，灰尘比较大的话，就不建议使用外循环，不然到时候开车的话注意力都不容易集中。开外循环，可以把人呼出的蒸汽排出车外，而外面的冷空气不容易凝结的。 什么时候使用内循环？ ● 车外空气质量差，污染严重情况。比如：尘土飞扬道路、拥堵的道路、化工厂附等有异味路段，这些情况就需要使用内循环来避免外部空气进入车内。 ● 夏季用车。为使空调快速降车内温度，可以使用内循环。 ● 冬季用车，让车内更温暖。 什么时候使用外循环？ ● 长时间使用内循环，又不方便打开车窗，是可以定期开启外循环，使新鲜空气进入车内。 ● 车内乘员较多的情况下。使用外循环，既可以保持空气清新，又能避免车内空气湿度过大导致车窗结雾。 内外循环使用方法： 1、利用外循环，可以呼吸到车外的新鲜空气。高速开车，时间长了就觉得车内空气浑浊，人感觉困倦，使注意力不集中，这时应该打开外循环，使外面的风进来;冬天送暖风感觉太热，可关掉风机，打开外循环，既保持车内温度，又有新鲜空气，感觉会更舒服。 2、如果开空调是为了降低车内温度，此时就不要开外循环。可隔段时间开一下外循环，更换点新鲜空气。夏天用空调，要打开内循环。如果开外循环，车外的热空气源源不断流进车内，温度反而会升高。 ♣跑高速和长途 不要一直使用内循环。时间长了，车内氧气浓度会下降。人就容易犯困。 ♣跑城市道路 多用内循环。隔绝外界污浊的空气。特别式堵车时。尾气大量排放，一氧化碳浓度过高。 ♣雨天开车吹空调 空气潮湿。 外循环。快速降低车内外温差。防止挡风玻璃和侧窗玻璃起雾。如果挡风玻璃已经起雾，开空调时，开外循环，加速除雾效果。 ♣乡村道路，灰尘滚滚 内循环。以免吸入大量灰尘。加快内饰老化。 ♣停车不熄火，睡觉开空调 开内外循环，都很危险。外循环时间长了，容易一氧化碳中毒，内循环时间长了，容易缺氧昏迷。 停车休息，窗户最好打开2指的缝隙，既能透气，也能防盗。 ♣空调车里有臭味 使用固特威，杀菌除臭剂。 ☀儿童锁 一般开关位置，都在车门门锁下面。有个小小的拨杆。有个儿童锁图标提示。 ☀遮阳板 能遮挡，正面和侧面的光。可以旋转。 ☀后视镜防眩目 有自动和手动，需要研究。 ☀ESB 防侧滑系统，默认开启。点亮后出现OFF字样就是关闭状态。如果关闭，紧急避险、急转弯容易侧滑。平时不要乱按。 开启ESB情况：1.脱坑陷入泥路、雨雪天起步需要较大马力。2.年检。 ☀暖风系统 刚启动，风速太大，暖风热的慢，发动机带来的热量时固定的，所以风太大没实际作用，并不会提高温度。手动空调1~2档，自动空调在中间位置。 暖风不能吹太长时间面部，容易口干，犯困，影响注意力集中和行车安全。 最好的吹风方向是脚部或者前挡风玻璃。吹向脚步没热空气往上走，会使车内整个温度非常平均，身体感受没有温差，就会很舒服。吹挡风玻璃，还有助于前档除雾，增加视线清晰度。 一直使用内循环错误。夏季使用制冷效果会好一点。冬季人坐在这种，呼出的水蒸气很多，车内空气潮湿，潮湿空气遇到前挡风玻璃非常冷，容易结霜产生雾气，还容易提高二氧化碳浓度升高，车内会非常闷热，开车时间久容易犯困打瞌睡，影响行车安全。所以要开外循环，1.防止前挡风起雾。2.空气清新不容易犯困。 最正确冬季使用方式：打开前挡风除雾，这时候会自动开启A/C，内循环，如果没了雾气，这时候关闭A/C，开启外循环。节省油耗，又起到了非常棒的将车内潮湿空气换出防起雾和清新空气作用。有些车自动关**A/C**。 ☀零件 ☀后视镜 后视镜后面可以撬开，更换后视镜。 冬季会出现结冰的时候，把后视镜自动收拢功能关闭。 ☀雨刮器 搬动卡扣，往下拔。 ☀空调滤芯 打开副驾驶手套箱，轻轻往外一拉，就可以更换了。 ☀液压撑杆 上方撬动，取下卡扣。就可以更换整个液压撑杆了。 ☀车钥匙没电 用指甲，划开钥匙的后壳，就可以更换里面的电池。就可以打开车门了。 ☀贴膜 选择轻度隐私和中度隐私就可以了。对安全驾驶比较好。 ☀ ☀结构知识 ☀P档结构和原理 差速器齿轮，变速箱壳体钢抓，挂入P档时，镶入齿轮，和齿轮发生结合。 车轮不会像同一个方向转动，起到驻车作用。 ☀S档 动力输出最强劲。急加速或者超车。 ☀L/M档 低速档。相当于手动变速器1档。当需要上长坡，下陡坡使用。M档多加了±档位功能。 ☀供电 夏天停车熄火前，一定要关掉空调吗？不一定。 车子启动时，空调等用电器会自动关闭，保证启动电压。 ☀保养 关键的几个点。 最好的就是，根据保养手册推荐的里程，或者周期进行更换。足够了。 机油，或者其他某些配件，并非越贵的越好，选择正确的油液和适合的配件，省钱又省心。 4S店避坑推荐保养： 1.轮胎养护 2.涡轮养护 3.清洗节气门 4.清洗积碳。药液清洗，不好，三元催化之类的堵，造成三元催化中毒。 5.各类添加剂，各种抗磨，添加剂。 ☀机油 金美孚机油。 每次保养更换。按照说明书选购。 ☀机滤 每次保养更换。按照说明书选购。 ☀火花塞 2万公里更换。 ☀空气滤芯 2万公里。 ☀空调滤芯 每次保养。 ☀冷却液 coolANT字母的盖子。 保证在最大值和最小值之间。 不确定防冻液颜色，可以添加万能型防冻液。固特威，全兼容型防冻液。应急可以加蒸馏水。 判断防冻液更换：铁锈的颜色暗红，暗橘色，表示发动机水道开始生锈。5、6年就换,油温过高导致变黑色。测试防冻液冰点，如果指数超过下线。 ☀玻璃水 用两年左右。 夜间气温在0度以下，换成防冻玻璃水。 ☀制动液 首次保养3年才换。 ☀变速箱油 6万公里更换。 ☀轮胎 更换准则：夏季轮胎花纹深度小于3mm，冬季小于4mm就可以换。差不多是最低标准的两倍。轮胎年限长了也是要更换的，超过6就需要换了，超过10年不能用了。 气温持续低于7度，可以换上冬季胎。如果不换，冬季胎压可以比实际胎压低一点点。 轮胎品牌的专卖授权店，买到正品。价格比4s店便宜。 检查轮胎有没有装配不当，和钢板弹簧，挡泥板之间有没有摩擦，轮胎胎压，外表有无刺伤，磨损。清理轮胎花纹钩子里的石子和异物。 ☀雨刷片 也可以自己买到。 ☀离合器油 ☀转向助力油 ☀电池水 ☀汽油滤 ☀洗车 每两周洗一次比较合理。看个人需求。最核心的是用的毛巾好不好，用的洗车液好不好。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"SSMS使用笔记","slug":"技术知识/数据库/SQLServer/SSMS使用笔记","date":"2021-08-24T22:50:05.000Z","updated":"2021-08-24T22:50:05.000Z","comments":true,"path":"posts/2021/08/24/6d1095d31093/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/08/24/6d1095d31093/","excerpt":"管理SQLServer数据库工具。","text":"管理SQLServer数据库工具。 ☀快捷键 快捷键 说明 ctrl+N 新建查询窗口 ctrl+u 选择数据库 ☀常用操作 ☀附加数据库 获得数据库MDF与LDF文件。MDF为数据文件，LDF为日志文件。 在解压之后，请查看本系统用户是否是对着两个文件为完全控制，如果不是完全的控制，那么在附加的时候，将会报错，导致附加数据库失败，而查看方法也是很简单的，直接在文件上右击--&gt;属性---&gt;安全---&gt;users(计算机名\\users)，查看权限是否为 完全控制，如果不是完全控制，点击编辑即可看到如下： 请将解压后的两个文件都执行以上的操作 附加数据库的时候，用到的工具是 Microsoft SQL Server Management Studio附加操作点击数据库右击---&gt;附加 然后点击添加按钮，选择需要附加的mdf文件。 ☀删除数据库 如果存在链接，无法删除。勾上关闭现有链接，再删除。 ☀选择数据库 ☀分离数据库 勾选删除链接、更新统计信息。断开所有客户端连接和刷新正在执行的操作。 | 分离之后，数据库从界面消失。 ☀修改身份验证登录模式 选中数据库，右键属性，安全性。 ☀创建账号 安全性——&gt;登录名，右键创建。取消勾选强制密码过期再创建。 ☀登录和用户配置 使用windows用户登录： 选择数据库连接名字，右键，属性设置。 查看用户名，设置修改密码，添加账户。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQLServer","slug":"SQLServer","permalink":"http://aner1001.gitee.io/tags/SQLServer/"}]},{"title":"糖醋排骨","slug":"生活知识/做饭/糖醋排骨","date":"2021-08-23T11:43:28.000Z","updated":"2021-08-23T11:43:28.000Z","comments":true,"path":"posts/2021/08/23/e16d4931f904/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/08/23/e16d4931f904/","excerpt":"","text":"☀准备材料 ☀肋排 500G ☀姜片 ☀清水 500ml ☀料酒 15ml 一勺 ☀食用油 10ml ☀冰糖 50g ☀热水 300ml ☀生抽 2勺 ☀香醋 3勺 ☀盐 1g ☀制作步骤 ☀1.切菜 排骨均匀切块 姜片 ☀2. 煮排骨 姜3片，大火焯水。 捞出备用 ☀3. 炒排骨 食用油10ml 冰糖50g,炒糖色。 颜色，淡红褐色： 放入排骨翻炒挂糖 姜3片 继续翻炒，挂糖。 加入热水300ml，抹过排骨不到。 ☀4. 调醋料 料酒1勺。 生抽2勺。 香醋3勺。 倒入调味汁。 ☀5. 炖排骨 小火30分钟。 ☀6. 收汁 盐1克。 翻炒一下： 大火收汁 ☀7.装盘 浇入酱汁： 撒上白芝麻：","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"做饭","slug":"生活知识/做饭","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%9A%E9%A5%AD/"}],"tags":[]},{"title":"回锅肉","slug":"生活知识/做饭/回锅肉","date":"2021-08-22T00:00:51.000Z","updated":"2021-08-22T00:00:51.000Z","comments":true,"path":"posts/2021/08/22/e7a43e4c7dbe/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/08/22/e7a43e4c7dbe/","excerpt":"回锅肉的制作攻略。","text":"回锅肉的制作攻略。 学习视频链接： https://www.bilibili.com/video/BV153411z75b?from=search&amp;seid=7914181838737081177 ☀准备材料 ☀猪的连皮坐墩肉/五花肉 200克。 图：坐墩肉 五花肉： ☀蒜苗 100克 ☀豆鼓/甜面酱 永川毛霉豆鼓9克。 甜面酱和豆鼓2选1。 ☀酱油 黄豆酱油3克。非生抽和老抽。 中坝黄豆酱油。 ☀豆瓣 郫县豆瓣30克。是指按郫县豆瓣工艺的老豆瓣。不能是红油豆瓣。 用刀切碎。 用水调一下。防止下锅糊了。 ☀尖椒 可额外添加： ☀小米辣 可额外添加： ☀制作步骤 ☀1.烙猪皮 锅烧红，洛。 程度： 刮洗干净： ☀2.煮猪肉 冷水下锅。加入姜、葱、料酒、花椒。 水开后改成中火煮到断生。煮熟不煮火巴，指食物熟透而柔软。煮火巴之后，敬神不好看。不好切片，下锅容易断。 20分钟左右。 放入冷水中，会使肉更加紧致，更好切一些。把五花肉切成薄片。 ☀3.切菜。 猪肉切成薄片。 蒜苗把杆微微拍一下，切成马耳朵。 小米辣和尖椒 小米辣 尖椒 ☀4.炒菜（方法1） 这种回锅肉的做法是煸炒，火不要大。 放入色拉油，油温150度。 放入肉片和盐0.5克。 炒到肉吐油的时候。加盐。 放入老豆瓣炒出红亮。 加入豆鼓炒香。 加酱油、白砂糖炒出香味。 加白糖的量。 放青蒜苗梗炒断生，再放另一半蒜苗叶和盐。第一份盐给猪肉，第二份盐给蒜苗。 炒匀出锅。 ☀5.炒菜（方法2） 五花肉炒法。 锅中不放油，放入切好的五花肉，煎至微焦黄。 五花肉本身油脂丰富所以不用加油，等它自己出。 将肉推至一旁，加入一勺蒜末，一勺郫县豆瓣酱，半勺甜面酱。如果肉比较多，可以再多方半勺甜面酱。 和肉混合翻炒均匀，全程开大火爆炒。 加入一茶勺糖，一勺生抽，少许鸡精。 加入蒜苗梗，比较不好熟 ​ 翻炒，超出蒜苗的香味，再加入刚切好的蒜苗叶、尖椒、小米辣。 开大火来回翻炒，炒至蒜苗叶微软，闻到蒜苗香气，出锅、装盘。 撒上白芝麻做装饰。 五花肉一定要煎出油脂才香。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"做饭","slug":"生活知识/做饭","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%9A%E9%A5%AD/"}],"tags":[]},{"title":"游泳","slug":"生活知识/经验感悟/游泳","date":"2021-08-15T11:11:33.000Z","updated":"2021-08-15T11:11:33.000Z","comments":true,"path":"posts/2021/08/15/e23f4735ce72/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/08/15/e23f4735ce72/","excerpt":"游泳技巧学习。","text":"游泳技巧学习。 ☀跳水 ☀路上练习 第一个动作：手臂夹紧头，脚尖向上蹬。 第二个动作：脚尖向上蹬的时候，手臂往上送。 找到这种感觉，只要一往前，脚尖就蹬起来。 第三个动作：蹲跳。蹲下来，背部挺直，跳起来一瞬间夹紧头，手臂往上送。这个动作对找流线型有很大的帮助。 手臂的技巧。 整体动作。十次为1组，做四组。 ☀注意重点 加紧头。 头要低到手下。 头低下去之前吸好气。登的时候鼻子慢慢出气。 脚趾头一定要钩住池边。最少三个指头勾紧。 弯腰屈膝。臀部网上提。 手指头朝前下放。 眼睛看着脚尖。 人慢慢往前倒。倒到控制不住的时候，腿推用力蹬。腿往前登就不会插到池底。 腿部发力。跟出去。 找到那种感觉，有角度的入水。从上往下传递的入水。要感觉倒入水。 插到1米左右是最好的。 ☀常见错误修复： ☀肚皮先入水 收腹。 指尖先入水。 大拇指要用力抓住池边。 ☀脸趴到水 收下巴。尽量做到下巴贴胸即可。 眼睛看水底。 ☀跳水教会弯曲 站在岸边直立入水练习。（注意：保持身体绷直。） ☀模拟 站在泳池岸边脚，大拇指勾住岸边，模拟跳发练习。 注意流线型，指尖先入水。脚尖最后入水。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"eclipse使用笔记","slug":"技术知识/工具/eclipse使用笔记","date":"2021-08-03T19:00:42.000Z","updated":"2021-08-03T19:00:42.000Z","comments":true,"path":"posts/2021/08/03/e00a42073909/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/08/03/e00a42073909/","excerpt":"Eclipse快速入门(常见设置,快捷键,调试技巧)","text":"Eclipse快速入门(常见设置,快捷键,调试技巧) ☀常见设置 ☀配置JDK Window——&gt;Preferences——&gt;Java——&gt;Installed JREs——&gt;Add——&gt;Standard VM 编译器配置： Window——&gt;Preferences——&gt;Java——&gt;Compiler ☀配置Tomcat Window——&gt;Preferences——&gt;Server——&gt;Runtime Environments 选择Tomcat路径和运行JRE版本。 勾选Create a new local server,效果是，创建一个本地的Tomcat副本。并不会使用和启动指定目录的Tomcat。参数预计运行环境的一个拷贝。 Tomcat也是java程序，所以也需要jre。 ☀设置编码 Window——&gt;Preferences——&gt;Workspace 设置成UTF-8，是全局的设置。 ☀调整字体大小 Window——&gt;Preferences——&gt;General——&gt;Appearance——&gt;Colors and Fonts——&gt;Text Font——Edit ☀输入自动提示 Window——&gt;Preferences——&gt;Java——&gt;Editor——&gt;Content Assist 添加：abcdefghijklmnopqrstuvwxyz ☀设置默认浏览器 Window——&gt;Preferences——&gt;General——&gt;Web Browser 修改位置2： ☀修改JSP、HTML的默认字符编码 Web——&gt;JSP Files ☀常用操作 ☀调出视图 Window——&gt;Show View ☀显示行号 在左边行中，选中Show Line Numbers ☀目录折叠与文件定位 ☀创建JAVA工程 略 ☀创建Web工程 new——&gt;Dynamic Web Project module version 指的是servlet版本。 default output folder指的是编译后的class文件位置。 context root 为发布后工程根目录的名字，默认与工程文件同名。也是访问的地址。 context directory为web工程文件的路径。关键的webapp文件夹。 创建一个html文件: 运行java,Web项目: 勾选Always use this server when running this project. 一直运行这个项目在toncat服务器中。 ☀查看服务器配置信息副本 路径：.metadata.plugins\\org.eclipse.wst.server.core 文件结构和Tomcat很像： wtpwebapps存放了临时工程 ☀Web工程重命名 工程浏览器中，F2、alt+shift+r 快捷键进行重命名。 在工程的properties中，Web Project Settings 修改，上下文的发布路径。 ☀快速选中弹窗中的复选框，文本框。 alt+对应的下划线： ☀快捷键 快捷键 说明 Alt 调出选择下划线。 Ctrl+N 新建 Ctrl+M 最大化显示。 Ctrl+E 打开编辑窗口，查看目录。 Ctrl+PageUp 切换到当前编辑窗口的上一个窗口。 Ctrl+PageDown 切换到当前编辑窗口的下一个窗口。 Ctrl+1 显示调错面板。 Alt+Enter 打开工程、文件、包、等属性窗口。 Alt+shift+x 运行一个类。 Alt+shift+d debug调试一个类。 Alt+/ 智能提示。 shift+回车 换行 ctrl+shift+y 变成小写 ctrl+shift+o 导包 ctrl+shift+x 变成大写 ctrl+T 查看继承结构。 ctrl+shit+T 快速打开一个类(可以打开jar中的类) ctrl+shift+R 快速打开一个类(不可以打开jar包中的类) ctrl+D 快速删除一行。 ctrl+alt+↑ 向上复制一行。 ctrl+alt+↓ 向下复制一行。 ctrl+o 查看当前类的属性及方法。再按一边显示市父类中的属性及方法。 ctrl+F11 运行main方法的快捷键。 F11 使用DEBUG模式运行。 ctrl+c 可以复制类、整个工程。 alt+shift+R 变量名、方法名、文件、工程重命名。 F2 工程名，文件名。 ctrl+shift+→\\← 光标单词之间选中跳动。 ctrl+/ 单行注释、取消单行注释。 ctrl+shift+/ 多行注释。 ctrl+shift+\\ 取消多行注释。 alt+shift+s+s,r,o 唤出生成代码。 alt+shift+f 格式化代码。 alt+shift+z+y,3 唤出包裹住代码块。 alt+shift+m 抽取方法。如果选中代码中带有变量，会生成带有参数的方法。如果选中一个表达式赋值语句，会生成带有返回值的方法。 alt+shift+L 抽取变量。在表达式上使用，会将表达式，写成赋值变量的形式。就是将表达式抽取成一个变量。 ctrl+1+convert... 将局部变量转换为成员变量。选中局部变量，ctrl+1，选择convert...，转换为成员变量。 ctrl+1+split 分离变量声明。将表达式赋值语句中定义的变量，单独分离定义。 F3 转到定义，可以是变量、方法、类。或者ctrl+鼠标左键。 alt+← 返回上一次光标所在位置，即使在不同文件中。 ☀调试 ☀1. 打断点 在行中左键，双击。 ☀2. Debug运行 程序中，右键菜单，选择Debug As. ☀3.视图查看 进入debug视图 三个按钮分别对应debug、java、javaee视图。 左侧Variables为变量视图。 ☀4. 调试按钮 F5跳入方法。 F6按行执行。 F7跳出方法。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://aner1001.gitee.io/tags/eclipse/"}]},{"title":"Windows系统重装","slug":"技术知识/计算机/Windows/Windows系统重装","date":"2021-07-28T07:53:27.000Z","updated":"2021-07-28T07:53:27.000Z","comments":true,"path":"posts/2021/07/28/f3e01b384e12/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/07/28/f3e01b384e12/","excerpt":"记录重装Window10系统的过程，和使用工具。需要安装的软件备份。","text":"记录重装Window10系统的过程，和使用工具。需要安装的软件备份。 ☀安装准备 ☀系统镜像 ☀下载 镜像下载地址：https://msdn.itellyou.cn/ 下载 64位 business 包含了企业版、专业版功能。 ☀Hash校验 检验文件hash值，目的是确保下载的文件没有损坏。从MSDN下载链接下方，可以下载iHasher。 使用方法： 选择镜像文件，进行校验计算Hash，将网站上的Hash复制对比， ☀驱动程序 ☀机械师T90 下载官网：https://www.machenike.com/download ☀U启动工具 ☀微PE 官网下载：http://www.wepe.com.cn/download.html?tdsourcetag=s_pcqq_aiomsg ☀优启通 官网下载：https://www.upe.net/ ☀安装步骤 ☀1）制作U启动盘 1#选择USB方式。 12#勾选包含DOS工具箱、个性化盘符图标#点击立即安装进U盘 1#制作完成后，得到EFI盘是PE的系统分区不能动，另外一个空的，有一个可当U盘使用，放入镜像，测试工具、驱动等软件。 ☀2）U盘插入 123#注意事项：#1.台式机，将U盘插在主机后置面板上。#2.笔记本，U盘随意插。 ☀3）进入BIOS 开机时，不断按DEL、F2、F10、F12等按键，不同电脑或者笔记本进入BIOS方式不同，根据实际操作。 修改启动项： PE支持UEFI、Legacy，双模式启动。UEFI对应GPT分区、Legacy对应MBR分区。 看主板支持哪个。将U盘启动置于第一个。 保存并重启。 ☀4）进入微PE操作系统 使用微PE自带的分区工具进行分区操作。 重新分区步骤: 选中磁盘，右键删除所有分区。保存更改。这一步会清空磁盘所有数据。 查看转换分区表类型，如果时UEFI启动的，必须转换为GPT，如果是Legacy启动，转换为MBR。选中磁盘，右键转换即可。 右键快速分区。根据实际使用情况。系统盘C盘至少需要40个G。C盘推荐60~100个G。C盘系统标卷名称最好不要动。其他可修改。 快速分区，默认勾选创建新ESP、MSR分区。 快速勾选，对齐分区到此扇区数的整数倍，数值默认2048。固态硬盘的4K对其。不勾上会减低固态硬盘性能，而且会降低使用寿命。 点击确定，等待运作，出现磁盘信息。就证明分好区了。 进入之前保存在U盘中的镜像文件，右键打开，点击装载，双击setup.exe程序。 ☀5) 安装和初始化设置 选择Windows10专业版。 自定义安装。 一定要将系统选择安装在，分区中的系统盘，C盘中。 进入Win10初始化界面。区域设置默认选择中国，输入法默认选择微软拼音，不添加第二种键盘布局，继续执行有限设置。用户名最好使用英文。不创建开机密码，直接使用下一步。 ☀6) 桌面唤出此电脑和副磁盘分区操作 ☀唤出此电脑： 右键——&gt;个性化——&gt;主题——&gt;桌面图标设置。将计算机勾上。 ☀副磁盘分区： 此电脑右键——&gt;管理——&gt;磁盘管理。右键——&gt;新建简单卷——&gt;无脑下一步。 ☀常用软件备份 ☀Windows常用系统工具 软件名 作用 office 办公软件 wps 办公软件 火绒 安全软件 geek 卸载工具 7z 解压缩工具 CleanMyPC 清理垃圾文件 unlocker 解绑进程占用 百度网盘 网盘软件 dll全安装包 修复dll缺失问题 谷歌浏览器 浏览器 星愿浏览器 浏览器 大黄蜂播放器 视频教学播放器 emptyfoldernuker 删除空文件夹 Everything 按名称快速索磁盘内的任何文件 uTools 按名称快速搜索可执行程序，并有各种好用插件可安装。 FileConverter 右键功能中添加文件格式转换 Ghelper 谷歌浏览器，访问谷歌翻墙插件。 QQ QQ聊天 微信 微信聊天 PotPlayer 纯净播放器 SwitchHosts 设置域名IP映射。 有道词典 词典查询 QQ音乐 音乐软件 网易云音乐 音乐软件 v2rayN 飞机场 JiJiDown B站视频下载工具。 ☀笔记工具 软件名 作用 GifCam 捕捉屏幕，gif制作工具。 Mybase7 wiki文档记录工具。 PicGo 图床工具 Typroa Markdown语法记录工具。 eDiary 良心Windows笔记软件 ☀开发工具 软件名 作用 IDEA 集成开发工具 CentOS镜像 Linux安装系统 VMware 虚拟机 SecureCRT Linux系统链接客户端 JDK Java开发工具包，运行环境。 SQLyog 数据库链接工具 Maven 项目构建工具 Tomcat 服务器 Atom github社区开发的编辑器，适用前端。 Git 版本管理工具 jd-gui 反编译工具 Lepton gist管理工具 Mysql 数据库 NodePad++ 记事本型编辑工具 nvm nodejs版本工具 Postman 测试工具 SoapUI 测试工具 VSCode 前端编辑工具。 Ruby Ruby脚本语言运行环境","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://aner1001.gitee.io/tags/windows/"}]},{"title":"Redis学习笔记","slug":"技术知识/数据库/Redis/Redis学习笔记","date":"2021-07-10T13:33:53.000Z","updated":"2021-07-10T13:33:53.000Z","comments":true,"path":"posts/2021/07/10/10f923e8abfb/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/07/10/10f923e8abfb/","excerpt":"计算机就是数据结构和算法.","text":"计算机就是数据结构和算法. redis的学习网站： redis.cn redis.io db-engines.com API代码的学习： 1231. redis.io 的client 中有JAVA语言的客户端：jedis、lettuce等可以分别访问他们的github学习2. 另外是基于spring的使用，主动通过spring.io官网学习spring.data.redis3. spring.io中: https://spring.io/projects/spring-data-redis ☀基础概念 ☀为什么要使用Redis 文件里 数据 data.txt，当查询某个字段的时候grep awk，java但是随着文件变大，速度变慢为什么？ 因为：硬盘i/o成为瓶颈。查询有一个过程，取出比较。主要取决于取出的速度。 💖常识： 磁盘： 寻址：ms 带宽：G/M 内存： 寻址：ns 带宽：很大 秒&gt;毫秒&gt;微秒&gt;纳秒 磁盘比内存在寻址上慢了10W倍 I/O buffer：成本问题 磁盘与磁道，扇区，一扇区 512Byte带来一个成本变大：索引 windows操作系统，一个扇区4K，4K 操作系统，无论你读多少，都是最少4k从磁盘拿，4K对其。 😘关系型数据库特性 磁盘中:数据+索引，内存中B+T树。 关系型数据库建表：必须给出schema 类型：字节宽度。 存：倾向于行级存储。 (✿◡‿◡)面试题： 数据库：表很大，性能下降？ 如果表有索引 维护索引会使得，增删改变慢。 查询速度呢？ 1个或少量查询依然很快。 并发大的时候会受硬盘带宽影响速度。 💕技术选型 数据库对比网站：https://db-engines.com/en/ 架构师： 技术选型 数据在磁盘和内存体积不一样，SAPHANA内存级别的关系型数据库2T，这种造价太高。 取折中的方案，使用缓存 memcached redis 速度主要是由个基础设施影响： 冯诺依曼体系的硬件 以太网，tcp/ip的网络 ☀Redis简介 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 😎Redis和memcache的区别 总结一句话：计算像数据移动。 ☀字符集的的使用 字符集 ascii，其他一般叫做扩展字符集。 扩展： 其他字符集不在对ascii重编码。 0xxxxxxx，以0开头的肯定是ascii编码，其他字符集一遇到就默认使用ascii了。 你自己写一个程序，字节流读取，每字节判断。 ☀Redis安装 😊命令执行过程： 1234567891011121314151617181920212223242526271，yum install wget2,cd ~3,mkdir soft4,cd soft5,wget http://download.redis.io/releases/redis-5.0.5.tar.gz6,tar xf redis...tar.gz7,cd redis-src8,看README.md9, make ....yum install gcc ....make distclean10,make11,cd src ....生成了可执行程序12, cd ..13,make install PREFIX=/usr/local/redis14,vi /etc/profile... export REDIS_HOME=/opt/mashibing/redis5... export PATH=$PATH:$REDIS_HOME/bin..source /etc/profile15,cd utils16,./install_server.sh （可以执行一次或多次） a) 一个物理机中可以有多个redis实例（进程），通过port区分 b) 可执行程序就一份在目录，但是内存中未来的多个实例需要各自的配置文件，持久化目录等资源 c) service redis_6379 start/stop/stauts &gt; linux /etc/init.d/**** d)脚本还会帮你启动！ f) /etc/redis/ 目录中会生成redis启动的配置文件，以后也可以通过，redis-server 搭配此配置文件进行服务的启动。17,ps -fe | grep redis ☀卸载Redis find / -name redis 查找redis的文件目录，删除即可。 ☀常用命令 ☀查看Redis 查看Redis的bin被安装位置 12whereis redis-cliwhereis redis-server ======= 测试结果，只会找配置在环境变量中的目录下的。 查看Redis的进程： 1ps -ef |grep redis 查看Redis版本： 1./redis-server -v ☀登录Redis 1./redis-cli -h IP地址 -p 端口 -a 密码 -c --raw 参数 描述 -c 开启reidis cluster模式，连接redis cluster节点时候使用。 -p 端口号，不写此参数就是用默认端口 -h ip地址，不写，默认本机。 --raw 使用客户端的指定的字符集进行解码显示。 ☀启动Redis 12345678#如果在服务目录/etc/init.d/****中注册了脚本.service redis_6379 start#使用客户端命令的启动方式，搭配配置文件即可。./redis-server /etc/redis/6379.confg#如果配置了环境变量,手工启动测试,会将当前启动的目录作为,持久化目录,所以必须先创建目录.redis-server --port 6379 参数 描述 --loadmodule 加载模块启动服务 ☀停止Redis 强制停止法： 123ps -ef | grep redis #查看端口占用的进程kill -9 进程的pid #强制停止进程 登录客户端停止法： 1234567# 登录命令./redis-cli ......#停止shoutdown#或者联合起来使用./redis-cli -p 6379 shutdown 服务停止法： 1service redis_6379 stop ☀查看Redis配置： 12redis-cli ... #登录redisCONFIG GET * #获取配置。 ☀conf配置文件 引入公共的配置： 加载模块配置 绑定能够访问的IP地址 默认是本机。如果需要在虚拟机外部的程序访问需要修改为： 1bind 0.0.0.0 是否允许外部主机访问。 是否为后台服务模式 启动后，进程的pid文件。放在这个目录下。通过pid文件判定进程是否在运行。 日志级别 日志存放在那个目录下： 库的数量： 需要密码登录： 将一些敏感的命令重命名，屏蔽。 允许最大连接数： 最大内存，根据经验一般是1G~10G。 ☀内核演变过程 ☀演变 🤢阻塞时期： cpu只有1颗 JVM: 一个线程的成本 1MB 线程多了调度成本CPU浪费。 内存成本。 🤔非阻塞时期 同步非阻塞 NIO 如果有1000fd，代表用户进程轮询调用1000次kernel，成本问题。 😃select，多路复用NIO时期。 fd相关数据考来考去。数据拷贝和传参调用成本比较高。 😎epoll，多路复用NIO时期。 共享空间mmap，降低了传参调用。 😍🤷‍♀️mmap，sendfile时期。 也就是现在的卡夫卡(kafka)技术的出现。减少数据拷贝和传参调用。 ☀Redis内核 redis的每个服务端都是，单进程，单线程，单实例。 单线程单进程的好处：“顺序”性，每连接内的命令顺序。 ☀Value结构和操作命令： 客户端help命令可以查看所有命令的用法。 ☀字符串 redis所有存储的都是字节流。如果时字符串，取决于客户端的编码格式，所以一定要统一编码。 每一个字节，都存在正反向索引： set 设置值。 get 获取key的值。 append 字符串追加。 setrange 从某个位置开始覆盖替换字符串。 getrange 获取一段字符串，从字节位置开始。所以用来取中文就不太方便了。 strlen 获取字节数量意义上的长度。 ☀数值 incr 从原来的数上+1. 用途场景： 抢购，秒杀，详情页，点赞，评论 规避并发下， 对数据库的事务操作 完全由redis内存操作代替 ☀bitmap 🤷‍♀️直接操作二进制位，牛逼。 setbit 针对某个二进制位进行设置（0/1）： 123setbit k1 1 1setbit k1 7 1setbit k1 9 1 bitcount 根据字节角标，计算二进制位1存在的数量。 bitpos 根据字节角标，命令返回字符串里面第一个被设置为1或者0的bit位。出现的起始位置坐标。 🐱‍👤注意：需要指定查询出现的0或者1。 BITPOS k1 0 0 第一个参数0指定查询0 第二个参数是0指定从第0个字节角标开始。 bitop 将多个bitmap进行逻辑计算操作，并将结果存入新的bitmap中。 ☀使用场景 有用户系统，统计用户登录天数，且窗口随机. 😏实现思路：用户id作为key，将二进制位1存储表示已登陆的实际第几天。 12345setbit sean 1 1setbit sean 7 1setbit sean 364 1STRLEN seanBITCOUNT sean -2 -1 京东就是你们的，618做活动：送礼物，大库备货多少礼物？ 假设京东有2E用户 僵尸用户 冷热用户/忠诚用户 活跃用户统计！随即窗口 比如说 1号~3号 连续登录要 去重 😏实现思路：天数作为key，二进制位代表实际用户，已登录，用1表示。 12345setbit 20190101 1 1setbit 20190102 1 1setbit 20190102 7 1bitop or destkey 20190101 20190102BITCOUNT destkey 0 -1 ☀List 链表结构，存在争对元素的正负索引。 😁口诀：同向命令模拟栈操作，逆向命令模拟队列操作。 lpush 从左向右存入元素。 lpop 按从左向右存入的顺序，弹出最后存入的数据。 lpush+lpop 同向命令模拟栈的使用。 rpush 从右向左存入元素 rpop 按从右向左存入的顺序，弹出最后存入的数据。 lpush+rpop逆向命令模拟队列的数据结构。 LRANGE 按照给定的范围，取出list中的值。lpush的list是栈取出。rpush的list是队列取出。 LINDEX 按照索引取出值。操作索引就相当于数组结构了。 LSET 按照索引设置对于的某个值. LREM 从list中,按照给定的数量,移除某个值.数量为正数,正向移除,为负数,逆向移除. LINSERT 在list中的某个元素前后插入元素。 llen 统计有多少个元素。 blpop brpop 阻塞弹出元素。实现消息的单播队列。谁先阻塞，谁先拿到元素。FIFO，先进先出。 开启窗口1 2 3 。 窗口1先进入阻塞，等待k1弹出。 窗口2后进入阻塞，等待k2弹出。 窗口3，压入元素。 窗口1，先收到弹出的元素。 窗口3，再压入元素。 窗口2，收到弹出的元素。 LTRIM 对两端外的数据进行移除和删除。不包括端的元素。 ☀Hash hset 存hash，键值对类型的数据。 hmset 在一个key的value中，存放多个，键值对类型数据。 hget 取出 hmget 根据key的values中根据多个键取值。 hkeys 取出所有的键。 hvals 取出所有的值。 hgetall 取出所有的键和值。 hincrbyfloat 将某个map中的值进行浮点数计算。 ☀Set 最有优势的就是去重。 sadd 集合中添加元素. smembers 显示集合中的元素. sinter 做多个集合的交集,不存放结果.,通过io将结果输出. sinterstore 做多个集合的交集,存放结果.没有io的交互.​👓​ sunion 做并集 sunionstore 做并集并保存. sdiff 差集.以第一个元素为基础取差集。 srandmember 随机数 SRANDMEMBER key count 正数：取出一个去重的结果集（不能超过已有集），超过已有集数量返回整个set集合。 负数：取出一个带重复的结果集，一定满足你要的数量。 如果：0，不返回 🎑应用场景： 抽奖： 10个奖品 用户： &lt;10 使用负数抽取。 &gt;10 使用正数抽取。 中奖：是否重复 解决家庭争斗！ 取名字的时候。5个名字，取10次(可重复) spop 将集合元素随机弹出。每次只弹出一个。 ☀sorted_set 理解排序的集合中，内部存储方式。对每个元素内置了一个分值，按照分值来排序的。 🎆**面试问题：**排序是怎么实现的，增删改查的速度？ ​ 答：使用了跳跃表的概念。吸收存储空间，换取未来的查询速度。 zadd 集合中添加元素。 zrange 取出集合中的元素，按照元素角标顺序。 zrangebyscore 通过分值范围取出元素。 zrevrange 逆向取出元素。从大到小取出。 zscore 通过元素取出分值。 zrank 通过元素，取出排名，就是索引角标。 zincrby 增加元素的分值，并且根据分值实时维护，元素的顺序。 🎗场景： 歌曲排行榜。倒叙显示。每播放一次+1. zunionstore 并集操作。 参数numkeys表示参数运算的key。 weight权重，与对应集合中的分值相乘计算后，参数与最后的集合与几何间的运算。 sum|min|max，集合元素的运算，默认为加法。 权重运算： 求最大值运算： ☀管道pipeline的使用 接住管道可以一次发送多个命令，节省往返时间。 建立socket链接 nc localhost 6379 将多个命令，通过管道传入redis执行。 1echo -e &quot;set k2 99\\nincr k2\\n get k2 | nc localhost 6379&quot; 一般用于冷加载，启动的时候，将一些预留的数据放到redis中。 ☀发布订阅 pubsub publish 向管道中添加元素。 SUBSCRIBE 接受元素,监听之后别人发的消息才能收到. ✌🤞**使用场景：**微信聊天窗口。 ☀事务的使用 永远记住一句话，速度快时特征，才会去选用Redis。Redis设计的事务也是往速度方面设计考虑，不是特别复杂。 为什么 Redis 不支持回滚（roll back） 如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。以下是这种做法的优点： ​ Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。 ​ 有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。 MULTI 开启事务 EXEC 关闭事务，谁的exe先到达，谁的事务就先执行。 WATCH 乐观锁。 例： 窗口1：watch k1 开启事务 窗口2：开启事务，修改k1,关闭执行事务。 窗口3：执行事务，由于k1被修改了，事务执行失败。 ☀Module布隆过滤器的使用 增加Redis的功能。 ☀安装bloom-filter 访问redis.io 点开modules 访问RedisBloom的githubhttps://github.com/RedisBloom/RedisBloom linux中wget *.zip yum install unzip unzip *.zip make cp bloom.so /opt/mashibing/redis5/ redis-server --loadmodule /usr/local/redis/redisbloom.so 。 🎨**注意：**此处启动，关联布隆过滤器的函数库redisbloom.so文件一定要用绝对路径。不能指定配置文件。才能启动成功。是属于临时启动。 ☀命令 BF.ADD 布隆过滤器中添加元素。 BF.EXISTS 验证是否存在。 返回1存在，返回0不存在。 CF.ADD 布谷鸟过滤器相关的命令。 ☀解决穿透问题 概率解决问题，不可能百分百阻挡，&gt;1% 1，你有啥 2，有的向bitmap中标记 3，请求的可能被误标记 4，但是，一定概率会大量减少放行：穿透 5，而且，成本低 ☀几种分布式实现方式 第三种最优。最符合分布式架构的思想。 ☀过滤器种类介绍 过滤器： bloom 布隆过滤器 counting bloom cukcoo 布谷鸟过滤器 ☀穿透了，但是数据库不存在的处理 client，增加redis中的key，value标记. 数据库增加了元素. 完成元素对bloom的添加. 过滤器相当于是对数据库存量的一个小的映射。 ☀Redis作为缓存 设置key的存活时长 1set k1 ex 50 #设置k1存活时长为50秒. ttl key 查看key剩余存活时长. 结果 描述 -2 表示key已经过期，或者不存在。 -1 表示key，一直存在。没有过期时间。 正数 表示key的剩余过期时间，单位秒。 expire 设置key的过期时间。单位秒。几秒后过期。 🎭注意：发生写会剔除过期时间。只针存在的key或者未过期的key有效。对已经过期，或者不存在的key设置无效。 🤗思考为什么会剔除过期时间？ 设置新值的时候，新值存放在一个新的物理地址中，key指向新的value的物理地址，过期时间针对的是老的value。 expireat 设置key在将来的某个时间节点过期。 time 取时间戳. ☀回收策略 当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。 以下的策略是可用的: noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 allkeys-random: 回收随机的键使得新添加的数据有空间存放。 volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。 ☀过期淘汰原理: Redis keys过期有两种方式：被动和主动方式。 当一些客户端尝试访问它时，key会被发现并主动的过期。 当然，这样是不够的，因为有些过期的keys，永远不会访问他们。 无论如何，这些keys应该过期，所以定时随机测试设置keys的过期时间。所有这些过期的keys将会从密钥空间删除。 具体就是Redis每秒10次做的事情： 测试随机的20个keys进行相关过期检测。 删除所有已经过期的keys。 如果有多于25%的keys过期，重复步奏1. 这是一个平凡的概率算法，基本上的假设是，我们的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。 ☀持久化 一个进程既要满足修改，又要满足持久化，成本很高。 Redis的存储层： 快照/副本 日志 ☀RDB ☀RDB持久化可实现的几种方式: ☀阻塞，数据拷贝: save命令实现 弊端:不能对外提供服务.明确关机维护的时候可以使用此命令。 ☀非阻塞，数据拷贝: 弊端:时点混乱.不使用此方式。 ☀非阻塞,fork 1.bgsave命令实现。 2.配置文件中给出bgsave的规则。 fork原理图： ☀优缺点： ☀😜优点： 时点性 类似java中的序列化 恢复的速度相对快 ☀🤔缺点： 不支持拉链 只有一个dump.rdb 丢失数据相对多一些 时点与时点之间窗口数据容易丢失。 8得到一个rdb，9纲要洛一个rdb，挂机了 ☀fork介绍 ☀进程的概念 父子进程之间的关系： 进程之间是数据隔离的。 父进程其实可以让子进程看到数据，当刚创建还未修改时，本质是子进程中的指针与父进程中的一致。 子进程修改变量，不会影响父进程。父进程中修改变量也不会影响子进程。 创建子进程需要考虑的维度： 速度。 内存空间够不够。 fork()方法特点： 速度快。 占用内存小。 fork过程图解： copy on write机制。 💖重点一句话：玩的都是指针。 ☀RDB配置： 12345save 900 1 #900秒内超过1条数据。save 300 10 #300秒内超过10秒数据。save 60 10000 #60秒内超过10000条数据。dbfilename dump.rdb #存储的文件名。dir /var/lib/redis/6379 #存储的文件目录。 ☀AOF ☀AOF概念： redis的写操作记录到文件中. ☀优点： 丢失的数据量少。 ☀AOF发展史 ☀4.0以前 弊端：体量无限变大，恢复慢。 RDB和AOF可以同时开启，如果开启了AOF 只会用AOF恢复。 日志方案：hdfs，fsimage+edits.log 让日志只记录增量 合并的过程。 重写策略–删除抵消的命令 合并重复的命令。最终也是一个 纯指令的日志文件。 ☀4.0以后 将老的数据RDB到aof文件中 将增量的以指令的方式 Append到AOF。 AOF是一个混合体 利用了RDB的快 利用了日志的全量。 重写命令执行之后，才会变成混合体。 增量日志+全量时点数据。恢复速度快，数据更全面。 ☀AOF配置： AOF记录时，写操作会触发IO。根据数据重要性，选择合适的写操作。 1234567appendonly yes #开启aofappendfilename &quot;appendonly.aof&quot; #文件名auto-aof-rewrite-percentage 100 #判断文件达到多大百分比时重写。auto-aof-rewrite-min-size 64mb #自动重写，初始的文件容量。appendfsync always #刷新buffer内存。appendfsync everysec #每秒刷新buffer内存appendfsync no #只有当buffer满时刷新内存。 往磁盘写操作内部理解： 只要是写操作，都会调用系统内核，内核中间有个buffer，缓冲区。就是用来减少交互次数。提升效率。 ☀实操 🙄配置文件相关： 设置redis，后台跑，还是前台阻塞跑。 1daemonize yes/no 设置输出日志文件路径： 1logfile /var/log/redis_6379.log 如果关闭了后台运行，日志也可以关闭，使其在控制台前台打印。 开启Aof追加模式 1appendonly yes aof-rdb混合开关 1aof-use-rdb-preamble no/yes 😏命令相关： 123save #阻塞方式rdb保存数据bgsave #后台非阻塞方式保存rdb数据 fork()，保存为rdb文件。bgrewirteaof #后台重写aof文件，命令整合。4，0之后为rdb+aof混合体。保存为aof文件。 ☀AFK原理 ☀单机存在的问题 单点故障。 容量有限。 压力。 ☀AFK策略图解 AKF X轴：每一台都是全量，有一台为主，其他为镜像。 Y轴：通过业务和功能区分。分段。 Z轴：每种业务，优先级，逻辑再拆分。将数据落到不同的片上。分片。 ☀AFK一变多，数据一致性解决方案，针对x轴。 通过AKF一变多 需要解决的问题：数据一致性！！！！ 反问自己：为什么一变多，解决可用性。 同步阻塞法 强一致性。但是，如果阻塞时间过长，破坏可用性。 异步法 弱一致性，如果异步处理出现失败异常，会丢失数据。 kafka法 redis与kafka之间为同步阻塞。redis和kafka之间为异步。由于kafka的可靠性，一定会同步到其他redis中。 期间可能会取到不一致的数据。但是最终数据会一直。强调：强一致性。 ☀主备、主从、主主概念区分： 参考博客链接：https://www.cnblogs.com/tankblog/p/11190598.html 主备 主从 主主模式 单点故障的情况不可避免，而且单副本的存储方案早已无法满足业务的可靠性要求，单机可靠性就就两个9，也就是一年大概有3.65天不可用。因此一般情况下我们至少也会上个双机存储架构。凡事最好有个plan B。 ☀主备 主：主机，备：备机。 主机的意思当然是以它为主了，读写都是主机上，而备机呢就是备用，默默的在背后吸收主机的数据，时刻待命着等待主机挂了之后取而代之(没这么坏哈哈)。因此在主机还活着的情况下，备机的唯一使命就是同步主机的数据，不对外提供服务。 image ❀优点：简单，主备之间只有数据同步，不需要考虑别的情况。就很简单的配置一下，再搞一台服务器就能组成主备架构了。 ❀缺点：备机等于就拿来备份，浪费了备机这台服务器的资源。上面说的不考虑别的情况指的是主机和备机它们两之间就只要复制数据. 但是有些情况我们人还是得考虑的：主机挂了如何让备机上。有三种选择: 人工切换。人工切换时效性不高，出了事情首先你得开机，登录远程一阵啪啪得好几分钟或者万一你在LOL，黑铁晋级青铜最后一把努力了几个月即将晋升倔强青铜的一刻！是吧。还要万一在深夜或者说…是吧。 引入中间件。例如ZooKeeper、keepalived。就跟好多房东把房子委托给中介一样，这中间件就是个中介。全权由中介来打理主机和备机，它会根据机子状态来判别这时候是不是该备机上了。(建议) 主机备机之间状态传输(咱不找中介了，自己来打理)，啥意思呢？就是除数据同步，主备之间还要有个状态传输过程，来让备机只要现在主机过得好不好，可以是主机主动推送它的状态给备机，或者是备机去索要状态。当状态拿不到或者不对的时候就开始主备切换。但是可能传输出现了波动啥的，导致备机误判了，然后备机升级为主机，这样就两主机了(下面会说主主的问题)。 ☀主从 主：主机，从：从机 从机和备机的区别在于它得除了同步数据之外还得干活，对外提供读的操作，你可以理解为它是仆从。但是仆从和备机一样也有翻身做主人的一天，所以它也在默默的等待着主机挂了，取而代之。image ❀优点： 充分利用了资源，嘿嘿不想备机这么爽了，还得出来干活，对外提供读操作。而且在主机挂了的时候，如果没任命新机主之前，读操作还是能用的。 ❀缺点： 客户端需要多个判断，也就是不同操作需要发放给不同服务器，我上图主机提供读写，有时候读写分离了，主机就提供写。 主从延迟，读操作分配给从库，就会存在数据同步的延迟问题，比如某个人注册了账号之后，登录走的是从机，这时候数据还未从主机同步过来，那可不让人很难受了。有关主从延迟问题的一些解决办法 和主备一样的切换问题。(参考主备) ☀主主 主主就是两台都是主机。同时对外提供读写操作。客户端任意访问提供的一台。 image ❀优点： ​ 主主的好处就是可以把写操作也分担一下，但是问题恰恰就出在写操作上，导致主主的架构有很大的局限性。 ❀缺点： ​ 例如主机A有个注册的插入操作，生成的id是50，同一时刻主机B也有个插入操作生成的id也是50。然后它们之间的数据同步了，你说是谁覆盖谁呢？谁覆盖谁都不对！ ​ 因此主主只适用于可以双向复制，覆盖的数据(例如用户登录生成的token)。但是我们平日里绝大部分的数据都不允许。 结语 这种双机存储架构一般而言应用于一些业务量不大的场景。主要还是为了存储的可用性。 ☀CAP ☀CAP概念 参考链接：http://www.ruanyifeng.com/blog/2018/07/cap.html 分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。 分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。 本文介绍该定理。它其实很好懂，而且是显而易见的。下面的内容主要参考了 Michael Whittaker 的文章。 ☀一、分布式系统的三个指标 1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。 Consistency Availability Partition tolerance 它们的第一个字母分别是 C、A、P。 Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。 ☀二、Partition tolerance 先看 Partition tolerance，中文叫做&quot;分区容错&quot;。 大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。 上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。 一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。 ☀三、Consistency Consistency 中文叫做&quot;一致性&quot;。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。 接下来，用户的读操作就会得到 v1。这就叫一致性。 问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。 为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。 这样的话，用户向 G2 发起读操作，也能得到 v1。 ☀四、Availability Availability 中文叫做&quot;可用性&quot;，意思是只要收到用户的请求，服务器就必须给出回应。 用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。 ☀五、Consistency 和 Availability 的矛盾 一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。 如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。 如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。 综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。 在什么场合，可用性高于一致性？ 举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。 一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。 实时证明，大多数都是牺牲了一致性。像12306还有淘宝网，就好比是你买火车票，本来你看到的是还有一张票，其实在这个时刻已经被买走了，你填好了信息准备买的时候发现系统提示你没票了。这就是牺牲了一致性。 但是不是说牺牲一致性一定是最好的。就好比mysql中的事务机制，张三给李四转了100块钱，这时候必须保证张三的账户上少了100，李四的账户多了100。因此需要数据的一致性，而且什么时候转钱都可以，也需要可用性。但是可以转钱失败是可以允许的，这时候舍弃可用性。 ☀Redis中主从CAP监控。 Redis中的集群关系，采用主从 监控法，实行主备切换，由多个监控程序集群监控主。 监控集群，势力范围n/2+1,一般使用奇数台。 奇数和偶数允许风险的个数一样，但是发生风险的个数偶数大于奇数，所以选择奇数台。 ☀Redis主从复制 使用经验： 从机如果是RDB模式，无论从机挂后重启或者从机运行时，每次同步数据，可从RDB文件中记录的ID给出偏移量，给到主，最后同步少量的增量。如果时AOF模式，每次同步数据都是全量同步。 同步数据时从节点会先删除老数据，再同步新数据。 ☀开启主从复制： ☀使用命令的方式： ❀redis运行时 SLAVEOF REPLICAOF host port redis5版本后可以使用。 ❀redis启动时： 不仅设置了主，还设置了AOF持久化的方式。 redis-server ./6380.conf --replicaof 127.0.0.1 6379 --appendonly yes 个人理解--参数相当于覆盖原有的配置文件中的参数。 ☀通过配置文件方式： 设置链接主redis的ip和端口： 1replicaof &lt;masterip&gt; &lt;masterport&gt; 设置链接主redis的参数： 1masterauth &lt;master-password&gt; 设置下载主最新rdb时，老数据是否可读。 1replica-serve-stale-data yes 设置从只读 1replica-read-only yes 设置同步方式，间接通过磁盘还是，直接网络IO。如果磁盘速度很慢，网络带宽很快就直接通过网络IO。 1repl-diskless-sync no 设置在同步增量数据时的存放队列的最大容量。如果超出最大容量，则直接使用全量RDB同步。 1repl-backlog-size 1mb #增量复制,至少写成功三条。主从异步同步数据的弱一致性，往强一致性上靠。 12min-replicas-to-write 3min-replicas-max-lag 10 ☀手工切换主备 12`REPLICAOF NO ONE` #设置替换的从机不再追随。`REPLICAOF host port` #在其他从机设置，重新追随指定的替换从机。 ☀监控哨兵Sentinel Redis 的 Sentinel 系统用于管理多个 Redis 服务器（instance）， 该系统执行以下三个任务： 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。 Redis Sentinel 是一个分布式系统， 你可以在一个架构中运行多个 Sentinel 进程（progress）， 这些进程使用流言协议（gossip protocols)来接收关于主服务器是否下线的信息， 并使用投票协议（agreement protocols）来决定是否执行自动故障迁移， 以及选择哪个从服务器作为新的主服务器。 虽然 Redis Sentinel 释出为一个单独的可执行文件 redis-sentinel ， 但实际上它只是一个运行在特殊模式下的 Redis 服务器， 你可以在启动一个普通 Redis 服务器时通过给定 –sentinel 选项来启动 Redis Sentinel 。 ☀启动哨兵 哨兵可以独立成一个进程，一个程序。也可以使redis服务进程包含哨兵这段代码。 独立进场方式： 1redis-sentienl &lt;配置文件&gt; redis服务方式： 1redis-server &lt;配置文件&gt; --sentinel 配置文件参考目录：下载的源码目录下。/usr/local/redis/redis-5.0.12 12port 26379 #配置哨兵端口号sentinel monitor mymaster 127.0.0.1 6379 2 #配置监听主机的ip和端口，投票的权重数。 ☀Spring整合Redis 官网学习:https://spring.io/projects/spring-data-redis ☀Redis的Sharing分片逻辑 akf主要解决单机问题: 单点故障. 容量问题. 访问压力. x,y,z轴思想. 主从复制，HA :从X轴,生成数据镜像,解决单点故障. 单节点：容量的问题,采取Sharing分片. ☀Y轴拆分方式 y轴按逻辑： 业务拆分 ☀Z轴Sharding分片逻辑: 按算法：hash+取模modula 缺点:取模的数必须固定 %3 %4 %10,影响分布式下的扩展性,每次添加新节点必须全局洗牌. 逻辑：random 随机 random算法,用于存放list数据.例如实现消息队列场景. 逻辑：kemata 一致性哈希,没有取模data，node 将node参数一致性hash运算,挂在一个环形的hash环上(实际是挂在树结构的节点上).每次有新的key进来,参数一致性hash运算,按照大小找到最近的node,存入机器. 将node物理节点的实际ip计算,换成ip+数字,造出多个代表实际主机的虚拟节点,挂在哈希环上,解决数据倾斜问题. ❀优点： 你加节点，的确可以分担其他节点的压力，不会造成全局洗牌 ❀缺点： 新增节点造成一小部分数据不能命中 1，问题，击穿，压到mysql 2，方案：没去取离我最近的2个物理节点 更倾向于 作为缓存，而不是数据库用！！！！ ☀Redis代理原理 代理可以解耦后面的Redis复杂度. ☀客户端直连Redis场景: redis 的连接成本很高 对server端造成的,客户端直连,在很多客户端的情况下,会造成连接数过多,增加了链接成本.三次握手消耗资源. ☀使用Proxy代理链接Redis场景: 达到负载均衡,减少链接的压力. 单台代理主机,可能访问量大的时候,proxy主机压力过大. ☀使用虚拟服务LVS,和keepalived监控,负载均衡代理Proxy LVS,虚拟出一个VIP地址. keepalived,监控LVS,使LVS高可用.监控proxy代理. ☀代理层的实现 Redis分片逻辑在代理层实现: 代理技术: twemproxy github地址:https://github.com/twitter/twemproxy predixy cluster(Redis自身) codis ☀Redis中的cluster分片技术 ☀预分区技术 由于三种分片算法,modula,random,ketama,一旦集群增加主机后,都会出现找不到原有数据情况.所以只能用作缓存.不能用作数据库. 实际分区两个,取模运算时,使用预分区个数10计算,算出的结果,在映射mapping下,转到实际主机. w 当集群中增加redis时,将mapping映射关系和对应数据实际分区同步转移到,新增的主机中. redis自身集群中.每台都会带有一个hash算法,和映射mapping,客户端随机访问主机,都会跳转到正确的redis机器上. 数据分治聚合操作很难实现事务 ☀Redis集群搭建 ☀twemproxy github地址：https://github.com/twitter/twemproxy 简单安装搭建步骤： 下载编译 123456git clone git@github.com:twitter/twemproxy.gitcd twemproxyautoreconf -fvi./configure --enable-debug=fullmakesrc/nutcracker -h 安装为服务 123456789101112cp nutcracker.init /etc/init.d/twemproxy #将源码路径script文件夹下的nutcracker.init,放入服务脚本文件夹中.nutcracker.init内容可研究参考.cd /etcmkdir nutcracker #创建脚本指定的启动配置文件夹.cp /usr/local/twemproxy/conf/* /etc/nutcracker/ #复制源码目录中的启动配置文件,进脚本指定的启动配置文件夹中.cp nutcracker /usr/bin/ #拷贝源码src目录下的nutcracker脚本到环境变量的目录中.service twemproxy start #启用代理服务. 缺点: 不支持keys *. 不支持watch ,multi事务. ☀predixy代理 github地址：https://github.com/joyieldInc/predixy predixy评测：https://blog.csdn.net/rebaic/article/details/76384028 特点: 可以监控一套主从复制,也可以监控多套主从复制. 可以支持事务,但是只支持单group. 简易搭建步骤: ☀下载 地址:https://github.com/joyieldInc/predixy/releases ​ 解压后,修改conf目录下的predixy.conf配置文件: ​ 解开端口号: ​ ☀哨兵sentinel代理配置: 通过哨兵发现并代理Redis. 1.引入哨兵配置: 只能引入一种: 2.配置主从哨兵: sentinel.conf Sentinels中配置哨兵的集群. ❀两套主从: Group为哨兵监控的主从组.名称为,哨兵配置文件中的主从关系名称. 缺点是不支持事务. ❀:一套主从 只需要设置一个group就可以了. 优点,支持事务 3.启动predixy: 进入bin目录: 1./predixy ../conf/predixy.conf #执行脚本,指定对应的配置文件. ☀Cluster集群 教程:http://redis.cn/topics/cluster-tutorial.html Redis 集群的数据分片 Redis 集群没有使用一致性hash, 而是引入了 哈希槽的概念. Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么: 节点 A 包含 0 到 5500号哈希槽. 节点 B 包含5501 到 11000 号哈希槽. 节点 C 包含11001 到 16384号哈希槽. 这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态. ☀单机创建集群演示 create-cluster： 脚本目录:/usr/local/redis/redis-5.0.12/utils/create-cluster 修改create-cluster脚本中的配置 12345# SettingsPORT=30000TIMEOUT=2000NODES=6 #总结点数。REPLICAS=1 #每个分片的从节点数。 分片数=(6/1+1) 启动所有节点实例 1./create-cluster start 创建分片和主从关系。 1./create-cluster create 链接集群： 1redis-cli -c -p 30001 停止集群： 1./create-cluster stop 清除日志，文件数据等缓存 1./create-cluster clean ☀分布式创建集群演示 使用客户端命令redis-cli创建. 查询帮助： 1redis-cli --cluster help 启动所有redis实例 集群的redis配置文件添加： 12345port 7000cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000appendonly yes 客户端命令，创建集群分片和主从关系： 1redis-cli --cluster create 127.0.0.1:30001 127.0.0.1:30002 127.0.0.1:30003 127.0.0.1:30004 127.0.0.1:30005 127.0.0.1:30006 --cluster-replicas 1 迁移数据 解决新增、减少节点的问题，解决数据倾斜的问题。 1redis-cli --cluster reshard 127.0.0.1:30001 #迁移节点上的数据。127.0.0.1:30001表示连接的集群地址，不代表要迁移的节点。 查看集群节点信息 1redis-cli --cluster info 127.0.0.1:30001 1redis-cli --cluster check 127.0.0.1:30001 ☀事务的使用技巧 分布式同一个事务中的不同key操作，如果计算出key的槽在不同节点，那么事务就无法提交。 解决方法：将事务关联的key，都设置{oo}类似一样的前缀，那么计算出的槽位，会在相同的节点下，这时候事务就可以提交执行。 ☀击穿 击穿发生场景：某个的key已经过期，在高并发情况下访问。造成直接到达访问数据库。通俗理解为.某个key有几千的请求。 ❀击穿解决方案： 当客户端访问key为null的时候，使用setnx锁。只有获取到锁的客户端才能访问数据库。其他客户端没有得到锁的情况下不能访问数据库，只能停留等待，设置睡眠时间重复获取。 如果设置了锁，可能会导致死锁。 ​ 死锁解决方案：为锁设定过期时间。 如果设置了过期时间，可能会导致锁超时。 ​ 锁超时解决方案：锁超时意味着，访问数据库时间超过了锁的过期时间。这时候可以加一个监控线程，监控数据是否被取回来了，如果没有，更新锁的过期时间。 个人理解：做锁在一定程度上，降低了执行速度，但是提高了数据准确性。同时也可以间接降低服务访问压力。 ☀穿透 穿透出现的场景：客户端访问系统中根本不存在的数据。 ❀解决方案： 使用布隆过滤器： client包含布隆算法和数据。 client包含了算法，数据在redis的bitmap中。redis无状态。 redis集成了布隆算法和数据（布隆过滤器）。 布隆过滤器问题：不能删除数据。解决方法：1.使用布谷鸟。2.设置空key。 ☀雪崩 大量的key同时失效，通俗理解为几百个key同时失效，每个可以有几十个几百个请求。 ❀解决方案： 1.对于与时点性无关的数据，设置key的随机过期时间。 2.对与时点性有关的数据，比如零点必须统一过期的数据，采取强依赖的击穿方案。并且可以在业务层加入判断，零点延时，减缓访问压力。 ☀分布式锁 setnx 已经做锁了，对于效率要求就不大了。对于准确度和一致性要求高。 redisson 锁的一种技术。 zookeeper zookeeper没有redis快。数据可靠性、准确。zookeeper做分布式锁比较好。 ☀API 官方文档： https://docs.spring.io/spring-data/redis/docs/2.5.0/reference/html/#reference ☀高阶API RedisTemplate 存放key的时候，会对key进行java字符串序列化. StringRedisTemplate 存放key字符串就不会进行java字符串序列化操作了。 代码示例： 123456789101112131415161718192021222324252627282930package com.msb.spring.redis.demo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;/** * @Auther: tang * @Date: 2021/4/21 - 04 - 21 - 17:10 * @Description: com.msb.spring.redis.demo * @version: 1.0 */@Componentpublic class TestRedis &#123; @Autowired RedisTemplate redisTemplate; @Autowired StringRedisTemplate stringRedisTemplate; public void testRedis() &#123; stringRedisTemplate.opsForValue().set(&quot;k2&quot;, &quot;321&quot;); System.out.println(stringRedisTemplate.opsForValue().get(&quot;k2&quot;)); &#125;&#125; springboot配置文件： 12spring.redis.host=192.168.57.129spring.redis.port=6379 springboot启动测试类： 123456789@SpringBootApplicationpublic class DemoredisApplication &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext ctx = SpringApplication.run(DemoredisApplication.class, args); RedisTest bean = ctx.getBean(RedisTest.class); bean.hashTest2(); &#125;&#125; ☀低阶API RedisConnection 示例代码： 1234RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();connection.set(&quot;hello&quot;.getBytes(), &quot;msbredis&quot;.getBytes());byte[] bytes = connection.get(&quot;hello&quot;.getBytes());System.out.println(new String(bytes)); ☀Hash实现 ☀设置单个属性： 123456public void hashTest() &#123; HashOperations&lt;String, Object, Object&gt; hash = stringRedisTemplate.opsForHash(); hash.put(&quot;tang&quot;, &quot;name&quot;, &quot;汤晔飞&quot;); hash.put(&quot;tang&quot;, &quot;age&quot;, &quot;18&quot;); hash.entries(&quot;tang&quot;);&#125; ☀存java对象。 引入pom工具： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;&lt;/dependency&gt; 实体类对象： 123456789101112131415161718192021222324252627282930public class Person &#123; private String name; private Integer age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 实现 1234567891011121314@AutowiredObjectMapper objectMapper; //对象属性转换工具。public void hashTest2() &#123; Person person = new Person(); person.setName(&quot;小万&quot;); person.setAge(20); Jackson2HashMapper jm = new Jackson2HashMapper(objectMapper, false);//将对象转为map的工具，应该是先将对象转为json，再将json转为map。 stringRedisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class));//由于stringRedisTemplate，支持的是string类型的序列化器。所以需要自定义hash的value序列化器使其支持int。 stringRedisTemplate.opsForHash().putAll(&quot;wan&quot;, jm.toHash(person)); Map&lt;Object, Object&gt; wan = stringRedisTemplate.opsForHash().entries(&quot;wan&quot;); Person lordwan = objectMapper.convertValue(wan, Person.class); System.out.println(lordwan);&#125; ☀自定义Template 自定义的Bean生成。 1234567891011@Configurationpublic class Mytemplate &#123; //干预未来容器里自己想要的模板。 @Bean public StringRedisTemplate ooxx(RedisConnectionFactory fc)&#123; //自己new时候需要传入，RedisConnectionFactory。 StringRedisTemplate st = new StringRedisTemplate(fc); st.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class)); return st; &#125;&#125; 注入干预： 123@Autowired@Qualifier(&quot;ooxx&quot;)StringRedisTemplate stringRedisTemplate; ☀发布订阅实现 123456789101112131415161718public void pubandsubTest() &#123;/*往一个通道发送消息。*/ stringRedisTemplate.convertAndSend(&quot;ooxx&quot;, &quot;hello&quot;); RedisConnection conn = stringRedisTemplate.getConnectionFactory().getConnection(); conn.subscribe(new MessageListener() &#123; @Override public void onMessage(Message message, byte[] bytes) &#123; System.out.println(new String(message.getBody())); &#125; &#125;, &quot;ooxx&quot;.getBytes()); while (true) &#123; stringRedisTemplate.convertAndSend(&quot;ooxx&quot;, &quot;汤小万&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://aner1001.gitee.io/tags/Redis/"}]},{"title":"Protostuff与Jedis工具类","slug":"技术知识/数据库/Redis/Protostuff与Jedis工具类","date":"2021-07-09T01:31:45.000Z","updated":"2021-07-09T01:31:45.000Z","comments":true,"path":"posts/2021/07/09/ce7f3937fcde/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/07/09/ce7f3937fcde/","excerpt":"Redis有很多数据结构：string、hash、list、set等，但是在实际来发中，我们往往保存的是对象在redis中，所以键值对更加常用。","text":"Redis有很多数据结构：string、hash、list、set等，但是在实际来发中，我们往往保存的是对象在redis中，所以键值对更加常用。 Redis在保存对象时，需要满足序列化，由于java的原生序列化方式效率较低，故更加常用的是Protostuff这个序列化框架。 ☀一、封装Protostuff工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import com.dyuproject.protostuff.LinkedBuffer;import com.dyuproject.protostuff.ProtobufIOUtil;import com.dyuproject.protostuff.Schema;import com.dyuproject.protostuff.runtime.RuntimeSchema;public class SerializeUtil &#123; private static Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = new ConcurrentHashMap&lt;&gt;(); @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; byte[] serializer(T obj) &#123; Class&lt;T&gt; clazz = (Class&lt;T&gt;) obj.getClass(); Schema&lt;T&gt; schema = getSchema(clazz); return ProtobufIOUtil.toByteArray(obj, schema, LinkedBuffer.allocate(256)); &#125; public static &lt;T&gt; T deSerializer(byte[] bytes, Class&lt;T&gt; clazz) &#123; T message; try &#123; message = clazz.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; Schema&lt;T&gt; schema = getSchema(clazz); ProtobufIOUtil.mergeFrom(bytes, message, schema); return message; &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; Schema&lt;T&gt; getSchema(Class&lt;T&gt; clazz) &#123; Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(clazz); if (schema == null) &#123; schema = RuntimeSchema.createFrom(clazz); if (schema != null) &#123; cachedSchema.put(clazz, schema); &#125; &#125; return schema; &#125;&#125; ☀二、封装RedisUtil工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;import redis.clients.jedis.JedisPoolConfig;public class RedisUtil &#123; private static String ADDR = &quot;localhost&quot;; private static int PORT = 6379; private static String AUTH = &quot;123456&quot;; // 最大连接实例数，默认为8，-1表示无限制，如果pool已经分配了超过max_active个jedis实例，则此时pool为耗尽 private static int MAX_ACTIVE = 1024; // 最大空闲实例，默认为8 private static int MAX_IDLE = 200; // 最大等待连接时间，单位毫秒默认为-1，表示永不超时，超时会抛出JedisConnectionException private static int MAX_WAIT = 10 * 1000; private static int TIMEOUT = 10 * 1000; // 在borrow一个jedis实例时，是否提前进行validate操作，如果为true，则得到的jedis实例均是可用的 private static boolean TEST_ON_BORROW = true; private static JedisPool jedisPool = null; /** * 初始化连接池 */ static &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(MAX_ACTIVE); config.setMaxIdle(MAX_IDLE); config.setMaxWaitMillis(MAX_WAIT); config.setTestOnBorrow(TEST_ON_BORROW); jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT, AUTH);//带密码 jedisPool = new JedisPool(config, ADDR, PORT, TIMEOUT);//不带密码。 &#125; /** * 获取jedis实例 */ public synchronized static Jedis getJedis() &#123; if (jedisPool != null) &#123; Jedis resource = jedisPool.getResource(); return resource; &#125; return null; &#125; /** * 释放资源 * * @param jedis */ public static void close(final Jedis jedis) &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; /** * 保存对象（键-值） * * @param &lt;T&gt; * * @param key * @param object * @return */ public static &lt;T&gt; String setObject(String key, T object) &#123; Jedis jedis = getJedis(); try &#123; return jedis.set(key.getBytes(), SerializeUtil.serializer(object)); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; finally &#123; close(jedis); &#125; &#125; /** * 带时间保存（键值） * * @param key * @param object * @param expiretime * @return */ public static &lt;T&gt; String setObject(String key, T object, long expiretime) &#123; Jedis jedis = null; try &#123; jedis = getJedis(); return jedis.psetex(key.getBytes(), expiretime, SerializeUtil.serializer(object)); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; finally &#123; close(jedis); &#125; &#125; /** * 读取对象（键-值） * * @param key * @param clazz * @return */ public static &lt;T&gt; T getObject(String key, Class&lt;T&gt; clazz) &#123; Jedis jedis = getJedis(); try &#123; byte[] bytes = jedis.get(key.getBytes()); T object = SerializeUtil.deSerializer(bytes, clazz); return object; &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; finally &#123; close(jedis); &#125; &#125; /** * 删除key */ public static Long deleteObject(String key) &#123; Jedis jedis = null; try &#123; jedis = getJedis(); return jedis.del(key.getBytes()); &#125; catch (Exception e) &#123; return null; &#125; finally &#123; close(jedis); &#125; &#125; /** * 检查存在 * * @param key * @return */ public static Boolean existsObject(String key) &#123; Jedis jedis = null; try &#123; jedis = getJedis(); return jedis.exists(key.getBytes()); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; finally &#123; close(jedis); &#125; &#125;&#125; ☀三、测试 User： 1234567891011121314151617181920212223242526272829public class User&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 123456789101112public class Main &#123; public static void main(String[] args) &#123; User user = new User(); user.setName(&quot;旭旭宝宝&quot;); user.setAge(33); RedisUtil.setObject(&quot;user&quot;, user); User obj = RedisUtil.getObject(&quot;user&quot;, User.class); System.out.println(obj); System.out.println(RedisUtil.existsObject(&quot;user&quot;)); &#125;&#125; ☀参考文章 RedisUtil工具类封装","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://aner1001.gitee.io/tags/Redis/"}]},{"title":"Hexo搭建个人博客","slug":"技术知识/脚本/Nodejs/Hexo搭建个人博客","date":"2021-06-05T07:11:56.000Z","updated":"2021-06-05T07:11:56.000Z","comments":true,"path":"posts/2021/06/05/fe58c35af835/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/06/05/fe58c35af835/","excerpt":"本人的博客最终选择了Hexo，原因： 强大的社区，基本什么问题都能查到，网上各种主题模板资料很全，各种QQ群一起high，讨论。 插件功能强大，技术成熟，使用起来很方便，从而封装性很好。 也能使用自动化部署技术GitHubActions或者TravisCi技术,弥补了相对于Jekyll博客能在Github自动部署的缺点。 使用Hexo能让你学习到很多东西。例如git知识、自动化部署等、第三方工具、在线编辑、云等等。","text":"本人的博客最终选择了Hexo，原因： 强大的社区，基本什么问题都能查到，网上各种主题模板资料很全，各种QQ群一起high，讨论。 插件功能强大，技术成熟，使用起来很方便，从而封装性很好。 也能使用自动化部署技术GitHubActions或者TravisCi技术,弥补了相对于Jekyll博客能在Github自动部署的缺点。 使用Hexo能让你学习到很多东西。例如git知识、自动化部署等、第三方工具、在线编辑、云等等。 ☀Hexo搭建博客(快速上手) ☀hexo安装 执行安装命令：cnpm install -g hexo-cli 验证安装hexo -v。 ☀基本命令本地创建博客 hexo init ​ 初始化目录，变为hexo博客目录，内容为hexo基础的框架内容。 cnpm install ​ npm安装可能会失败，使用国内cnpm安装package.json依赖。 hexo s ​ 启动博客 hexo n blogname 创建一篇博客 hexo clean ​ 清理生成的html博客文件，一般生成之前都需要清理。 hexo g ​ hexo根据md文件，生成html博客。 ☀将博客部署远端 cnpm install --save hexo-deployer-git ​ 安装hexo的部署依赖包 修改_config.yml deply参数 1234deploy: type:git repo:仓库地址 branch:master 1234567deploy: type: &#x27;git&#x27; repo: github: url: https://github.com/aner1001/blog3.git branch: gh-pages token: $HEXO-GITHUB-TOKEN #读取系统中的环境变量 hexo d ​ 执行命令，将本地生成好的博客部署到远端。 ☀更换主题 yilia主题为例： $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia ​ 将博客克隆到当前blog博客目录下的，themes主题文件夹，yilia文件夹下。 修改_config.yml theme参数 1theme:yilia hexo clean ​ 重新清理博客。 hexo g ​ 重新生成博客。 hexo d ​ 重新发布博客。 ☀根目录设置 如果博客并非部署在端口号对应的根目录下。则需要修改博客部署的根目录，所有文件都是基于这个根目录访问。 本地启动时，会在端口号后拼接上根目录的路径。 这样就可已解决，万一博客不是在服务器根目录造成的问题。 ☀Hexo配置_config.yml ☀参数纪要 记录一些个人认为比较有用的参数，详细参数文档请看Hexo官方参数文档 ☀#site网站参数 参数 说明 title 网站标题 subtitle 网站副标题 description 网站描述，主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。 keywords 网站的关键词。支援多个关键词。 author 您的名字，用于主题显示文章的作者。 language 网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。 timezone 网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。 ☀#URL网址参数 参数 说明 url 网址, must starts with http:// or https://如果您的网站存放在子目录中，例如 http://example.com/blog，则请将您的 url 设为 http://example.com/blog 并把 root 设为 /blog/。 root 网站根目录 … … ☀#Directory目录参数 参数 说明 skip_render 用于source目录中的文件跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。您可使用 glob 表达式来匹配路径。 12345skip_render: &quot;mypage/**/*&quot;# 将会直接将 `source/mypage/index.html` 和 `source/mypage/code.js` 不做改动地输出到 &#x27;public&#x27; 目录# 你也可以用这种方法来跳过对指定文章文件的渲染skip_render: &quot;_posts/test-post.md&quot;# 这将会忽略对 &#x27;test-post.md&#x27; 的渲染 ☀#Writing写作文章的参数 参数 描述 默认值 new_post_name 新文章的文件名称格式。 :title.md default_layout 预设布局，未指定布局创建时使用默认布局。 post external_link 在新标签中打开链接 true external_link.enable 在新标签中打开链接 true external_link.field 对整个网站（site）生效或仅对文章（post）生效 site external_link.exclude 需要排除的域名。主域名和子域名如 www 需分别配置 [] render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹。用于存放文章的图片等资源。 false ☀#Date / Time format日期格式参数 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 HH:mm:ss updated_option 当 Front Matter 中没有指定 updated 时 updated 的取值 mtime updated_option updated_option 控制了当 Front Matter 中没有指定 updated 时，updated 如何取值： mtime: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。 date: 使用 date 作为 updated 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变。在 Git 工作流中这个选项会很有用 。 empty: 直接删除 updated。使用这一选项可能会导致大部分主题和插件无法正常工作。 ☀#Extensions/Plugins/Themes/Deployment主题，拓展，发布等参数 参数 描述 theme 当前主题名称。值为false时禁用主题 theme_config 主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置 deploy 部署部分的设置 meta_generator Meta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签 ☀#包括或不包括目录和文件# Include / Exclude file(s) 参数 描述 include Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 . 开头的文件和文件夹，Hexo 的 _posts 和 _data 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 source 目录下。 exclude Hexo 会忽略这些文件和目录 ignore Ignore files/folders 12345678910111213141516171819202122232425262728293031# Include/Exclude Files/Foldersinclude: - &quot;.nojekyll&quot; # 包括 &#x27;source/css/_typing.css&#x27; - &quot;css/_typing.css&quot; # 包括 &#x27;source/_css/&#x27; 中的任何文件，但不包括子目录及其其中的文件。 - &quot;_css/*&quot; # 包含 &#x27;source/_css/&#x27; 中的任何文件和子目录下的任何文件 - &quot;_css/**/*&quot;exclude: # 不包括 &#x27;source/js/test.js&#x27; - &quot;js/test.js&quot; # 不包括 &#x27;source/js/&#x27; 中的文件、但包括子目录下的所有目录和文件 - &quot;js/*&quot; # 不包括 &#x27;source/js/&#x27; 中的文件和子目录下的任何文件 - &quot;js/**/*&quot; # 不包括 &#x27;source/js/&#x27; 目录下的所有文件名以 &#x27;test&#x27; 开头的文件，但包括其它文件和子目录下的单文件 - &quot;js/test*&quot; # 不包括 &#x27;source/js/&#x27; 及其子目录中任何以 &#x27;test&#x27; 开头的文件 - &quot;js/**/test*&quot; # 不要用 exclude 来忽略 &#x27;source/_posts/&#x27; 中的文件。你应该使用 &#x27;skip_render&#x27;，或者在要忽略的文件的文件名之前加一个下划线 &#x27;_&#x27; # 在这里配置一个 - &quot;_posts/hello-world.md&quot; 是没有用的。ignore: # Ignore any folder named &#x27;foo&#x27;. - &quot;**/foo&quot; # Ignore &#x27;foo&#x27; folder in &#x27;themes/&#x27; only. - &quot;**/themes/*/foo&quot; # Same as above, but applies to every subfolders of &#x27;themes/&#x27;. - &quot;**/themes/**/foo&quot; 列表中的每一项都必须用单引号或双引号包裹起来。 include 和 exclude 并不适用于 themes/ 目录下的文件。如果需要忽略 themes/ 目录下的部分文件或文件夹，可以使用 ignore 或在文件名之前添加下划线 _。 ☀#永久链接（Permalinks） 您可以在 _config.yml 配置中调整网站的永久链接或者在每篇文章的 Front-matter 中指定。 ☀变量 除了下列变量外，您还可使用 Front-matter 中的所有属性。 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（去掉开头的零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（去掉开头的零） :hour 文章发表时的小时 (2 位数) :minute 文章发表时的分钟 (2 位数) :second 文章发表时的秒钟 (2 位数) :title 文件名称 (relative to “source/_posts/“ folder) :name 文件名称 :post_title 文章标题 :id 文章 ID (not persistent across cache reset) :category 分类。如果文章没有分类，则是 default_category 配置信息。 :hash SHA1 hash of filename (same as :title) and date (12-hexadecimal) 您可在 permalink_defaults 参数下调整永久链接中各变量的默认值： 12permalink_defaults: lang: en 示例 12345source/_posts/hello-world.mdtitle: Hello Worlddate: 2013-07-14 17:01:34categories:- foo- bar 参数 结果 :year/:month/:day/:title/ 2013/07/14/hello-world/ :year-:month-:day-:title.html 2013-07-14-hello-world.html :category/:title/ foo/bar/hello-world/ :title-:hash/ hello-world-a2c8ac003b43/ 12345source/_posts/lorem/hello-world.mdtitle: Hello Worlddate: 2013-07-14 17:01:34categories:- foo- bar 参数 结果 :year/:month/:day/:title/ 2013/07/14/lorem/hello-world/ :year/:month/:day/:name/ 2013/07/14/hello-world/ ☀多语种支持 若要建立一个多语种的网站，您可修改 new_post_name 和 permalink 参数，如下： 12new_post_name: :lang/:title.mdpermalink: :lang/:title/ 当您建立新文章时，文章会被储存到： 12$ hexo new &quot;Hello World&quot; --lang tw# =&gt; source/_posts/tw/Hello-World.md 而网址会是： 1http://localhost:4000/tw/hello-world/ ☀配置文件合并原理 ☀使用代替配置文件 可以在 hexo-cli 中使用 --config 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如： 12345# use &#x27;custom.yml&#x27; in place of &#x27;_config.yml&#x27;$ hexo server --config custom.yml# use &#x27;custom.yml&#x27; &amp; &#x27;custom2.json&#x27;, prioritizing &#x27;custom3.yml&#x27;, then &#x27;custom2.json&#x27;$ hexo generate --config custom.yml,custom2.json,custom3.yml 当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 _multiconfig.yml。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。 例如，使用 --options 指定了两个自定义配置文件： 1$ hexo generate --config custom.yml,custom2.json 如果 custom.yml 中指定了 foo: bar，在 custom2.json 中指定了 &quot;foo&quot;: &quot;dinosaur&quot;，那么在 _multiconfig.yml 中你会得到 foo: dinosaur。 ♣注：一般直接使用hexo根目录下的_config.yml。 ☀使用代替主题配置文件 通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 _config.yml 配置文件。 除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。 配置文件中的 theme_config 该特性自 Hexo 2.8.2 起提供 1234567891011# _config.ymltheme: &quot;my-theme&quot;theme_config: bio: &quot;My awesome bio&quot; foo: bar: &#x27;a&#x27;# themes/my-theme/_config.ymlbio: &quot;Some generic bio&quot;logo: &quot;a-cool-image.png&quot; foo: baz: &#x27;b&#x27; 最终主题配置的输出是： 12345678&#123; bio: &quot;My awesome bio&quot;, logo: &quot;a-cool-image.png&quot;, foo: &#123; bar: &quot;a&quot;, baz: &quot;b&quot; &#125;&#125; 独立的 _config.[theme].yml 文件 该特性自 Hexo 5.0.0 起提供 独立的主题配置文件应放置于站点根目录下，支持 yml 或 json 格式。需要配置站点 _config.yml 文件中的 theme 以供 Hexo 寻找 _config.[theme].yml 文件。 1234567891011# _config.ymltheme: &quot;my-theme&quot;# _config.my-theme.ymlbio: &quot;My awesome bio&quot;foo: bar: &#x27;a&#x27;# themes/my-theme/_config.ymlbio: &quot;Some generic bio&quot;logo: &quot;a-cool-image.png&quot; foo: baz: &#x27;b&#x27; 最终主题配置的输出是： 12345678&#123; bio: &quot;My awesome bio&quot;, logo: &quot;a-cool-image.png&quot;, foo: &#123; bar: &quot;a&quot;, baz: &quot;b&quot; &#125;&#125; 我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 theme_config 的优先级最高，其次是 _config.[theme].yml 文件，最后是位于主题目录下的 _config.yml 文件。 ♣注：针对主题的配置，基本上直接新建使用hexo根目录下_config.[theme].yml，统一处理。不修改主题，目录下的_config.yml ☀Hexo命令 ♣注：一定要先写关键字主命令后再写参数。 ☀init 1$ hexo init [folder] 1$ hexo init 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 ☀new 1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1$ hexo new &quot;post title with whitespace&quot; 参数 描述 ★-p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about/me &quot;About me&quot; 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot; 注意：指定目录后，文件名会以最后一层目录下的名称me作为文件名。 ♠个人心得:为何要这样生成？md文件最后渲染的就是一个md文件名称的目录，其中有个index.html。 注意！title 是必须指定的！如果你这么做并不能达到你的目的： 1hexo new page --path about/me 此时 Hexo 会创建 source/_posts/about/me.md，同时 me.md 的 Front Matter 中的 title 为 &quot;page&quot;。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 注意：如果标题中有特殊字符如[],必须带上’'符号括起来. ☀generate 生成静态文件。 123$ hexo generate#简写为$ hexo g 选项 描述 ★-d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 ★-f, --force 强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。 使用该参数的效果接近 hexo clean &amp;&amp; hexo generate -c, --concurrency 最大同时生成文件的数量，默认无限制 ☀publish 1$ hexo publish [layout] &lt;filename&gt; 发表草稿。经过测试目前只能将darft目录下的文件添加到_post文件夹下。不支持子目录添加操作。 ☀server 123$ hexo server#简写为$ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件，使用public中的。generate之后生成的文件。 -l, --log 启动日记记录，使用覆盖记录格式 --draft 添加预览草稿文件 -i 指定访问Ip.服务器有双网口时，可用此选项覆盖默认的ip设置。 服务启动后，文章中内容是实时渲染的。一旦改动立马会生效。不会使用静态public中generate生成后的文件。 ☀deploy 123$ hexo deploy#简写为$ hexo d 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 ☀render 1$ hexo render &lt;file1&gt; [file2] ... file需要指明目录。路径默认在的执行此命令的blog根目录中。 例：hexo render source\\_posts\\about\\me.md -o data 渲染文件。 参数 描述 -o, --output 设置输出路径 ☀clean 1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 ☀list 1$ hexo list &lt;type&gt; 列出网站资料，已经存在的文件等。 参数 列举 page, post, route, tag, category ☀version 123$ hexo version#简写为$ hexo v 显示 Hexo 版本。 ☀基本的操作 ☀创建文章 你可以执行下列命令来创建一篇新文章或者新的页面。 1$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 ☀布局（Layout） Hexo 有三种默认布局：post、page 和 draft。在创建者三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。对应Scaffold文件夹中的post .md、page.md、draft.md。 布局 路径 post source/_posts page source draft source/_drafts Disabling layout If you don’t want an article (post/page) to be processed with a theme, set layout: false in its front-matter. Refer to this section for more details. ☀自定义模版（Scaffold） 在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo &quot;My Gallery&quot; 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，模版中使用的变量列举： 变量 描述 layout 布局 title 标题 date 文件建立日期 ☀文件名称 Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 ☀写作 ☀写作语言格式 不仅可以用 Markdown 写作，你还可以用 EJS 写作。甚至可以用 Pug 模板语言书写文章。需要渲染插件的支持，hexo-renderer-marked 和 hexo-renderer-ejs默认已安装。hexo-renderer-pug安装后可渲染Pug。 ☀Front-matter文章前提 Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说： 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） ☀分类和标签 只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games 分类方法的分歧 如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法： 123categories: - Diary - Life 会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。 如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。 1234categories:- [Diary, PlayStation]- [Diary, Games]- [Life] 此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。 ☀引入资源文件 资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 ♣注：引入图片资源最好的解决方案就是使用图床。下方的方案可以参考，更加了解Hexo。 对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。 1post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 由于md文件最终渲染后生成的index.html，最终会放到md文件名称的文件夹中。所以md中引入路径需要写成：![](example.jpg) 但是这样写，如果文章显示在首页，则图片在首页中不会显示出。 解决方案： ​ ❀使用标签插件 ​ ​ ❀使用Hexo3.1.0新增的插件渲染配置. _config.yml 1234post_asset_folder: truemarked: prependRoot: true postAsset: true ☀引入数据文件 有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。 举例来说，在 source/_data 文件夹中新建 menu.yml 文件： 123Home: /Gallery: /gallery/Archives: /archives/ 您就能在模板中使用这些资料： 123&lt;% for (var link in site.data.menu) &#123; %&gt; &lt;a href=&quot;&lt;%= site.data.menu[link] %&gt;&quot;&gt; &lt;%= link %&gt; &lt;/a&gt;&lt;% &#125; %&gt; 渲染结果如下 : 123&lt;a href=&quot;/&quot;&gt; Home &lt;/a&gt;&lt;a href=&quot;/gallery/&quot;&gt; Gallery &lt;/a&gt;&lt;a href=&quot;/archives/&quot;&gt; Archives &lt;/a&gt; ☀部署 Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。 1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数. 例如：使用git工具部署 12deploy: type: git 可以使用支持多个平台同时部署 123456789101112deploy: type: &#x27;git&#x27; repo: github: url: branch: gh-pages token: $HEXO_GITHUB_TOKEN coding: url: branch: gh-pages token: $HEXO_CODING_TOKEN 您可同时使用多个 deployer工具，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: heroku repo: ☀Git工具部署 安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 修改配置。 123456deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] token: [token] #一般配置在环境变量中。 参数 描述 默认 repo 库（Repository）地址 branch 分支名称 gh-pages (GitHub) coding-pages (Coding.net) master (others) message 自定义提交信息 Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;) token Optional token value to authenticate with the repo. Prefix with $ to read token from environment variable 生成站点文件并推送至远程库。执行 1hexo clean &amp;&amp; hexo deploy You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key. hexo-deployer-git does not store your username and password. Use git-credential-cache to store them temporarily. 登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为_config.yml配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。 这一切是如何发生的？ 当执行 hexo deploy 时，Hexo 会将 public 目录中的文件和目录推送至 _config.yml 中指定的远端仓库和分支中，并且完全覆盖该分支下的已有内容。 ☀自动化部署 ☀[Travis CI] ☀介绍 编写代码只是软件开发的一小部分，更多的时间往往花在构建（build）和测试（test）。 为了提高软件开发的效率，构建和测试的自动化工具层出不穷。Travis CI 就是这类工具之中，市场份额最大的一个。 用好这个工具不仅可以提高效率，还能使开发流程更可靠和专业化，从而提高软件的价值。而且，它对于开源项目是免费的，不花一分钱，就能帮你做掉很多事情。 什么是持续集成？ Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。 持续集成指的是只要代码有变更，就自动运行构建和测试，反馈运行结果。确保符合预期以后，再将新代码&quot;集成&quot;到主干。 持续集成的好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。 ☀部署步骤 创建博客源码仓库和静态文件仓库。 github创建token，权限为repo。 前往 Travis CI 使用 GitHub 账户登录并赋权。 Travis CI中前往你的 博客源码仓库repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GITHUB_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存。 在你的 Hexo 站点文件夹中新建一个 .travis.yml 文件：gistLink. 接下来每次提交博客源码仓库，都会被Travis CI监控到。执行脚本，部署到静态文件仓库中。 ☀[GitHub Actions] ☀介绍 大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。 很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。 如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。 GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。 ☀部署步骤 创建博客源码仓库和静态文件仓库。 github创建token，权限为repo。 在博客源码仓库中创建隐私资料,settings-&gt;secrets,将创建的token存入。不等同于Travis中的配置。区别：secrets中的变量需要在脚本配置中再引入。Travis中配置的，直接就是环境变量直接可以使用。 在博客源码仓库中创建Actions，并配置。参考Gist。实际生成.github/workflow/xxx.yml配置文件。 每次提交博客源码仓库，都会被Actions监控，执行部署脚本。 ☀好看的博客收藏 博客地址 亮点 https://eightplus.github.io/ 嵌入音乐。侧边栏支持隐藏/打开。支持站内搜索。 https://mellow.yuanlichenai.cn/ 有一个可以盯着得玩具人，逗她玩。 http://litten.me/ 相册功能很不错。 https://www.codesheep.cn/ 标签云很好看。有专题文章。搜索功能好，可以搜索到书签，分类。 https://jerryc.me/ 归档时间轴好看，设置简体繁体，全屏，黑夜模式。电影和照片也是亮点。标签侧边显示。手机端查看也支持目录。 https://blog.cofess.com/ 搜索功能好，可以搜索到书签，分类。 https://molunerfinn.com/archives/ 简洁美观。 https://volantis.js.org/ 本人就是最终选择了这个，太好用了，简洁美观，文档说明清晰，优化也很好。Volantis！ ☀Volantis主题 注意： 使用hexo-filter-github-emojis 插件会使gulp压缩报错，不能用这个插件。 使用emojis插件个人推荐：markdown-it-emoji，好看简洁又好用。重点和Typroa渲染一模一样。 ☀问题解决 ☀1.YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at … 原因是在博客头文件时，键值对格式需要有空格。 ☀2.ExperimentalWarning: The fs.promises API is experimental 根本原因是node的版本不是最新的，而在项目引入的模块是最新的，node.js的版本低于模块的版本： 解决方法是升级npm,node.js： ☀3.Warning: Accessing non-existent property ‘lineno’ of module exports inside circular dependency 出现这些是因为node版本太高，切换成低版本的node来安装Hexo就可以了 ☀4.Travis CI日志push失败src refspec master does not match any 原因：tarvis ci配置文件中，commit的说明中带有中文，导致TravisCI环境中中文变为空字符串。提交报错，最终导致无法提交远程仓库。 配置文件中带有中文： TravisCi环境中提交时，变为了空字符串，提交失败。 日志报文信息: ☀5.extends includes/layout.pug block content include ./includes/mixins/post-ui.pug #recent-posts.recent-posts +postUI include includes/pagination.pug 解决执行： 1npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive hexo clean hexo g hexo s ☀6.err: Error [Nunjucks Error]: gallery/index.md [Line 2, Column 4] unknown block tag: galleryGroup ☀7.Git提交时提示‘The file will have its original line endings in your working directory’ 原来是Git默认配置替换回车换行成统一的CRLF，我们只需要修改配置禁用该功能即可。 Gitshell中输入如下命令解决： git config --global core.autocrlf false ☀8.PWA启动err: TypeError: Cannot read property ‘data’ of undefined 原因是hexo版本过高导致。 ☀9. heox部署Warning: Accessing non-existent property ‘column’ of module 出现这些是因为node版本太高，切换成低版本的node来安装Hexo就可以了 我原先是安装了最新版node14.0，后来多装了一个比较稳定的node12.14版本，这个问题就解决了 ☀10.cnpm安装过程中提示optional install error: Package require os(darwin) not compatible with your platform sass loader出问题的 解决方法：cnpm rebuild node-sass —经过尝试不一定行。😢 😄 ☀11.刚下载下来的Hexo工程，hexo g报错，无法编译。unknown block tag: btn 原因是:子工程主题模块没有下载。 解决办法： 1.git submodule update --init --recursive 下载子工程 2.git clone 父工程地址 --recursive #在克隆父工程时，直接使用递归命令 ☀参考文献 nodejs环境搭建之搭建nvm(node版本管理) NodeJS入门（一）—nodejs详细安装步骤 npm基本命令 npm install 本地安装与全局安装的区别 YAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at … npm install 、npm install --save 和 npm install --save-dev的区别 [馨客栈分享]使用travis CI自动部署hexo博客到Github并且在Github pages上展示页面 通过travis-ci或者GitHub Actions自动化部署GitHub Pages和Coding Pages 持续集成服务 Travis CI 教程 GitHub Actions 入门教程","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"脚本","slug":"技术知识/脚本","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://aner1001.gitee.io/tags/Hexo/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://aner1001.gitee.io/tags/Nodejs/"}]},{"title":"Ruby环境搭建篇(Jekyll博客)","slug":"技术知识/脚本/Ruby/Ruby环境搭建篇-Jekyll博客","date":"2021-05-29T05:36:49.000Z","updated":"2021-05-29T05:36:49.000Z","comments":true,"path":"posts/2021/05/29/a4740947d4f3/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/05/29/a4740947d4f3/","excerpt":"Jekyll博客基于Ruby开发，需要安装Ruby开发和运行环境。 本篇介绍Ruby和Ruby环境搭建。","text":"Jekyll博客基于Ruby开发，需要安装Ruby开发和运行环境。 本篇介绍Ruby和Ruby环境搭建。 ☀Ruby ☀Ruby 简介 Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。您可以在 www.ruby-lang.org 的 Ruby 邮件列表上找到松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）的名字。在 Ruby 社区，松本也被称为马茨（Matz）。 Ruby 是&quot;程序员的最佳朋友&quot;。 Ruby 的特性与 Smalltalk、Perl 和 Python 类似。Perl、Python 和 Smalltalk 是脚本语言。Smalltalk 是一个真正的面向对象语言。Ruby，与 Smalltalk 一样，是一个完美的面向对象语言。使用 Ruby 的语法比使用 Smalltalk 的语法要容易得多。 ☀Gem介绍： Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem（如 http://rubygems.org/ ）源来查找、安装、升级和卸载软件包，非常的便捷。 Ruby 1.9.2版本默认已安装Ruby Gem，如果你使用其它发行版本，请参考“如何安装Ruby Gem”。 Ruby gem包的安装方式： 所有的gem包，会被安装到 /[Ruby root]/lib/ruby/gems/[ver]/ 目录下，这其中包括了Cache、doc、gems、specifications 4个目录，cache下放置下载的原生gem包，gems下则放置的是解压过的gem包。 当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的gem包，然后重新运行 gem install [gemname] 命令即可。 Jekyll就是通过Gem来管理安装，理解为nodejs中的npm安装。 ☀Ruby Gem命令详解： $ gem --version (查看gem版本) $ gem sources(查看数据源) $gem sources -l 查看版本 $ gem sources --remove https://rubygems.org/(删除数据源) $ gem sources -a https://ruby.taobao.org/(添加数据源) $ gem update --system(更新Gem自身,注意：在某些linux发行版中为了系统稳定性此命令禁止执行) $ gem search 软件包关键字(搜索软件包) $ gem install [gemname] 从Gem源安装gem包 $ gem install [gemname] [gemname] 安装多个包 ​ 例：gem install bundler jekyll 安装bundler和jekyll $ gem install -l [gemname].gem（从本机安装gem包） $ gem install [gemname] --version=[ver]（安装指定版本的gem包） $ gem update （更新所有已安装的gem包） $ gem update [gemname]（更新指定的gem包） // 注意：gem update [gemname]不会升级旧版本的包，此时你可以使用 gem install [gemname] --version=[ver]代替 $ gem uninstall [gemname]（删除指定的gem包，注意此命令将删除所有已安装的版本） $ gem uninstall [gemname] --version=[ver]（删除某指定版本gem） $ gem list [–local]（查看本机已安装的所有gem包） DevKit 介绍 DevKit 是一个在 Windows 上帮助简化安装及使用 Ruby C/C++ 扩展如 RDiscount 和 RedCloth 的工具箱。安装在ruby中。 ☀下载安装 ☀Windows版本 http://rubyinstaller.org/downloads/ 心得：windows下安装的高版本Ruby+Devkit包含了Ruby运行环境和gem管理包。Devkit工具包，是选择安装的。 选择WITH DEVKIT 下载。 选择添加到环境变量中。 选择3 验证 ruby -v 验证ruby安装。 gem -v 验证gem安装。 gem install rdiscount --platform=ruby 如果能安装rdiscount成功说明安装DevKit成功。 ☀配置： ​ 如果是在墙内，需要切换安装源到https://gems.ruby-china.com/。墙外请忽略。 ​ 切换安装源 gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ ☀Bundler 官网 ☀简介： Bundler: 管理 Ruby 项目中 gem 依赖的最好工具 Bundler 能够跟踪并安装所需的特定版本的 gem包，以此来为 Ruby 项目提供一致的运行环境。 Bundler 是 Ruby 依赖管理的一根救命稻草，它可以保证你所要依赖的 gem 如你所愿地出现 在开发、测试和生产环境中。 利用 Bundler 启动项目简单到只用一条命令：bundle install。 ☀使用方法： Bundler 使用起来非常简单！打开命令行窗口并运行如下命令： 1$ gem install bundler 在 Ruby 项目的根目录下新建 Gemfile 文件并指定所需的依赖： 1234source &#x27;https://rubygems.org&#x27;gem &#x27;nokogiri&#x27;gem &#x27;rack&#x27;, &#x27;~&gt; 2.0.1&#x27;gem &#x27;rspec&#x27; 深入了解：Gemfiles 从指定的 gem 源安装所需依赖： 12$ bundle install$ git add Gemfile Gemfile.lock ☀心得感悟： 每次下载了博客模板后，运行一次bundle install安装gem依赖搭建环境。bundler会会根据配置文件中的源和依赖进行安装。 所以博客模板中使用了Gemfile，并且配置了jekyll的版本，jekyll也可以通过bundle来安装。 ❤bundle可以理解为封装了gem命令，用来读取本地化文件配置转换为gem命令进行执行的工具。批量管理gem包","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"脚本","slug":"技术知识/脚本","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://aner1001.gitee.io/tags/Ruby/"}]},{"title":"Jekyll和GitHubPages搭建个人博客","slug":"技术知识/脚本/Ruby/Jekyll和GitHubPages搭建个人博客","date":"2021-05-29T05:36:49.000Z","updated":"2021-05-29T05:36:49.000Z","comments":true,"path":"posts/2021/05/29/ca816c779a77/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/05/29/ca816c779a77/","excerpt":"本文介绍Jekyll的安装和基本使用。 最后本人选择了hexo搭建博客，具体原因请看hexo搭建篇。 Jekyll博客我参照B站Up主，制作了在线简历，同样很棒！参考简历，下方有视频连接可以学习。","text":"本文介绍Jekyll的安装和基本使用。 最后本人选择了hexo搭建博客，具体原因请看hexo搭建篇。 Jekyll博客我参照B站Up主，制作了在线简历，同样很棒！参考简历，下方有视频连接可以学习。 ☀环境搭建 ☀搭建Ruby环境 参考：Ruby环境搭建篇(Jekyll博客) ☀安装Jekyll Jekyll是什么？ 引用自官网： Jekyll 是一个简单的博客形态的静态站点生产机器。它有一个模版目录，其中包含原始文本格式的文档，通过一个转换器（如 Markdown）和我们的 Liquid 渲染器转化成一个完整的可发布的静态网站，你可以发布在任何你喜爱的服务器上。Jekyll 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的。 简单来说，Jekyll就是将纯文本转化为静态博客网站，不需要数据库支持，也没有评论功能，想要评论功能的话可以借助第三方的评论服务。 Jekyll + Github Pages可以让你更加专注于博客内容，而不是如何搭建一个博客平台。 Jekyll官网：https://www.jekyll.com.cn/ Jekyl主题站：https://jekyllthemes.dev/ ==GitHub本身自带Jekyll== ==安装Jekyll的目的就是本机预览== 优点： 使用了 Jekyll 你会发现如果你想使用多台电脑发博客都很方便，只要把远端 github 仓库里的博客 clone 下来，写文章后再提交就可以了，Hexo 由于远端提交的是静态网页，所有无法直接写 Markdown 的文章。 ☀安装Jekyll ☀Jekyll运行所需要的环境: Ruby 一种简单快捷的面向对象（面向对象程序设计）脚本语言，在20世纪90年代由日本人松本行弘(Yukihiro Matsumoto)开发。 下载地址:https://rubyinstaller.org/downloads/ RubyGems RubyGems 是 Ruby 的一个包管理器，它提供一个分发 Ruby 程序和库的标准格式，还提供一个管理程序包安装的工具。 RubyGems 旨在方便地管理 gem 安装的工具，以及用于分发 gem 的服务器。这类似于 Ubuntu 下的apt-get, Centos 的 yum，Python 的 pip。 RubyGems大约创建于2003年11月，从Ruby 1.9版起成为Ruby标准库的一部分。如果你的 Ruby 低于 1.9 版本，也可以通过手动安装: DevKit DevKit 是一个在 Windows 上帮助简化安装及使用 Ruby C/C++ 扩展如 RDiscount 和 RedCloth 的工具箱。 Ruby、RubyGems、DevKit环境安装请看Ruby ☀安装配置步骤： 安装完上述所需环境后： gem install jekyll gem install bundler 切换bundler的安装源 bundle config mirror.https://rubygems.org https://gems.ruby-china.com ☀启动： ☀1. 新建博客启动 进入本地的一个存放博客目录 jekyll new myblog cd mybolg bundle exec jekyll serve 或者 jekyll server 或者 bundle exec jekyll s 看jekyll的版本。 或者 mkdir myblog cd myblog jekyll new . jekyll s ☀2.从一个刚拉取的已有博客中启动 bundle install bundle exec jekyll serve ☀第三方工具 ☀GiTalk ☀GiTalk简介 Gitalk 最初推出来，应该是想配合在 github 上建博客，方便添加评论功能的。随着其他评论插件的没落，Gitalk 就火起来了。Gitalk 是一个基于 Github Issue 和 Preact 开发的评论插件。它除了支持 Hexo 外，还支持 java，php 等语言开发的博客。 优点：方便，简单，很适合新手。 ☀使用方法 首先需要到GitHub上去新建一个仓库用于存放评论的内容。 在设置中打开issue功能。 使用自己的博客仓库就可以了 需要注册一个Github Oauth Application具体步骤如下： 进入个人的Github首页，Settings-&gt;Applications-&gt;Developer applications-&gt;Register a new application，然后在下图中输入信息，信息输入完毕后点击&quot;Register application&quot;按钮。 得到Client ID 和 Client Secret 只需要将如下代码引入你想添加评论的 html 或者 jsp 页面中就可以使用了: 12345678910111213141516&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;&lt;script src=&quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; // gitalk的主要参数 clientID: `f8b924888078dee1cXXX`, //上面获取到的值 clientSecret: `7318911d69cddc8932c4b200a4e7c881a9XXX`,//上面获取到的值 repo: `PingLunShuJu`, //您刚才建立仓库的名字 owner: &#x27;Tom-shushu&#x27;, //你的GitHub用户名字 admin: [&#x27;Tom-shushu&#x27;], //你的GitHub用户的名字 id: &#x27;indow.location.pathname&#x27;, //id不能重复，如果重复就会把其他页面的评论引进来 &#125;); gitalk.render(&#x27;gitalk-container&#x27;);&lt;/script&gt; 注意：第一次进入时评论模块加载不出来，需要注册Github Application的账号，将博客发布服务器，登录评论模块后刷新页面，就可以正常使用了。 添加了评论后在博客仓库的issues中显示下面一条记录： ☀参数描述： clientID String 必须. Github Application Client ID. clientSecret String 必须. Github Application Client Secret. repo String 必须. Github repository. owner String 必须. Github repository 所有者，可以是个人或者组织。 admin Array 必须. Github repository 合作者 (确保对这个 repository 是有写的权限)。 id String Default: location.href. 页面的唯一标识。 labels Array Default: ['Gitalk']. Github issue 的标签。 title String Default: document.title. Github issue 的标题。 body String Default: location.href + header.meta[description]. Github issue 的内容。 language String Default: navigator.language || navigator.userLanguage. 设置语言，支持 [en, zh-CN, zh-TW]。 perPage Number Default: 10. 每次加载的数据大小，最多 100。 distractionFreeMode Boolean Default: false。 类似Facebook评论框的全屏遮罩效果. pagerDirection String Default: ‘last’ 评论排序方式， last为按评论创建时间倒叙，first为按创建时间正序。 createIssueManually Boolean Default: false. 如果当前页面没有相应的 isssue 且登录的用户属于 admin，则会自动创建 issue。如果设置为 true，则显示一个初始化页面，创建 issue 需要点击 init 按钮。 proxy String Default: https://cors-anywhere.herokuapp.com/https://github.com/login/oauth/access_token. Github oauth 请求到反向代理，为了支持 CORS。 为什么要这样? flipMoveOptions Object Default: 123456&#123; staggerDelayBy: 150, appearAnimation: &#x27;accordionVertical&#x27;, enterAnimation: &#x27;accordionVertical&#x27;, leaveAnimation: &#x27;accordionVertical&#x27;,&#125; 评论列表的动画。 参考 enableHotKey Boolean Default: true. 启用快捷键(cmd|ctrl + enter) 提交评论. ☀如何写Jekyll的MarkDown博客： 命名格式:yyyy-mm-dd-blogName.md 开启标题头文件：注意key: 后的value值前必须加一个空格，否则不会识别。 layout: 布局 post、default、page title: 标题，显示在文本的最上方，同文件名就可以。 description: 文章描述 date: 日期可有可无，本身也会识别文件的日期名进行输出。 tag: 标签 为博客添加标签 tags: [标签1,标签2] 添加多个标签 categories: [分类1,分类2] 多个分类 图片 ☀好看的博客模板 博客地址 亮点 https://github.com/leopardpan/leopardpan.github.io 此模板须放在github.io首页，因为很多路径未用当前相对路径，使用的是项目的相对路径/，所以需放在github.io首页仓库中使其生效。 https://yuanlichenai.cn/ 关灯，黑夜模式切换，阅读时的右侧目录好用，测试中嵌入音乐 https://blog.ixxoo.me/ READ和NOTE板块很好。 https://mmistakes.github.io/mm-github-pages-starter/posts/ 风格简单，搜索好看。 https://mmistakes.github.io/jekyll-theme-basically-basic/ 有一张背景图，导航栏隐藏。 https://jekyller.github.io/jasper/# 比漂亮的模板 https://yuanlichenai.cn/ https://github.com/jekyller/jasper.git ☀模板改造记录 基于，潘柏信的模板 删除posts文件夹下原作者的文章。 README.md 写上自己仓库的信息，指向原作者连接的信息。 删除原作者迁移博客残留文件。Gemfile、Gemfile.lock、Rakefile Feed.xml为iss订阅的东西，不用可以删除。让博客支持iss订阅，则不需要删除。 CNAME为域名映射的文件。没有域名直接删除。 修改images中的图片。(主目录)个人头像、(paying)微信、支付宝打赏等，不需要直接将paying删除,同时将include中的newold.html中的打赏相关的html和div删除。 images中的post为作者写文章markdown引用的图片资源，不需要也可以删除，或者添加自己的图片。 js文件夹为网站脚本，images为图片地址。css为样表，可修改。post为写文章的地方，支持markdown或者html会套上网站的样表展现。layout为网站的样表(相当于一个整个的汽车)。layout所需的部件都在include中。 修改_config.yml，按照注释配置即可。 全文替换作者的用户名域名。 配置百度站内搜索。 将写好的markdown文件，放入_post文件夹中，jekyll服务会自动将md文件解析生成为html放在__site文件夹，根据年月划分目录存入。 添加评论系统：GiTalk 添加分类功能：引入categories.md 连接 ☀🎉🎉🎉Jekyll制作在线简历 参考视频： 个人简历 ☀加载速度优化方案 思路：使用谷歌Network功能，查看加载资源文件，哪一个资源文件最耗时，优化将其变短。 将加载时间长的js相关的功能隐藏，放在一个可触发的按钮中，点击按钮后再去加载js和对应的功能。 加载非本地其他域名的资源响应慢： 将资源放到本地，通多本地去加载。 使用离地区比较近的域cdn。https://www.bootcdn.cn/ 优秀cdn网站整理 协议转发耗时，使用了http协议访问，转发到https下 ，这个转发的过程会消耗时间。如果明确了协议直接写固定会节省时间。 加载的图片比较大，也会耗时，无损压缩网站,将图片压缩。 如果本机测试很快，但是发布的服务器本身访问带宽慢，可以直接将jekyll生成得site文件发布到中国的主机上。与主机的ping值主要决定了访问速度。 ☀问题记录 ☀1.启动jekyll服务时`require’: cannot load such file – bundler (LoadError) 原因： ​ 未安装bundler 解决： ​ 执行命令安装 ​ gem install bundler ​ bundle -v 查看版本 ​ 安装失败：切换安装源 ​ bundle config mirror.https://rubygems.org https://gems.ruby-china.com ☀2.Please add the following to your Gemfile to avoid polling for changes: gem ‘wdm’, ‘&gt;= 0.1.0’ if Gem.win_platform? Auto-regeneration: enabled for ‘D:/Data/Git/github/blog’ **原因：**在blog文件中又创建了blog启动。 ☀3.Ensure you have plugins:[jekyll-paginate] in your configuration file. 原因：缺少jekyll-paginate插件。 **解决：**gem install jekyll-paginate ☀4.it looks like you don’t have jekyll-sitemap or one its dependencies installed. 原因：缺少 jekyll-sitemap插件。 **解决：**gem install jekyll-sitemap ​ 以此类推，报这种错误，直接gem安装插件就可以了。 ☀5.socket.rb:201:in `bind’: Permission denied- bind(2) for 127.0.0.1:4000 (Errno::EACCES) **原因：**4000端口被其他程序占用。 解决： ​ 查看端口占用的进程pid： ​ netstat -aon|findstr “4000” ​ 查看pid所对应的软件 ​ tasklist|findstr “2100” ​ ​ 杀死进程： ​ tskill 2100 ☀6.can’t find gem bundler (&gt;= 0.a) with executable bundle 原因： ​ 原因是本地项目bundler 和 服务器 bundler 版本不一致导致，项目是在本地建立，故Gemfile.lock最后一行BUNDLED WITH中是2.0.1（本地版本） 解决： ~~ 删除本地文件的GemFile GemFile.lock.~ 或者将GemFile.lock中的版本改成安装版本。 ☀7.Could not find public_suffix-3.1.1 in any of the sources 原因： 需要安装bundle的一些程序。 解决： bundle install 执行安装。 ☀8. You appear to have pagination turned on, but you haven’t included the jekyll-paginate gem. Ensure you have plugins: [jekyll-paginate] inyour configuration file. config.yml中配置插件，gem定义应该为老版本的，替换为新版本的plugins就没问题了。 ☀9.Jekyll 解决Jekyll server本地预览文章not found的问题 参考解决方案：https://blog.csdn.net/u010632165/article/details/103538062 原因: 以上无法找到的文件，在_site文件夹下都存在，简单分析应该是编码格式的问题，导致server无法正确找到对应的文章； 解决方案： 找到文件Ruby的安装目录：Ruby26-x64\\lib\\ruby\\2.6.0\\webrick\\httpservlet\\filehandler.rb，具体安装目录根据实际情况确定； ☀10:in `block in verify_gemfile_dependencies_are_found!': Could not find gem ‘github-pages (~&gt; 192) x64-mingw32’ in any of the gem sources listed in your Gemfile. (Bundler::GemNotFound) 原因： ​ 缺少gem环境所需的依赖。 解决： ​ 解决执行 bundle install。 ☀11.Bundler::HTTPError Coudle not fetch specs from https://gem.ruby-china.org/^C* 原因： ​ org在中国环境需要备案，还不能使用此源。需要更换。 解决: ​ 更换为：https://gems.ruby-china.com ☀注意事项： 如果把一些图片放在了本地，直接上传到github或者coding，会严重拖慢你博客的速度。 图床也就是上传一个图片至一个服务器或者一个平台，使用特有的连接去访问。可以大大加速博客的访问速度。 ☀参考： https://my.oschina.net/u/3077716/blog/4402516 https://www.bilibili.com/video/BV14x411t7ZU","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"脚本","slug":"技术知识/脚本","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"Ruby","slug":"Ruby","permalink":"http://aner1001.gitee.io/tags/Ruby/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://aner1001.gitee.io/tags/Jekyll/"}]},{"title":"Nodejs环境搭建","slug":"技术知识/脚本/Nodejs/Nodejs环境搭建","date":"2021-05-25T07:09:44.000Z","updated":"2021-05-25T07:09:44.000Z","comments":true,"path":"posts/2021/05/25/5acb08517bd6/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/05/25/5acb08517bd6/","excerpt":"本文介绍： nodejs环境的搭建。 nvm工具管理nodejs版本的使用。 npm包管理工具的使用以及命令。","text":"本文介绍： nodejs环境的搭建。 nvm工具管理nodejs版本的使用。 npm包管理工具的使用以及命令。 ☀nodejs ☀概念： 什么是nodejs? 脚本语言需要一个解析器才能运行，JavaScript是脚本语言，在不同的位置有不一样的解析器，如写入html的js语言，浏览器是它的解析器角色。而对于需要独立运行的JS，nodejs就是一个解析器。 每一种解析器都是一个运行环境，不但允许js定义各种数据结构，进行各种计算，还允许js使用允许环境提供的内置对象和方法做一些事情。如运行在浏览器中的js的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在nodejs中的js的用途是操作磁盘文件或搭建http服务器，nodejs就相应提供了fs,http等内置对象。 能做什么？ NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器，他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制。JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一大群程序员，因此就成为了天然的选择。 如他所愿，NodeJS在服务端活跃起来，出现了大批基于NodeJS的Web服务。而另一方面，NodeJS让前端众如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。 因此，对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。 ☀安装： 此处不介绍安装，nodejs版本安装可由nvm工具管理。 ☀nvm nvm就是nodejs version manage 叫做nodejs 版本管理，而nodejs有很多版本，场景如下: 1、而你手上开发的有多个项目又分别是不同的nodejs版本，咱们就可以用nvm轻松切换！ 2、假设你正在开发的项目开始使用的nodejs版本是8.0，而现在因为某些原因，你需要升级 或者 降级 nodejs 版本，也可以使用 nvm 轻松切换 ☀nvm下载、安装、设置 ☀下载 nvm的GitHub下载地址 nvm-noinstall.zip：绿色免安装版，但使用时需进行配置。 nvm-setup.zip：安装版，推荐使用。 ☀安装 注：安装路径不要出现中文和空格。 双击安装文件 nvm-setup.exe 选择nvm安装路径 选择nodejs路径。 这个是一个映射文件的路径，相当于快捷方式。实际安装位置默认在nvm根目录。 确认安装即可 输入 nvm v，弹出版本号，表示安装成功。 ☀设置 node 和 npm 镜像地址 在nvm安装目录，找到 setting.txt加上如下两行： 12node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ ☀nvm操作nodejs(快速上手) ☀安装 安装你要的nodejs版本，必须是npm和nodejs都成功，因为有时候会npm或者nodejs不会下载成功，不成功的原因很多，前提必须按我的这个步骤，并且是之前没有装nodejs,或者是卸载干净了nodejs。 命令：nvm install 版本号 如上表示成功了，继续检验是否真的成功，进入nvm目录查看： 下图是ok的 下图是不行的 你可以自己去下载一个nodejs版本，但后解压后放复制到nvm目录，注意命名,如：v11.11.0，这样就不需要使用 nvm install 命令。nodejs官方单独下载地址 镜像地址也可以下载更快 系统原因可能nodejs过高版本不支持低版本的操作系统，根据操作系统下载版本。个人测试win7不支持v14，可以支持v13版本。 ☀nvm切换版本 12nvm use 版本号这样就好了，node和 npm都好了 个人理解：nvm use实际做的就是更换映射的nodejs安装位置的。 ☀nvm命令整理： 注：命令中的[xxx]将字符串括起来写更加规范。也可以直接写xxx。 命令 说明 nvm list installed nvm list♣nvm ls 查看已经安装的版本 nvm list available 查看网络可以安装的版本 nvm install [version] 安装最新版本nvm nvm use [version] 切换使用指定的版本node nvm uninstall [version] 卸载指定版本的nodejs。一般卸载不干净，直接找安装目录删除即可。 nvm alias [name] [version] 给不同的版本号添加别名 nvm unalias [name] 删除已定义的别名 nvm reinstall-packages [version] 在当前版本node环境下，重新全局安装指定版本号的npm包。 nvm on 打开nodejs控制。 nvm off 关闭nodejs控制,实际将nodejs映射路径文件夹删除。 nvm arch 显示node是运行在32位还是64位。 nvm proxy [url] 设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。 nvm node_mirror [url] 设置或者查看setting.txt中的node_mirror，不设置默认: https://nodejs.org/dist/ nvm npm_mirror [url] 设置或者查看setting.txt中的npm_mirror,不设置默认: https://github.com/npm/npm/archive/. nvm root [path] 设置和查看root路径,（存储node的目录），如果未设置，默认使用当前目录。 nvm version♣nvm v 查看当前的版本 ☀npm Npm(Node Package Manager) 是node的包管理工具，是用JavaScript写出来的工具 ，被内置进了node中,新版的nodejs已经集成了npm，所以之前npm也一并安装好了。 ☀命令： ☀检测是否成功安装npm 12npm -v 6.4.1 //安装成功会返回这个版本号 ☀使用 npm 命令安装模块 1npm install &lt;Module Name&gt; //&lt;Module Name&gt;指的是模块名 安装多个模块 1npm install &lt;Module Name&gt; &lt;Module Name&gt; 检测安装 1npm i &lt;Module Name&gt; npm i 和 npm install 的区别,实际使用的区别点主要如下(windows下)： 用npm i安装的模块无法用npm uninstall删除，用npm i才卸载掉 。 npm i会帮助检测与当前node版本最匹配的npm包版本号，并匹配出来相互依赖的npm包应该提升的版本号 。 部分npm包在当前node版本下无法使用，必须使用建议版本。 安装报错时intall肯定会出现npm-debug.log 文件，npm i不一定。 ☀全局安装与本地安装 npm 的包安装分为本地安装（local），全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如 123npm install &lt;Module Name&gt; # 本地安装npm install &lt;Module Name&gt; -g # 全局安装// install可以缩写为i 如果出现以下错误： 1npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 解决办法为： 1npm config set proxy null ☀本地安装 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录）如果没有 node_modules 目录，会在当前执行npm 命令的目录下生成node_modules 目录 可以通过 require() 来引入本地安装的包 ☀全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录 如果是nvm安装的node，安装在nvm根目录下的对应node目录中。 可以直接在命令行里使用 ☀–save本地安装保存和根据配置复原依赖安装。 ☀相同点 三者都会本地安装包到项目的node_modules目录中 ☀区别 区别在于对项目package.json的修改，npm install不会修改package.json，而后两者会将依赖添加进package.json，后两者的区别请看下文循序渐进。 ☀指定依赖包 指定包取决于你的项目，你需要在package.json 文件中列出你需要使用的包，有两种包可以选择： “dependencies”： 这些包都是你的应用程序在生产环境中所需要的。 “devDepedencies”：这些包只是在开发和测试中需要的。 ☀手动编辑package.json文件 你可以手动编辑你的package.json。你需要在包的dependencies 对象中创建一个属性用来指出你需要添加的依赖。 例如下面的项目中，在主要生产环境中使用包my_dep的版本1.0.0，而在在开发环境中使用包 my_test_framework 的3.1.0版本。 12345678910&#123; &quot;name&quot;: &quot;my_package&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;dependencies&quot;: &#123; &quot;my_dep&quot;: &quot;^1.0.0&quot; &#125;, &quot;devDependencies&quot; : &#123; &quot;my_test_framework&quot;: &quot;^3.1.0&quot; &#125;&#125; --save 和--save-dev下载标签 他们表面上的区别是–save 会把依赖包名称添加到 package.json 文件 dependencies 键下，–save-dev 则添加到 package.json 文件 devDependencies 键下. dependencies是运行时依赖，devDependencies是开发时的依赖。即devDependencies 下列出的模块，是我们开发时用的 比如 我们安装 js的压缩包gulp-uglify 时，我们采用的是 “npm install gulp-uglify --save-dev”命令安装，因为我们在发布后用不到它，而只是在我们开发才用到它。dependencies 下的模块，则是我们发布后还需要依赖的模块，譬如像jQuery库或者Angular框架类似的，我们在开发完后后肯定还要依赖它们，否则就运行不了。 补充：正常使用npm install时，会下载dependencies和devDependencies中的模块，当使用npm install --production或者注明NODE_ENV变量值为production时，只会下载dependencies中的模块。个人理解：这个功能类似于Ruby的bundle管理依赖包，bundle install 非常好用。 npm install --force 会强制重新安装所有，一般卸载出问题后，就执行此命令。 ☀安装package.json 12npm install #安装dependencies和devDependencies。npm install --production #只安装dependencies而不安装devDependencies。 ❤️❤️❤️❤️❤️注意： 刚下载下来的nodejs项目 package-lock.json 会阻碍一些报的安装，需要删除。 ☀覆盖安装 经过测试，多次install一个包，会覆盖原来的包。 ☀查看模块的版本号 1npm &lt;Module Name&gt; grunt ☀安装指定版本 npm install 默认安装最新版本，如果想要安装指定版本，可以在库名称后加 @版本号 123npm install &lt;Module Name&gt;@latestnpm install &lt;Module Name&gt;@0.1.1npm install &lt;Module Name&gt;@&quot;&gt;=0.1.0 &lt;0.2.0&quot; ☀更新模块 1npm update &lt;Module Name&gt; 更新升级时应该把原本的node-modules文件夹删除，不然的话可能会报错 更新并将版本保存至本地。 1npm install hexo-butterfly-douban --update --save ☀卸载模块 1npm uninstall &lt;Module Name&gt; 参数: ​ --save 将package.json的版本也删除 简写: 1npm un &lt;Module Name&gt; 注意： ​ 如果用cnpm安装，同时也用cnpm卸载。 ☀查看模块信息 1npm list &lt;Module Name&gt; ☀查看模块地址 1npm view &lt;Module Name&gt; repository.url 很多包的地址都是托管在github上 ☀查看帮助信息 1npm help ☀搜索模块，验证某个模块是否存在 发布一个npm包的时候，需要检验某个模块是否已存在 1npm search &lt;Module Name&gt; 如果存在就会显示其完整信息 ☀npm获取全局安装的默认目录 1npm config get prefix ☀npm设置全局安装的默认目录 1npm config set prefix “directory” ☀使用淘宝 NPM 镜像 大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像 你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步 你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm: 1npm install -g cnpm --registry=https://registry.npm.taobao.org 这样就可以使用 cnpm 命令来安装模块了： 1cnpm install [name] ☀cnpm卸载与安装步骤 1.卸载原有旧的版本： 1npm uninstall -g cnpm --registry=https://registry.npm.taobao.org 2.注册模块镜像： 1npm set registry https://registry.npm.taobao.org 3.node-gyp 编译依赖的 node 源码镜像 1npm set disturl https://npm.taobao.org/dist 4.清空缓存 1npm cache clean --force 5.重新安装cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org ☀重新安装所有依赖 1234rm node_modules/rm -rf node_modulesrm package-lock.jsonnpm cache clear --forcenpm install ☀❤️npm使用心得和注意事项 刚下载下来的nodejs项目 package-lock.json 会阻碍一些报的安装，个人觉得没什么用，而且也会影响自动化部署删除，包的删除和更新，所以如果项目中携带了这个文件，建议直接删除，再进行npm的系列操作。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"脚本","slug":"技术知识/脚本","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://aner1001.gitee.io/tags/Nodejs/"},{"name":"nvm","slug":"nvm","permalink":"http://aner1001.gitee.io/tags/nvm/"},{"name":"npm","slug":"npm","permalink":"http://aner1001.gitee.io/tags/npm/"}]},{"title":"Nginx学习笔记","slug":"技术知识/中间件/Nginx学习笔记","date":"2021-05-13T12:20:37.000Z","updated":"2021-05-13T12:20:37.000Z","comments":true,"path":"posts/2021/05/13/fa918a90eed5/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/05/13/fa918a90eed5/","excerpt":"Nginx主要用于1. 静态资源服务器，2. 反向代理，3. 负载均衡，本文主要围绕这三块进行描述。","text":"Nginx主要用于1. 静态资源服务器，2. 反向代理，3. 负载均衡，本文主要围绕这三块进行描述。 ☀1.Nginx功能介绍 Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。 Nginx 应用场景： 1、http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 ☀2.下载和安装 ☀下载 Nginx下载地址 学习所用相关工具： 修改主机的Host文件：SwitchHosts ☀安装 主要介绍nginx系统中的安装，windows系统，开箱即用。 ☀环境准备: （1）需要安装 gcc 的环境【此步省略】 1yum install gcc-c++ （2）第三方的开发包。 PCRE PCRE(Perl Compatible Regular Expressions)是一个 Perl 库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库。 注：pcre-devel 是使用 pcre 开发的一个二次开发库。nginx 也需要此库。 1yum install -y pcre pcre-devel zlib zlib 库提供了很多种压缩和解压缩的方式，nginx 使用 zlib 对 http 包的内容进行 gzip，所以需要在 linux 上安装 zlib 库。 1yum install -y zlib zlib-devel OpenSSL OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在 ssl 协议上传输 http），所以需要在 linux安装 openssl 库。 1yum install -y openssl openssl-devel ☀步骤: 第一步：上传 把 nginx 的源码包nginx-1.8.0.tar.gz上传到 linux 系统 第二步：解压缩 1tar zxvf nginx-1.8.0.tar.gz 第三步：创建配置文件 进入nginx-1.8.0目录 使用 configure 命令创建一 makeFile 文件。 123456789101112./configure \\--prefix=/usr/local/nginx \\--pid-path=/var/run/nginx/nginx.pid \\--lock-path=/var/lock/nginx.lock \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--with-http_gzip_static_module \\--http-client-body-temp-path=/var/temp/nginx/client \\--http-proxy-temp-path=/var/temp/nginx/proxy \\--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\--http-scgi-temp-path=/var/temp/nginx/scgi 执行后可以看到Makefile文件 12345678910111213141516171819202122232425---- 知识点小贴士 ----Makefile是一种配置文件， Makefile 一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。--- 知识点小贴士 ----configure参数./configure \\--prefix=/usr \\ 指向安装目录--sbin-path=/usr/sbin/nginx \\ 指向（执行）程序文件（nginx）--conf-path=/etc/nginx/nginx.conf \\ 指向配置文件--error-log-path=/var/log/nginx/error.log \\ 指向log--http-log-path=/var/log/nginx/access.log \\ 指向http-log--pid-path=/var/run/nginx/nginx.pid \\ 指向pid--lock-path=/var/lock/nginx.lock \\ （安装文件锁定，防止安装文件被别人利用，或自己误操作。）--user=nginx \\--group=nginx \\--with-http_ssl_module \\ 启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）--with-http_flv_module \\ 启用ngx_http_flv_module支持（提供寻求内存使用基于时间的偏移量文件）--with-http_stub_status_module \\ 启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）--with-http_gzip_static_module \\ 启用ngx_http_gzip_static_module支持（在线实时压缩输出数据流）--http-client-body-temp-path=/var/tmp/nginx/client/ \\ 设定http客户端请求临时文件路径--http-proxy-temp-path=/var/tmp/nginx/proxy/ \\ 设定http代理临时文件路径--http-fastcgi-temp-path=/var/tmp/nginx/fcgi/ \\ 设定http fastcgi临时文件路径--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \\ 设定http uwsgi临时文件路径--http-scgi-temp-path=/var/tmp/nginx/scgi \\ 设定http scgi临时文件路径--with-pcre 启用pcre库 第四步：编译 1make 第五步：安装 1make install 第六步：启动 注意：启动nginx 之前，上边将临时文件目录指定为/var/temp/nginx/client， 需要在/var 下创建此 目录 1mkdir /var/temp/nginx/client -p 进入到Nginx目录下的sbin目录 1cd /usr/local/ngiux/sbin 输入命令启动Nginx 1./nginx 启动后查看进程 1ps aux|grep nginx 地址栏输入虚拟机的IP即可访问（默认为80端口） 关闭 nginx： 1./nginx -s stop 或者 1./nginx -s quit 重启 nginx： 1、先关闭后启动。 2、执行重启指令,刷新配置文件： 1./nginx -s reload ☀3.配置介绍 nginx.conf 配置文件所在路径：在nginx安装目录的conf目录下。 ☀server server&#123;&#125; 表示代理的某个服务，下方的配置都在这个server括号中。 ☀listen listen 80 表示服务所监听的端口号 ☀server_name server_name 有匹配规则，与浏览器上输入的域名匹配。优先匹配最精确的。 举例： ==localhost== 指向本机 ==www.tangyefei. com== 域名，最终指向本机 ☀location location 匹配规则，在域名ip和端口号后的地址匹配，/表示全部匹配。 ==注意：==路径的间隔都使用/。 location匹配模式及顺序 表示 描述 location = /uri地址 =开头表示精确匹配，只有完全匹配上才能生效。 location ^~ /uri地址 ^~ 开头对URL路径进行前缀匹配，并且在正则之前。 location ~ 正则表达式 ~开头表示区分大小写的正则匹配。 location ~* 正则表达式 ~*开头表示不区分大小写的正则匹配。 location /uri地址 不带任何修饰符，也表示前缀匹配，但是在正则匹配之后。 location / 通用匹配，拦截所有，但是优先级最低，只有前面都没有被拦截的情况下，才会被拦截到这里。 ☀root root 在location中配置 表示匹配成功后进入主机的目录 相对路径以niginx安装位置为基础，通常是绝对路径。 ==注意：路径都使用/来间隔文件夹。root 路径最后不能为/结束。== 匹配成功查找资源时，root+地址中的location。 ☀index index 在location中配置 在location中配置 默认打开的页面 如果地址匹配成功，并且进入的是某个目录，而不是具体文件，则打开root+location地址中的index指定的文件。 ☀proxy_pass proxy_pass反向代理配置 在location中配置 proxy_pass: 127.0.0.1可以换成任何一个通的内网地址，这个ip表示你要真实访问的tomcat所在的位置，proxy_pass的值就表示你真正访问的域名是什么（站在公网服务器角度来说）。 真正要访问并且代理的服务器地址。 可配置方式： ip+端口或者域名(有默认端口或者映射的端口) ip+端口+某个路径 一般配置了proxy_pass就不需要配置root了。root指向本机资源。proxy_pass指向代理服务器。 最终访问的方式： proxy_pass+location ☀proxy_redirect off 在location中配置 ☀proxy_set_header 在location中配置 proxy_set_header Host $host proxy_set_header X-Real-IP $remote_addr proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for ☀proxy_connect_timeout nginx向tomcat发起连接，即第一次握手等待tomcat回应的超时时间，tomcat的这次回应只是说明能正常连接，并没有响应具体请求的内容。 理解为确认连接的时间。 proxy_connect_timeout 3s; ☀proxy_send_timeout nginx将请求发送给tomcat的超时时间，应该是确认能正常连接之后向tomcat发送真正的业务请求。 理解为建立了连接口，发送请求的时间。 proxy_send_timeout 3s; ☀proxy_read_timeout tomcat接受到真正业务请求之后，nginx等待tomcat响应具体请求的内容的超时时间。差不多可以理解tomcat处理具体请求时间的最大值，也就是tomcat必须在这个时间内做完业务逻辑处理。 理解为发送请求成功后，处理和响应的时间。 proxy_read_timeout 5s; ☀proxy_cookie_path 作用：将服务器返回的 Set-Cookie 中的path进行修改。 应用场景:转载自：https://www.jb51.net/article/187898.htm 背景 一同事求援：后台系统的登录成功了，但不能成功登进系统，仍然跳转到登录页，但同一套代码另一个环境却没有问题。 经了解，他对同一个项目使用tomcat部署了两个环境，一个在开发服务器上，一个在他本机，两个环境代码配置完全相同。两边通过同一个nginx进行反向代理，nginx配置大致如下， 1234567location /health/ &#123; proxy_pass http://192.168.40.159:8081/health/; #无问题的配置 &#125;location /health-dev/ &#123; proxy_pass http://192.168.40.202:8080/health/; #有问题的配置&#125; 一个反向代理到开发环境，一个反向代理到本机服务。 定位 既然代码配置完全相同，那么问题很大可能就出现在nginx的反向代理上。 因为两边location路径不同（即浏览器路径不同），但是反向代理的服务端路径却相同，结合session的基本原理，如下图， 当浏览器第一次打开页面时，服务端会为这次会话创建一个session，并将session id通过response的header传递给浏览器，header一般为 Set-Cookie: JSESSIONID=xxxxx; Path=xxxx 浏览器接收到响应后，如果header Set-Cookie 中path的值与浏览器地址路径匹配，则将该header值存于浏览器的Cookie中 浏览器在下次请求服务器时，将Cookie中的JSESSIONID值通过request的header上报给服务端，header一般为 Cookie: JSESSIONID=xxxx; 服务端可通过该JSESSIONID来定位到对应的session nginx反向代理按这种方式配置时 123location /health-dev/ &#123; proxy_pass http://192.168.40.202:8080/health/;&#125; 浏览器访问 http://www.domian.com/health-dev 时，服务端返回的 Set-Cookie 的 Path 值为 /health （因为中间有反向代理，服务端并不知道代理前的路径是啥，是按最终请求服务端的路径设置），如图 因为浏览器访问地址的路径 /health-dev 与 Set-Cookie 的 Path /health 不匹配，所以浏览器并不会将其值存入Cookie中，如图 因此在下次请求服务器时，浏览器无法设置request Cookie header的 JSESSIONID 值，服务器无法定位到对应的session，因此会将其当做第一次请求，创建一个新的session，如此反复，因此就算你登录认证通过了，但服务器返回的登录凭证（JSESSIONID）浏览器不会保存，并在下次请求时携带，导致服务器认为你是一个新的请求，当然就会又跳到登录页面了。 解决 nginx有一个命令 proxy_cookie_path （参考： proxy_cookie_path ）可将服务器返回的 Set-Cookie 中的path进行修改，格式为 proxy_cookie_path 原路径 目标路径 ，我们在配置中添加 proxy_cookie_path 如下。 1234location /health-dev/ &#123; proxy_pass http://192.168.40.202:8080/health/; proxy_cookie_path /health /health-dev;&#125; 重启nginx，问题解决。 ☀proxy_cookie_domain 作用：修改response中的，set-cookie的domain属性，可以控制cookie的生效域名目标 1234location /api &#123; proxy_pass https://b.test.com; proxy_cookie_domain b.test.com a.test.com;&#125; proxy_cookie_domain的作用是单向的，并不是双向转换的。 浏览器在发送请求的时候，会在request header中带上cookie项(有内容的话)，此时的cookie是一个字符串，一个key=value并用分号分割的字符串， 其中并不包含任何域名信息。这是因为浏览器在设置cookie选项的时候，所选取的内容都是缓存中接口域名下的。然后request的只要请求发送出去之后，cookie中有关domain信息其实是不存在的，它只是一个普通的字符串，随便proxy_pass到任何位置，都会正常携带下去。因此在前端到后端的request的过程中，proxy_cookie_domain是没用的 而server端在做响应的时候，通过set-cookie的domain属性，可以控制cookie的生效域名目标，做到诸如二级域名cookie分离等等，如果前端接收到的set-cookie的domain和当前域名不一致，或者一级域名不一致(二级域名可以共享一级域名下的cookie)，这个cookie在后续的通信中就是无效的，所以这里才需要去做domain的转换，也就是说response中set-cookie的domain转换才是有意义的，这也正是proxy_cookie_domain的作用所在。 当response的set-cookie中domain不去设置时，cookie顺利传入浏览器中，浏览器会自动设置这个cookie的生效域名为当前域名。 ☀add_header 配置在location中。 add_header 是 headers 模块中定义的一个指令，顾名思义就是用来添加 http 响应头的。但请注意他只是「添加」而已，并不是重写。所以如果已经存在某个头，再使用 add_header 就会出问题。而且在低版本的 nginx 中 add_header 还不支持在错误页面中使用。 ☀rewrite //TODO ☀return 配置在location中 设置响应的状态信息 123456789101112location = /b &#123; add_header b 2; return 204;&#125;location = /a &#123; add_header Content-Type application/json; return 200 &#x27;&quot;OK&quot;&#x27;;&#125;location = /a &#123; add_header Content-Type application/json; return 404 &#x27;&quot;Not Found&quot;&#x27;;&#125; ☀default_type 配置在server中。 全局设置response响应的Content-Type参数 123456default_type &#x27;text/plain&#x27;;location = /a &#123; #这里和全局设置冲突。会重复。 add_header Content-Type application/json; return 200 &#x27;&quot;OK&quot;&#x27;;&#125; ☀upstram XXX{} 与server{}同级配置 表示负载均衡的配置，XXX 轮巡算法默认 权重算法在server中添加 weight = X ip绑定算法，添加ip_hash ☀server ​ 负载均衡服务器，上游的服务器，通常格式是Ip:Port ☀ip_hash ​ 表示使用负载均衡的ip绑定算法。 ☀4.反向代理 ==域名可以解析为IP+端口==，猜测如果指向本机，默认端口为80。 **实质：**个人理解反向代理就是nginx拦截动态请求之后转发给某个tomcat。这个在==集群==和==分布式==都可以使用这个来进行配置转发。 作用： 隐藏真实的访问ip地址。我们可以看到流程图中我们访问的最多也就是公网的ip，但是具体tomcat在那个ip是不知道的，这样就能减少tomcat被攻击，提高了服务器的安全性。 ☀5.动静分离 ☀概念 ☀静态资源： 静态资源： html、js、css、图片、音乐、视频等。当用户多次访问这个资源，资源的源代码永远不会改变或者很少改变的资源。 ☀动态资源： 动态资源：当用户多次访问这个资源，资源的源代码可能会发生改变。 ​ &gt; 我的理解就是我们所说的接口。这里需要注意的是：themleaf、freemark这些模板引擎的html不是静态资源而应该属于动态资源（个人认为）。 ☀动静分离： 动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，简单的概括是：动态文件与静态文件的分离。动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路 ☀伪静态 伪静态：网站如果想被搜索引擎搜素到，动态页面静态技术freemarker等模版引擎技术 ☀动静分离原因： 在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗。==当然这是可以的，但是这样后台的请求次数就明显增多了。==在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决。 动静分离将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。这里我们将静态资源放到nginx中，动态资源转发到tomcat服务器中。 因此，动态资源转发到tomcat服务器我们就使用到了前面讲到的反向代理了。 之前项目中需要用到百度地图，由于项目的特殊环境，所以需要下载百度的离线地图。我们知道，地图的展示其实就是一张张地图的图片展示，我们在网页上浏览查找位置的时候，其实都是在发送图片请求。这些图片请求相对于jsp，servlet来说就是所谓的静态资源，当然服务中的静态资源不仅仅只是图片，像页面样式css文件，js脚本文件这些都可以看着是静态资源。==tomcat既可以静态资源也可以处理动态资源。但是单节点的tomcat本身处理请求的资源是有限的，如果项目中的tomcat既处理动态请求有要处理大量的静态资源。显然是不合理的，也就是会遇到tomcat的性能瓶颈问题，对于静态资源的处理我们有更好的服务器像Nginx,Apache.他们处理静态资源的能力比Tomcat强很多==，那么我们能不能对请求进行分工呢?静态资源的请求由Nginx来处理，像jsp我们交给tomcat来处理。这样也能减轻tomcat的处理压力。 ==个人理解：== Tomcat也可以处理静态资源，动静分离也可以分两个Tomcat减缓访问压力。Nginx处理静态资源能力更加优秀。 总结： 1.提高用户访问静态代码的速度，降低对后台应用访问，降低后台压力。 2.总体提高资源的响应速度。 ☀实现动静分离的两种方法： ☀通过不同域名来拦截 动态请求和静态请求使用不同的域名。比如所有的静态资源都使用static.tuesdayma.com域名来访问，所有的接口都使用www.tuesdayma.com来请求。 图片理解： ==优点：==扩展性比较强，静态资源是什么都可以。 ==缺点：==存在跨域问题，所有的html全靠ajax请求来请求接口，后端域名和前端不一致导致跨域问题,实际是因为配置了两个server导致跨域。 ☀location来拦截 只配置一个server，然后配置两个location，一个通过正则表达式拦截静态资源，还有一个拦截.do结尾的接口请求。 ==优点：==不存在跨域问题。 ==缺点：==扩展性太差，静态资源的类型不可确定，每增加一种类型都需要重新修改配置文件并且重启nginx。 ☀6.负载均衡 ☀原因与作用： 为了解决高并发问题，负载均衡服务器拦截所有的请求，采用负载均衡算法，分配到不同的tomcat上。 作用： 减少单台tomcat的压力 ☀三种基本的负载均衡算法： 轮询 nginx==默认==的负载均衡算法，简单来说就是从上到下按顺序轮流（127.0.0.1:8082轮完就轮到127.0.0.1:8081，127.0.0.1:8081轮完就轮到127.0.0.1:8082）。注意：mzd的地方需要保持一致。。。 1234upstream mzd &#123; server 127.0.0.1:8082; server 127.0.0.1:8081; &#125; 权重 我的理解就是哪台服务器配置好就多轮几次，或者你就想某个服务器多轮几次。简单来说就是轮到次数的比例，数字越大表示轮到的概率越大。（个人认为weight都设置为1的时候和轮询没什么区别） 1234upstream mzd &#123; server 127.0.0.1:8082 weight=2; server 127.0.0.1:8081 weight=3; &#125; ip绑定 我的理解就是你第一次访问的时候，nginx会根据你的ip通过哈希算法，算出某个值，然后取分配哪个tomcat，当你第二次访问，第三次访问。。。之后的任何一次访问都是去请求那个第一次访问的tomcat。 12345upstream mzd &#123; server 127.0.0.1:8082 ; server 127.0.0.1:8081 ; ip_hash; &#125; ☀7.故障转移机制 在负载均衡下存在故障转移机制 其实nginx有默认故障转移机制的，但是很慢（本人测了一下，默认好像是要60秒左右，一分钟后就有自动发送到其他tomcat上去了 可通过手工配置超时时间： proxy_connect_timeout proxy_send_timeout proxy_read_timeout ☀8.命令 ☀Windows 启动 CMD切换到nginx.exe目录下： start nginx nginx.exe 停止 nginx.exe -s stop nginx.exe -s quit stop是快速停止nginx，可能并不保存相关信息；quit是完整有序的停止nginx，并保存相关信息。 ==注意：==使用停止命令的时候，不能修改nginx.conf文件，在原启动时配置的文件基础上停止。否则可能会报d错。nginx: [error] CreateFile() 测试配置文件是否有效 nginx.exe -t 重新载入 nginx.exe -s reload 当配置信息修改，需要重新载入这些配置时使用此命令。 重新打开日志文件 nginx.exe -s reopen 查看nginx版本 nginx -v ☀Linux 1.启动 cd 到nginx安装路径的sbin目录下 ./nginx 2.测试配置文件是否有效 ./nginx -t 3.重启nginx ./nginx -s reload 4.查看nginx版本 ./nginx -v ☀9.配置案例： ☀1.静态资源服务器 ☀root相对路径 123456789101112server &#123; listen 80; server_name www.tuesdayma.com; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ☀域名匹配访问不同资源 123456789101112131415161718192021222324server &#123; listen 80; server_name static.Tuesdayma.com; location / &#123; root extend/static; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;server &#123; listen 80; server_name www.Tuesdayma.com; location / &#123; root extend/www; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ☀2.反向代理 123456789101112 server &#123; listen 80; server_name www.tuesdayma.com; location / &#123; proxy_pass http://127.0.0.1:8090; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; ☀3.动静分离 ☀通过不同域名来拦截 1234567891011121314151617181920212223242526272829#动态请求拦截 server &#123; listen 80; server_name www.Tuesdayma.com; location / &#123; # proxy_redirect off; # proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; #静态请求拦截 server &#123; listen 80; server_name static.Tuesdayma.com; location /nginx_static&#123; root F:/; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ☀4.负载均衡 ☀1.轮询 12345678910111213141516upstream mzd &#123; server 127.0.0.1:8082; server 127.0.0.1:8081; &#125; server &#123; listen 80; server_name www.tuesdayma.com; location / &#123; proxy_pass http://mzd; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 本机nginx的负载： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354upstream tw&#123; server 127.0.0.1:8080; server 127.0.0.1:8081;&#125;server &#123; listen 8080; server_name 127.0.0.1; location / &#123; root D:/Data/Html/nginx1; index nginx1.html; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;server &#123; listen 8081; server_name 127.0.0.1; location / &#123; root D:/Data/Html/nginx2; index nginx2.html; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; server &#123; listen 80; server_name www.tangyefei.com; location / &#123; proxy_pass http://tw; index xiaowan.html; &#125; location /Html &#123; root D:/Data; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ☀2.权重 12345678910111213141516upstream mzd &#123; server 127.0.0.1:8082 weight=2; server 127.0.0.1:8081 weight=3; &#125; server &#123; listen 80; server_name www.tuesdayma.com; location / &#123; proxy_pass http://mzd; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ☀3.ip绑定 1234567891011121314151617upstream mzd &#123; server 127.0.0.1:8082 ; server 127.0.0.1:8081 ; ip_hash; &#125; server &#123; listen 80; server_name www.tuesdayma.com; location / &#123; proxy_pass http://mzd; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; ☀5.配置超时 12345678910111213141516server &#123; listen 80; server_name www.tuesdayma.com; location / &#123; proxy_pass http://mzd; proxy_connect_timeout 3s; proxy_read_timeout 5s; proxy_send_timeout 3s; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; ☀6.Nginx匹配路径部分替换 nginx 配置 proxy_pass时可以实现URL路径的部分替换。 1.proxy_pass的目标地址，默认不带/，表示只代理域名，url和querystring部分不会变（把请求的path拼接到proxy_pass目标域名之后作为代理的URL） 2.如果在目标地址后增加/，则表示把path中location匹配成功的部分剪切掉之后再拼接到proxy_pass目标地址 123456789101112server &#123; access_log /home/access.log; error_log /home/error.log; server_name h5.xxx.com; location /abc &#123; proxy_pass http://server_url; &#125; location /abc &#123; proxy_pass http://server_url/; &#125; &#125; 比如请求 /abc/b.html 如上两个匹配成功后，实际代理的目标url分别是 http://server_url/abc/b.html (把/abc/b.html拼接到http://server_url之后) http://server_url/b.html (把/abc/b.html的/abc去掉之后，拼接到http://server_url/之后) ☀7.Nginx跨域设置 解决场景： 静态资源服务器与nginx服务器不是同一台，nginx代理的服务器，未设置跨域。（简称非同源下的nginx代理） 同源下的代理就不需要设置跨域了。 个人理解可以解决，服务器端设置CORS的cookie缺陷。服务支持多源跨域访问，同时支持cookie。其实就是将服务器设置的CORS转移到代理服务器，变得灵活起来。 一句话：同源下的代理需不要设置跨域，非同源下的代理需要设置跨域。 123add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET,POST&#x27;; 生效的方案： 12345678910111213141516171819if ($request_method = &#x27;OPTIONS&#x27;) &#123; add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;; add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;; add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;; add_header &#x27;Access-Control-Max-Age&#x27; 1728000; add_header &#x27;Content-Type&#x27; &#x27;text/plain charset=UTF-8&#x27;; add_header &#x27;Content-Length&#x27; 0; return 204; &#125; if ($request_method = &#x27;POST&#x27;) &#123; add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;; add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;; add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;; &#125; if ($request_method = &#x27;GET&#x27;) &#123; add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;; add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;; add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&#x27;; &#125; ☀10.常见报错 nginx -s reload 时报错 Nginx错误：nginx: [error] OpenEvent(“Global\\ngx_reload_6252”) failed (2: The system cannot find the file specified) 错误原因：Nginx 尚未启动导致，执行 start nginx 命令开启Nginx 访问时报错 ginx1&quot; failed (123: The filename, directory name, or volume label syntax is incorrect), client: 127.0.0.1, server: 127.0.0.1, request: “GET / HTTP/1.0”, host: “tw” 2020/10/28 21:34:14 [crit] 18412#15040: *26 CreateFile() &quot;D:\\Data\\Html 错误原因：配置root路径使用了 \\ ☀11.参考文献 Nginx反向代理理解误区之proxy_cookie_domain nginx配置教程之add_header的坑详解 Nginx跨域设置Access-Control-Allow-Origin无效的解决办法","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"中间件","slug":"技术知识/中间件","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://aner1001.gitee.io/tags/Nginx/"}]},{"title":"GoogleAnalytics","slug":"技术知识/工具/GoogleAnalytics","date":"2021-05-04T00:48:11.000Z","updated":"2021-05-04T00:48:11.000Z","comments":true,"path":"posts/2021/05/04/3c666189d167/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/05/04/3c666189d167/","excerpt":"记录谷歌分析工具的使用(✪ω✪)。","text":"记录谷歌分析工具的使用(✪ω✪)。 谷歌分析，即大家俗称的ga，全称google analytics，是谷歌推出的网站流量分析工具，可以说是当前业界最强大的流量分析工具，并且完全免费。 ☀产品介绍 ☀GA工作原理： ☀GA与China 对于网站数据发送GA服务器不会被墙。 GA报表呈现被墙。查看数据报告需要翻墙。 ☀通过GA分析什么数据 1.分析登录浏览网站的用户的行为。 2.分析网站本身的标签内容，互动内容，鼠标滚动。 ☀GA账户结构 1.账号：GA的入口。理解为一个公司或者一个集团。 2.媒体资源，公司集团下的网站或者移动应用设备。一个账号对应多个媒体资源。 3.数据视图：用户数据，浏览数据，行为数据等等。 1账户/50媒体资源/25个视图。 ☀使用步骤 ☀第一步：注册GOOGLE帐号 要使用GA，必需先成为GOOGLE的注册用户，如果没有请去注册。当然，你有GMAIL邮箱就可以。邮箱就是帐户名。 ☀第二步：开启Google Analytics分析工具 当你有了GOOGLE账户后，你会发现里面只有基本的功能和服务，找不到GA，呵呵，别担心，你需要去开通一下GA工具才行。访问这个地址https://marketingplatform.google.com/info?authuser=0进行注册。当然这个产品介绍网站做的也很不错。很值得我们学习。注册后，再次登录到GOOGLE账户，你会发现你的服务里已经有了GA工具。 ☀第三步：配置跟踪站点 管理——&gt;创建账——&gt;创建媒体资源——&gt;数据流 获取GA代码： 数据流 在获得GA代码后，你所要做的是将这个代码放在你需要跟踪页面的 标记之前。一般都是放在index页面上。 ☀参考文献 ☀视频 ☀博客帖子 https://www.cnblogs.com/wuling129/p/5220679.html","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Google","slug":"Google","permalink":"http://aner1001.gitee.io/tags/Google/"},{"name":"GoogleAnalytics","slug":"GoogleAnalytics","permalink":"http://aner1001.gitee.io/tags/GoogleAnalytics/"}]},{"title":"搭建个人图床","slug":"技术知识/工具/搭建个人图床","date":"2021-05-03T23:47:18.000Z","updated":"2021-05-03T23:47:18.000Z","comments":true,"path":"posts/2021/05/03/3893ce8c324a/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/05/03/3893ce8c324a/","excerpt":"介绍了PicGo工具的使用，图床的选择，和CDN.jsDelivr加速的使用方法。Typroa中如何配置使用的办法。","text":"介绍了PicGo工具的使用，图床的选择，和CDN.jsDelivr加速的使用方法。Typroa中如何配置使用的办法。 ☀PicGo ☀简介 所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用PicGo还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等， 个人理解： ​ 图床工具就是简化了上传到指定图片服务器(图床)的操作，并且自动将生成的图片访问连接放在粘贴板。如果配置了反向代理、加速功能的域名路径前缀，也会将前缀覆盖添加在最终的图片访问连接中。使得一系列操作更加便捷了。 ☀下载 下载地址 注意：mac 系统选择 dmg 下载，windwos 选择 .exe系统，如果不是下载安装包，想看源码的话，可以选择 git clone https://github.com/Molunerfinn/PicGo.git 克隆到本地 ☀jsDelivr ☀简介 jsDelivr 是国外的一家优秀的公共 CDN 服务提供商，也是首个「打通中国大陆（网宿公司运营）与海外的免费 CDN 服务」 jsDelivr 有一个十分好用的功能——它可以加速 Github 仓库的文件。我们可以借此搭建一个免费、全球访问速度超快的图床。 声明：静态文件主要是缓存在 jsDelivr 的 CDN 节点上，确保 GitHub 承受最小的负载，并且你还可以从 GitHub 仓库获得快速简便的静态文件托管。 **个人理解：**jsDelivr的gh模块，为raw.githubusercontent.com做了全球反向代理。 ☀使用限制 jsDelivr仅能针对50M以下的文件CDN加速！经过使用测试现在是20M了。 ☀通过jsDelivr引用资源 使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如：https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.png https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css [https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The Pet Girl of Sakurasou.mp4](https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The Pet Girl of Sakurasou.mp4) 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： // 加载任何Github发布、提交或分支 https://cdn.jsdelivr.net/gh/user/repo@version/file // 加载 jQuery v3.2.1 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js // 使用版本范围而不是特定版本 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本 https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js 最新版本就是最新的将版本号换成latest即可！或者不带版本号！或者直接@master(或者其他分支名称)！ // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成 https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表 https://cdn.jsdelivr.net/gh/jquery/jquery/ 官方教程： 延迟对比： ☀PicGo+GitHub+Jsdelivr搭建个人图床 ☀前言 图床是个啥东西就不用过多介绍了，先来对比一下各路图床： 微博图床：以前用的人比较多，从2019年4月开始开启了防盗链，凉凉 SM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧 其他小众图床：随时有挂掉的风险 Imgur等国外图床：国内访问速度太慢，随时有被墙的风险 大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，容量限制，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说） 因此，GitHub图床是个不错的选择，利用jsDelivr CDN加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo工具一键上传，操作简单高效，GitHub和jsDelivr都是大厂，不用担心跑路问题，不用担心速度和容量问题，而且完全免费，可以说是目前免费图床的最佳解决方案！ ☀搭建步骤 ☀1.创建一个github仓库作为图床。 ​ public权限。 &gt; 用于存需要上传的图片。这个仓库最好是public的，因为private的仓库，图片链接会带token，这个token又存在过期的问题。 ​ 创建仓库步骤略。 ☀2.Github中申请一个Token。 申请token的作用是配置在picgo工具中，使得picgo连接github有权限将图片上传到生成token用户的仓库中。 在主页依次选择【Settings】-【Developer settings】-【Personal access tokens】-【Generate new token】，填写好描述，勾选【repo】，然后点击【Generate token】生成一个Token，注意这个Token只会显示一次，自己先保存下来，或者等后面配置好PicGo后再关闭此网页。 ​ b581a26841bf78f72aedb9e954faaa554e3a9540 ☀3.安装和配置PicGo 配置： 选项 说明 （必填*） 值 设定仓库名 用户名/仓库名 * aner1001/picBed 设定分支名 用来做图床的仓库master就可以 * master 设定token 申请的token * 存储路径 仓库子目录路径。创建并存放其中。 设定自定义域名 配置一些github访问代理加速的域名,如jsDelivr https://yefeit-note-picbed.oss-cn-shanghai.aliyuncs.com 必填项：必填项用于github的连接访问和鉴权，仓库定位。 选填项会拼接在图片路径中。 ☀PicGO+GitHub+GitHubPages搭建个人图床 如果代理加速网站后续，无法使用了。可以直接使用github Pages中的功能访问图片。 ☀搭建步骤： ☀1. 将图床仓库开启github Pages。 ​ 点击仓库settings——&gt;GitHub Pages ——&gt;master-root-save. ☀2. 配置PicGo ​ 关键域名参数：https://aner1001.github.io/picBed ​ **注意：**可能上传了之后，链接不能立马生效，因为github pages发版的原因。等5分钟就可以了。 ☀Typroa中配置PicGo实现粘贴即上传 进行如下配置后，可以在编写markdown时直接粘贴图片，Typora会调用PicGo，实现图片上传。 要求Typora的版本在0.9.84及以上，版本低于此的，【偏好设置】-【版本更新】 打开PicGo 【PicGo设置】 -【设置Server】，进行如下配置(一般都为默认) 打开Typora，选择【偏好设置】 - 【图像】 进行如下设置 点击验证图片上传选项，观察success是否为true。成功之后打开GitHub图床仓库，就可以看到两个Typora的图标了~说明配置非常成功。这里验证显示失败了，测试一下实际粘贴能否上传。实际测试可以成功！就OK。 现在在Typora中粘贴图片，会自动上传到Github图床，并且自动替换连接，非常省心省事~~~ ☀参考文献 Images in Typora Typora+PicGo+阿里云oss搭建私人图床，完美markdown体验","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://aner1001.gitee.io/tags/GitHub/"},{"name":"PicGo","slug":"PicGo","permalink":"http://aner1001.gitee.io/tags/PicGo/"},{"name":"jsDelivr","slug":"jsDelivr","permalink":"http://aner1001.gitee.io/tags/jsDelivr/"},{"name":"GitHubPages","slug":"GitHubPages","permalink":"http://aner1001.gitee.io/tags/GitHubPages/"}]},{"title":"跨域解决方案","slug":"技术知识/Web/跨域","date":"2021-05-03T13:36:43.000Z","updated":"2021-05-03T13:36:43.000Z","comments":true,"path":"posts/2021/05/03/ec8e6e150ef7/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/05/03/ec8e6e150ef7/","excerpt":"跨域相关的概念、造成跨域的原因、以及9大解决跨域的方案。","text":"跨域相关的概念、造成跨域的原因、以及9大解决跨域的方案。 ☀概念 源：（origin）就是协议、域名和端口号。 同源： 同源指协议、域名、端口皆相同。 同源策略Same origin policy： 同源策略（Same origin policy）是一种约定，它是由Netscape提出的一个著名的安全策略。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 同源策略是浏览器的一个安全功能，主要时为了防止CSRF攻击【利用用户的登录专改发起恶意请求】，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源，阻止用户读取到另一个域下的内容。现在所有支持JavaScript 的浏览器都会使用这个策略。所以a.com下的js脚本采用ajax读取b.com里面的文件数据是会报错的，请求被发送出去了，但是相应被浏览器拦截。 同源策略控制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 总： 同源策略 是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。实际上，这种策略只是一个规范，并不是强制要求，各大厂商的浏览器只是针对同源策略的一种实现。它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 同源策略限制： JS中的AJAX cookie不能读取 （如我在自己的站点无法读取博客园用户的cookie） dom无法获得 浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。 不受同源策略限制: 页面中的链接(浏览器输入框)，重定向以及表单提交是不会受到同源策略限制的。联想到postman，soapui工具也不会受到同源影响。 跨域资源的引入是可以的。但是js不能读写加载的内容。如嵌入到页面中的&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等。 前端/js跨域 受前浏览器同源策略的影响，不是同源的脚本不能操作其他源下面的对象。想要操作另一个源下的对象是就需要跨域。 js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名(或主机地址)、端口有任何一个不同，都被当作是不同的域。 总： 跨域 简单的来说，指的是两个资源非同源。出于安全方面的考虑，页面中的JavaScript在请求非同源的资源时就会出 跨域问题 ——即跨域请求（非同源策略请求），这时，由于同源策略，我们的请求会被浏览器禁止。也就出现了 我们常说的 跨域 问题。 举例： 1234567**在 a的应用的js脚本中调用了b的后端地址**http://cas.feixue.com ahttp://cart.feixue.com ba: jsajax请求的方式调用 --&gt;http://cart.feixue.com/......do 上述的错误信息为 不能加载该地址, 头信息 Access-Control-Allow-Origin 不存在!,为什么默认不能跨域,主要是为了安全考虑. 同源策略请求 ajax / fetch（新诞生的数据通信方式） 跨域传输 gmap 开发在本地修改host可以模拟出同源的效果。 服务器拆分： web服务器：静态资源 data服务器：业务逻辑和数据分析 图片服务器： ☀解决方法 ☀1、JSONP： JSONP需要服务器端的支持。 ☀实现思路和原理： 字符串的魅力 ☀Jquery实现JSONP示例： 有多种实现方式，ajax，单独jsonp模块，或者vue中的模块。 ☀ajax实现 123456789$.ajax(&#123; url:&#x27;http://127.0.0.1:8081/list&#x27;, method:&#x27;get&#x27;, dataType:&#x27;jsonp&#x27;,//执行的是jsonp的请求 success:function(result)&#123; console.log(result); &#125;&#125;); ajax dataType： dataType默认类型是：String 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值: “xml”: 返回 XML 文档，可用 jQuery 处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 “script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） “json”: 返回 JSON 数据 。 “jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 “text”: 返回纯文本字符串 其中，text和xml类型返回的数据不会经过处理。数据仅仅简单的将XMLHttpRequest的responseText或responseHTML属性传递给success回调函数， ‘’‘注意’’’，我们必须确保网页服务器报告的MIME类型与我们选择的dataType所匹配。比如说，XML的话，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。 如果指定为html类型，任何内嵌的JavaScript都会在HTML作为一个字符串返回之前执行。 如果指定script类型的话，也会先执行服务器端生成JavaScript，然后再把脚本作为一个文本数据返回。 如果指定为json类型，则会把获取到的数据作为一个JavaScript对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，他首先尝试使用JSON.parse()。如果浏览器不支持，则使用一个函数来构建。JSON数据是一种能很方便通过JavaScript解析的结构化数据。 如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用jsonp类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback，可以通过设置$.ajax()的jsonp参数。 ☀现况： JSONP现在已经不怎么使用了。 注意：JSONP只支持GET请求(资源文件请求)，不支持POST请求。 安全问题：参数容易被截取。响应JS文本加入木马程序。 ​ ☀2、CORS跨域资源共享 ☀使用前提背景 浏览器需要支持CORS 当js调用跨域被阻止时，会报如下错误：No ‘Access-Control-Allow-Origin’ header is present on the requested resource. 这说明浏览器支持CORS，需要在服务端进行配置。 ☀CORS原理 所有支持CORS的浏览器客户端，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin。发送跨域请求的时候，都会预先发送一个OPTIONS试探性请求。验证服务器端的response是否配置了CORS。 客户端只需要发送请求(ajax/fetch)即可，配置在服务器端： 服务器response的header中设置参数： 参数 值 说明 Access-Control-Allow-Origin * http://127.0.0.1:3001 Access-Control-Allow-Methods PUT,POST,GET,DELETE,OPTIONS,HEAD 跨域允许的客户端请求方法。 Access-Control-Allow-Headers Content-Type,Content-Length,Authorization,Accept,X-Requested 跨域允许的客户端请求头head设置。 Access-Control-Allow-Credentials true 跨域是否允许携带资源凭证，如：cookie。 ☀现况： 缺陷: 设置Access-Control-Allow-Origin 只能有两种，*和具体地址。 *设置了，就不能使用cookie了。**为啥不能使用cookie，浏览器为了保证安全性。 能使用cookie的只有具体地址，但只能设置一个。--------使用nginx+cors技术解决。 ☀3、代理：http proxy ☀核心思想 使用后端作为中间件代替前端访问跨域的请求。 例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。 ☀代理工具： 1.nginx 2.webpack webpack-dev-server ☀4.post message postMessage解决跨域、跨窗口消息传递 平时做web开发的时候关于消息传递，除了客户端与服务器传值还有几个经常会遇到的问题 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个问题的跨域数据传递 比较全面的说明文档： MDN-window.postMessage html5 postMessage解决跨域、跨窗口消息传递 两个不同源的Html页面代码示例： 注意iframe.onload(){} A.html B.html ☀5.socket.io html5中提供的websocket协议来完成。 微信中的实时聊天技术，使用的是socket.io来玩。 客户端 服务器端 ☀6. document.domain + iframe 实现同一个主域，不同子域之间页面的操作。 v.qq.com ——&gt;qq.com sport.qq.com ——&gt;qq.com 俗话说的降域操作。 ☀代码示例： ☀现况 只能实现同一个主域，不同子域之间的操作。限制比较多。 ☀7.window.name + iframe 实现不同域之间的操作。 B.html 同源的空代理页面： proxy.html A.html 关键步骤，需要将iframe的地址重新指向到同源的代理页面中。 ☀8.location.hash + iframe ☀代码示例 A.html 关键步骤，改变跨域路径的hash值。 B.html 关键步骤： 1. 嵌入iframe源域的c.html页面。 2. 监听hash值改变。 ​ C.html ​ 关键步骤： 1. 监听hash改变。 2. 通过操作同域的A的js回调。 ☀现况： ​ 通过url传数据存在局限。仅供参考。 ☀9.本地测试修改host ☀场景： ​ 接口部署在服务器，为方便本地启动测试，修改host文件，在测试时页面和接口非跨域访问。 ☀总结 实现跨域的方式分类： 利用允许跨域机制 使其变成同源 ☀参考资料： https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy https://segmentfault.com/a/1190000015597029 https://blog.csdn.net/tjcjava/article/details/76468225 https://blog.csdn.net/yup1212/article/details/87633272 https://www.cnblogs.com/itmacy/p/6958181.html 同源策略 什么是同源策略 视频：","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Web","slug":"技术知识/Web","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Web/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://aner1001.gitee.io/tags/%E8%B7%A8%E5%9F%9F/"}]},{"title":"java1.8新特性Lamdba表达式","slug":"技术知识/Java/基础/java1-8新特性Lamdba表达式","date":"2021-04-30T11:19:02.000Z","updated":"2021-04-30T11:19:02.000Z","comments":true,"path":"posts/2021/04/30/0aeb75b8584e/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/04/30/0aeb75b8584e/","excerpt":"lambda表达式可以替代只有一个抽象函数的接口实现，告别匿名内部类，代码看起来更简洁易懂. 参考学习资料","text":"lambda表达式可以替代只有一个抽象函数的接口实现，告别匿名内部类，代码看起来更简洁易懂. 参考学习资料 lambda表达式的使用 ☀1、Lambda表达式概念 lambda表达式可以替代只有一个抽象函数的接口实现，告别匿名内部类，代码看起来更简洁易懂 lambda表达式同时还提升了对集合、框架的迭代、遍历、过滤数据的操作 lambda可以极大的减少代码冗余，同时代码的可读性要好过冗长的内部类，匿名类 ☀2、lambda表达式的语法 ​ LambdaParameters -&gt; LambdaBody ​ args-&gt;expr或者（object … args）-&gt;{函数式接口抽象方法实现逻辑} ​ 1、（）参数的个数，根据函数式接口里面抽象的参数个数来决定，当参数只有一个的时候，（）可以省略 ​ 2、当expr逻辑非常简单的时候，{}和return可以省略 ☀3、表达式案例 ​ ()-&gt;{} ​ ()-&gt;{System.out.println(1);} ​ ()-&gt;System.out.println(1) ​ ()-&gt;{return 100;} ​ ()-&gt;100 ​ ()-&gt;null ​ (int x)-&gt;{return x+1;} ​ (int x)-&gt;x+1 ​ (x)-&gt;x+1 ​ x-&gt;x+1","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://aner1001.gitee.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"MarkDown+Typroa学习笔记","slug":"技术知识/工具/MarkDown-Typroa学习笔记","date":"2021-04-23T11:12:58.000Z","updated":"2021-04-23T11:12:58.000Z","comments":true,"path":"posts/2021/04/23/80d2e7f0afbd/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/04/23/80d2e7f0afbd/","excerpt":"总结了MarkDown语法和Typroa使用的快捷键、使用技巧、设置项等。","text":"总结了MarkDown语法和Typroa使用的快捷键、使用技巧、设置项等。 ☀1.MarkDown语法 ☀1.1 标题 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 ☀1.2 字体 **加粗** *倾斜* ***加粗倾斜*** ~~删除线~~小弯弯 &lt;u&gt;下划线&lt;/u&gt; ==高亮== ？ 我是^上标^ ？ 我是~下标~ ? ☀1.3 列表 无序列表：+或-或 * 一二三四五 按回车自动续。 上山打老五第一行的+删除后，两个空格加上+ ，到下一级列表 老虎没打到 打到小松鼠双回车，跳出当前列表 有序列表：1+.+空格 ​ 按住shift+回车 不会自动跳到2的列号上，就是换行还属于1序号的内容。如果只按回车就会跳到下一个序列。==列表中内容换行尽量用Shift+回车表明不需要跳到下一个序列。== 一问三四五 上山打老五 老虎没打到0 打到小松鼠 任务列表： [x] xxx [ ] d [ ] dd ☀1.4 表格 MON TUE WED TNU FRI 上山 上山 上山 上山 上山 打老虎 打老虎 打老虎 打老虎 打老虎 切换出源代码模式比较方便，只需要打一个表格头按回车就可以弹出表格。 调整行列，每一列的居中，左对齐、右对齐都比较方便。 通过代码对齐： 左对齐|:------| 右对齐|-------:| 居中对齐|:-------:| 快捷键CTRL+T ☀1.5 引用 一二三四五 上山打老虎 老虎没打到 打到小松鼠 &gt;+空格出现引用 &gt;&gt;&gt;....多个&gt;给引用分级。 一帮用于别人的文档内容或者名句。 ☀1.6 分割线 连着打连字符-------或者星号*********哈哈。 ☀1.7 代码 单行代码两个小斜斜 英文状态下的`，被称为小斜斜。 HelloWorld 一般操作就是先打一个`,将内容输入完毕后，再输入一个小斜斜作为结尾。 多行代码，三个小斜斜为一组，上下两组将多行代码夹住。 123public static void main(String args)&#123; System.out.println(&quot;HelloWorld&quot;);&#125; 非源代码模式下，快捷方法为，输入三个小斜斜后==再输入代码名称==，回车直接弹出代码框，上下切换输入内容框和语言。太帅了。 ==```java== ☀1.8 反转义 使用 \\ 可使 Markdown 解析时不会去解析本该属于语法部分的一些符号。 例： 1\\`代码块\\` 效果： `代码块` ☀1.9 符号表情 :smile:英文冒号+表情英文+英文冒号 😄 ☀1.10 跳转 ☀1.10.1 外部跳转–超链接 [连接名称](连接地址) 百度 如果要打开连接，Typroa中按住Ctrl+鼠标左键。 ☀1.10.2 内部跳转–本文件内跳转 [跳转名称](#+标题名) Typroa使用 同样按住Ctrl+鼠标左键跳转到指定标题位置。 ☀1.10.3 自动连接–不带名称的地址 URL或者邮箱地址都行。外部跳转和自动连接视使用情况而定。 &lt;www.baidu.com&gt; &lt;www.baidu.com&gt; 5848560254@qq.com ☀1.11 图片 ![自己起的图片名字](图片地址或者本地图片地址) ☀1.11.1 外部图片 ![酷乐猫](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1601649589932&amp;di=a62749b9058429787e9d2dc84c860c3e&amp;imgtype=0&amp;src=http%3A%2F%2Fimgwx5.2345.com%2Fdianyingimg%2Fdongman%2Fimg%2F9%2F1%2Fsup3704_223x310.jpg) 效果展示： ☀1.11.2 本地图片 本地图片，如果md文件和实际图片位置离得很近，直接使用相对路径。离得远就直接拷贝。 ![糖糖午睡](午睡.jpg) 效果展示： ☀1.12 流程图 Mermaid是一个用于画==流程图、状态图、时序图、甘特图==的库。使用JS进行本地渲染，广泛集成于许多MarkDown编辑器中，Mermaid作为一个使用js渲染的库，生成的不是一个图片，而是一段HTML代码。 MarkDown画图是一个轻量级的，功能并不全。 ☀1.12.1 流程图(Graph) ☀1.12.1.1概述 12graph 方向描述 图标中的语句 关键词graph表示一个流程图的开始，同时需要指定该图的方向。 其中“方向描述”为： 用词 含义 TB 从上到下 BT 从下到上 RL 从右到左 LR 从左到右 T=TOP，B=BOTTOM，L=LEFT，R=RIGHT，D=DOWN 最常用的布局方向是TB、LR。 1234graph TB; A--&gt;B B--&gt;C C--&gt;A 1234graph TB; A--&gt;B B--&gt;C C--&gt;A 1234graph LRA--&gt;BB--&gt;CC--&gt;A 1234graph LRA--&gt;BB--&gt;CC--&gt;A ☀1.12.1.2 节点形状 流程图在代码中，可以提现程序的执行过程。 表述 说明 含义 id[文本] 矩形节点 表示过程，也就是流程中的一个执行环节。可以理解为调用某个方法。 id(文字) 圆角矩形节点 表示开始和结束(start和end) id((文字)) 圆形节点 表示连接，为了避免流程过长或者有交叉，可以将流程切开。成对。 id{文字} 菱形节点 表示判断、决策(if语句) id&gt;文字] 右项旗帜状节点 **单向箭头线段：**表示流程进行方向。 id即为节点的唯一标识，A-F是当前节点的名字，类似于变量名，画图时便于引用。 括号内是节点中要显示的文字，如果名字后不带符号，默认为矩形节点。 1234567graph TBAB[矩形节点]C(圆角矩形节点)D((圆形节点))E&#123;菱形节点&#125;F&gt;右项旗帜状节点] 1234567graph TBAB[矩形节点]C(圆角矩形节点)D((圆形节点))E&#123;菱形节点&#125;F&gt;右项旗帜状节点] 12345graph TBbegin(出门)--&gt;buy[买炸鸡]buy--&gt;isAvilable&#123;还有没有炸鸡?&#125;isAvilable--&gt;|有|happy[买完炸鸡开心]--&gt;goBack(回家)isAvilable--没有--&gt;sad[伤心]--&gt;goBack(回家) **注意：**文本中使用中文符号？会导致程序有问题，用英文。==还有没有炸鸡?== 123456graph TBbegin(出门)--&gt;buy[买炸鸡]buy--&gt;isAvilable&#123;还有没有炸鸡?&#125;isAvilable--&gt;|有|happy[买完炸鸡开心]--&gt;goBack(回家)isAvilable--请等待--&gt;happy[买完炸鸡开心]--&gt;goBack(回家)isAvilable--没有--&gt;sad[伤心]--&gt;goBack(回家) ☀1.12.1.3 连线 12345678910111213graph TB;A1--&gt;B1A2---B2A3--text---B3A4--text--&gt;B4A5-.-B5A6-.-&gt;B6A7-.text.-B7A8-.text.-&gt;B8A9===B9A10==&gt;B10A11==text===B11A12==text==&gt;B12 12345678910111213graph TB;A1--&gt;B1A2---B2A3--text---B3A4--text--&gt;B4A5-.-B5A6-.-&gt;B6A7-.text.-B7A8-.text.-&gt;B8A9===B9A10==&gt;B10A11==text===B11A12==text==&gt;B12 ☀1.12.1.4 子图表 使用一下语法添加子图表 123subgraph 子图表名称 子图表中的描述语句end ==理解为用颜色区别分装出一个模块== 1234567graph TB subgraph 买炸鸡前 goOut(出门)-.-&gt;taxi[打车到炸鸡店]==&gt;buy[买炸鸡] buy--询问--&gt;hasChicken&#123;有没有炸鸡啊&#125; end hasChicken--有--&gt;happy[买到炸鸡开心]--&gt;goBack(回家) hasChicken--&gt;|没有了|sad[没买到不开心]--&gt;goBack(回家) 1234567graph TB subgraph 买炸鸡前 goOut(出门)-.-&gt;taxi[打车到炸鸡店]==&gt;buy[买炸鸡] buy--询问--&gt;hasChicken&#123;有没有炸鸡啊&#125; end hasChicken--有--&gt;happy[买到炸鸡开心]--&gt;goBack(回家) hasChicken--&gt;|没有了|sad[没买到不开心]--&gt;goBack(回家) ☀1.12.2 时序图(sequence diagram) 123sequenceDiagram [参与者1][消息线][参与者2]:消息体 .... sequenceDiagram为每副时序图的固定开头。 1234sequenceDiagram Title:买炸鸡 小汤-&gt;&gt;炸鸡店老板:还有炸鸡吗 炸鸡店老板--&gt;&gt;小汤:没有要现炸 1234sequenceDiagram Title:买炸鸡 小汤-&gt;&gt;炸鸡店老板:还有炸鸡吗 炸鸡店老板--&gt;&gt;小汤:没有要现炸 ☀1.12.2.1 参与者(participant) 传统时序图概念中参与者有角色和类对象之分，但这里我们不做区分，用参与者表示一切参与交互的事务，可以是人、类对象、系统等形式。中间竖直的线段从上至下表示时间的流逝。 123456sequenceDiagram participant 参与者 1 partucipant 参与者 2 ... participant 简称 as 参与者3 (简称是用于代码中的) participant &lt;参与者名称&gt; 声明参与者，语句次序即为参与者横向排列次序。 ☀1.12.2.2 消息线 类型 描述 -&gt; 无箭头的实线 –&gt; 无箭头的虚线 -&gt;&gt; 有箭头的实线（主动发出消息） –&gt;&gt; 有箭头的虚线（响应） -x 末端为叉的实线（表示异步） –x 末端为叉的虚线（表示异步） 记忆: 1. -实现 --虚线 2. `&gt;`无箭头 `&gt;&gt;`有剪头 3. x为异步代替箭头 ☀1.12.2.3 处理中-激活框 从消息接收方的时间线上标记一小段时间，表示对消息进行处理的时间间隔。说明处理就在处理这个事务，无法异步处理其他请求。 在消息线末尾增加 + ，则消息接收者进入当前消息的“处理中”状态； 在消息线末尾增加 - ，则消息接收者离开当前消息的“处理中”状态。 1234567sequenceDiagram participant t as 小汤 participant s as 炸鸡店老板 t-&gt;&gt;s:还有炸鸡吗? s--&gt;&gt;t:没有了要现炸。 t-x+s:炸两个。 s--x-t:炸好了。 1234567sequenceDiagram participant t as 小汤 participant s as 炸鸡店老板 t-&gt;&gt;s:还有炸鸡吗? s--&gt;&gt;t:没有了要现炸。 t-x+s:炸两个。 s--x-t:炸好了。 ☀1.12.2.4 注解（note） 语法如下 1Note 位置表述 参与者: 标注文字 其中位置表述可以为 表述 含义 right of 右侧 left of 左侧 over 在当中，可以横跨多个参与者 12345678910sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 Note over 99,seller : 热爱炸鸡 Note left of 99 : 女 Note right of seller : 男 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -x +seller : 给我炸！ seller --&gt;&gt; -99: 您的炸鸡好了！ 12345678910sequenceDiagram participant t as 小汤 participant s as 炸鸡店老板 Note left of t:喜欢看书、魔兽。 Note right of s:炸鸡最拿手。 Note over t,s :都是男的。 t-&gt;&gt;s:还有炸鸡吗? s--&gt;&gt;t:没有了要现炸。 t-x+s:炸两个。 s--x-t:炸好了。 ☀1.12.2.5 循环（loop） 在条件满足时，重复发出消息序列。（相当于编程语言中的 while 语句。） 123456789101112sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller: 还有炸鸡吗？ seller --&gt;&gt; 99: 没有，要现炸。 99 -&gt;&gt; +seller:给我炸！ loop 三分钟一次 99 -&gt;&gt; seller : 我的炸鸡好了吗？ seller --&gt;&gt; 99 : 正在炸 end seller --&gt;&gt; -99: 您的炸鸡好了！ 1234567891011121314sequenceDiagram participant t as 小汤 participant s as 炸鸡店老板 Note left of t:喜欢看书、魔兽。 Note right of s:炸鸡最拿手。 Note over t,s :都是男的。 t-&gt;&gt;s:还有炸鸡吗? s--&gt;&gt;t:没有了要现炸。 t-x+s:炸两个。 loop 五分钟一次 t -&gt;&gt; s:我的炸鸡好了吗？ s --&gt;&gt; t:还没好。 end s--x-t:炸好了。 ☀1.12.2.6 选择（alt） 在多个条件中作出判断，每个条件将对应不同的消息序列。（相当于 if 及 else if 语句。） 123456789101112131415sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 现在就多少只炸好的炸鸡？ seller --&gt;&gt; 99 : 可卖的炸鸡数 alt 可卖的炸鸡数 &gt; 3 99 -&gt;&gt; seller : 买三只！ else 1 &lt; 可卖的炸鸡数 &lt; 3 99 -&gt;&gt; seller : 有多少买多少 else 可卖的炸鸡数 &lt; 1 99 -&gt;&gt; seller : 那我明天再来 end seller --&gt;&gt; 99 : 欢迎下次光临 ==注意：==选择语法最后也要补上end 123456789101112131415161718sequenceDiagram Title: 小汤买炸鸡 participant t as 小汤 participant s as 炸鸡店老板 Note left of t:喜欢看书、魔兽。 Note right of s:炸鸡最拿手。 Note over t,s :都是男的。 t -&gt;&gt; s:还有炸鸡吗? s --&gt;&gt; t:有的。 t -&gt;&gt; s:有多少只? s --&gt;&gt; t:可卖的炸鸡数。 alt 可卖的炸鸡数 &gt; 3 t -&gt;&gt; s:买三只 else 1 &lt; 可卖的炸鸡数 &lt; 3 t -&gt;&gt; s:全要了 else 可卖的炸鸡数 &lt; 1 t -&gt;&gt; s:明天买 end ☀1.12.2.7 可选（opt） 在某条件满足时执行消息序列，否则不执行。相当于单个分支的 if 语句。 1234567sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 买炸鸡 opt 全都卖完了 seller --&gt;&gt; 99 : 下次再来 end 1234567891011sequenceDiagram Title: 小汤买炸鸡 participant t as 小汤 participant s as 炸鸡店老板 Note left of t:喜欢看书、魔兽。 Note right of s:炸鸡最拿手。 Note over t,s :都是男的。 t -&gt;&gt; s:还有炸鸡吗。 opt 炸鸡都卖完了 s --&gt;&gt; t:没有了，下次再来。 end ☀1.12.2.8 并行（Par） 将消息序列分成多个片段，这些片段并行执行。 **==理解:==**并行就是同时一起开始执行。区别于异步，异步可能不一起开始执行。并行和异步可能都都在执行中。 12345678910111213sequenceDiagram participant 99 as 救救 participant seller as 炸鸡店小哥 99 -&gt;&gt; seller : 一个炸鸡，一杯可乐！ par 并行执行 seller -&gt;&gt; seller : 装可乐 and seller -&gt;&gt; seller : 炸炸鸡 end seller --&gt;&gt; 99 : 您的炸鸡好了！ 1234567891011121314sequenceDiagram Title: 小汤买炸鸡 participant t as 小汤 participant s as 炸鸡店老板 Note left of t:喜欢看书、魔兽。 Note right of s:炸鸡最拿手。 Note over t,s :都是男的。 t -&gt;&gt; s:来一份炸鸡。 par 并行执行 s -&gt;&gt; s:装可乐。 and s -&gt;&gt; s:炸炸鸡。 end s --&gt;&gt; t:您的炸鸡好了！ ☀1.12.3 饼图（Pie） 12345pie title Pie Chart &quot;Dogs&quot; : 386 &quot;Cats&quot; : 85 &quot;Rats&quot; : 150 12345pie title Pie Chart &quot;Dogs&quot; : 100 &quot;Cats&quot; : 200 &quot;Tortoise&quot; : 300 Typora支持mermaid的官方链接 ☀1.12.4 甘特图（gantt） 12345678910 title 标题dateFormat 日期格式section 部分名任务名:参数一, 参数二, 参数三, 参数四，参数五 //参数一：crit（是否重要，红框框） 或者 不填 //参数二：done（已完成）、active（正在进行） 或者 不填(表示为待完成状态) //参数三：取小名 或者 不填 //参数四：任务开始时间 //参数五：任务结束时间 官方教程 123456789101112131415161718192021222324252627gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 123456789101112131415161718192021222324252627gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h ☀1.13 目录 [TOC] ☀1.14 设置文档的根路径 在YAML Front Matters 中使用属性’typora-root-url’ 123---typora-root-url: im--- 文档本身是没有根路径的。一旦设定了，就可以像项目的根路径一样使用。 绝对路径个人理解为，有两种，一种是全路径的绝对路径，另一种是带根路径的绝对路径。 此根路径的设定一定要是本机地址，可以用文档的相对路径，也可以是全路径的绝对路径。 引入本地图片时写的./相对路径，/根路径的绝对路径都以此根路径为基准。 ☀1.15 设置YAML Front Matters 在文本的最上方写入 123---内容--- 快捷输入法： ---+回车 ☀1.16 嵌入html（不同平台的支持程度不同，Typroa支持！） 常用嵌入： ☀1.16.1 嵌入span字体 你可以使用HTML来设置纯Markdown不支持的内容样式。 例如：使用&lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt;添加红色文本 this text is red ☀1.16.2 嵌入iframe窗体内容 例如：bilibili中的视频iframe可以直接复制引入： ​ 直接嵌入的话，视频窗口太小，我们加入 height=&quot;500&quot;，让窗口变大一些。 ☀1.16.3 嵌入视频video标签 ​ &lt;video src=&quot;UP主战争xx1.mp4&quot; /&gt; ☀1.17 跟踪任务 ​ 语法： ​ - [x] taskname x 表示任务完成。 ​ - [ ] taskname 空格表示任务未完成 12- [x] 洗苹果- [ ] 吃苹果 [x] 洗苹果 [ ] 吃苹果 ☀1.18 换行 段落内换行，直接紧贴编辑下一行即可。 段落之间换行，直接空一行写即可。 ☀2.Typora使用 ☀2.1 设置项 偏好设置——&gt;严格模式 默认严格模式下所输入的语法一定要标准，才会识别，#+空格才是标题。 取消严格模式，#+内容就会识别出标题。 偏好设置——&gt;MarkDown扩展语法，上标、下标、高亮、图表，这些够了之后，输入的语法才会被识别生效。 偏好设置——&gt;外观——&gt;状态栏，右边统计字数，左边源代码模式和侧边栏切换按钮，此栏的开启和关闭。 偏好设置——&gt;图像 ​ 优先使用相对路径：当引入的图片与md文件在同一盘服下，md会使用相对路径引入该图片。 ​ 插入时自动转义图片URL：会将图片路径中带有中文名转义 ☀2.2 快捷键 新建文本 Ctrl+N Ctrl+Shift+N 会新建一个窗口 打开一个本地文件 Ctrl+O 快速打开最近编辑文件 Ctrl+P 弹出一个列表展示最近编辑的文件 保存 Ctrl+S 另存为 Ctrl+Shift+S 关闭 Ctrl+W 选择当前行/句 Ctrl+L 选择当前词 Ctrl+D 选择的就是当前格式包裹的内容,在选择一小段方面真的比较好用。 选择当前词和格式 Ctrl+E 选择的就是当前格式包裹的内容和当前格式 选中后，在开始坐标的基础上调整选择内容 Shift+上、下、左、右、HOME、END、PageUp、PageDown、Ctrl+HMOE、CTRL+END 上、下调整上下行的。 左、右调整当前行每个字符。 HOME、END调整到当前行的开始和结尾。 PageUp、PageDown跨页调整。 Ctrl+HMOE跨首页调整。 CTRL+END跨尾页调整。 跳转到文首 Ctrl+首页(HOME) 跳转到所选内容 Ctrl+J 跳转到文末 Ctrl+结束(END) 跳转到一行的开头 HOME 跳转到一行的结尾 END 上下翻页 PageUP、PageDown 删除当前的词 Ctrl+Shift+D 删除的就是当前格式包裹的内容。 查找 Ctrl+F 查找下一个 F3 查找上一个 shift+F3 替换 Ctrl+H 标题 Ctrl+1~6 改变标题级别或者文本字体大小 Ctrl+=、Ctrl+- 表格 Ctrl+T Ctrl+回车下方插入行 Alt+向上箭头向上移动行 Alt+向下箭头向下移动行 Alt+向左箭头向左移动列 Alt+向右箭头向右移动列 Alt+Shift+back删除行 代码块 Ctrl+Shift+K 注意：按下去的时候，Ctrl+Shift先放手。 习惯操作直接打三个```后，输入代码块的语言类型，回车即可生成，也很快速。 公式块 Ctrl+Shift+M 引用 Ctrl+Shift+Q 有序列表 Ctrl+Shift+[ 无序列表 Ctrl+SHift+] 任务列表 Alt+P选中下拉项 - [x] taskname 调整列表缩进(对于多级列表而言调整级数) Ctrl+[向外减少 Ctrl+]向里增加 加粗 Ctrl+B 斜体 Ctrl+I 下划线 Ctrl+U 代码行 `Ctrl+shift+`` 删除线 Alt+Shift+5 超链接 Ctrl+K 插入图像 Ctrl+Shift+I 清除样式 Ctrl+\\ 显示和隐藏侧边栏 Ctrl+Shift+L 标题大纲 Ctrl+Shift+1 当前文件夹的文档列表(包含一些内容) Ctrl+Shift+2 文件树(只有文件名，显示比较全的文件) Ctrl+Shift+3 查找文件 Ctrl+Shift+F 切换源代码模式 Ctrl+/ 专注模式 F8 ==除了当前格式个内容，其他都淡化。太专注了。== 打字机模式 F9 ==永远将行停留在中间，厉害了。！== 全屏 F11 放大显示比例 Ctrl+Shift+= 缩小显示比例 Ctrl+Shift+- 恢复原显示比例 Ctrl+Shift+9 多个Typroa窗口切换 Ctrl+Tab 开发者工具(查看Html源代码) Shift+F12 换行 段落中换行 shift+回车 段落外换行 回车 代码块自动缩进 Shift+Tab ☀2.3 小技巧 在对应的格式上重新输入格式快捷键，可以取消该格式。 图片保存到本地 按住Ctrl+V 就可以弹出复制文件到本地的选项。 或者设置插入图片时的操作。复制到安排好的文件夹中，进行统一管理。 表格中换行shift+回车，表格中从当前单元格跳到下一列对应的格回车","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://aner1001.gitee.io/tags/MarkDown/"},{"name":"Typroa","slug":"Typroa","permalink":"http://aner1001.gitee.io/tags/Typroa/"}]},{"title":"Web前端零散知识点整理","slug":"技术知识/Web/Web前端零散知识点整理","date":"2021-04-13T08:57:35.000Z","updated":"2021-04-13T08:57:35.000Z","comments":true,"path":"posts/2021/04/13/be312aef64b7/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/04/13/be312aef64b7/","excerpt":"各类与Web前端相关的零散知识点整理。滴水成湖，多了之后，归类整理成文章。","text":"各类与Web前端相关的零散知识点整理。滴水成湖，多了之后，归类整理成文章。 ☀1.html资源地址 src=&quot;// 开头 如果浏览器当前使用的是https协议，那么就加载https协议的脚本，否则使用http，这保证了页面所有资源使用同一协议。 其实是有人将其做为规范来实践的。另外包括图片地址，CSS中的background地址都可以省略协议名。在script标签上使用没有兼容性问题，但在link上或者@import上这样写IE下会有问题。更多请参考：http://www.paulirish.com/2010/the-protocol-relative-url/ ☀2.ajax的jquery语法$.post() 和 $.get() 如何同步请求。 由于$.post() 和 $.get() 默认是 异步请求，如果需要同步请求，则可以进行如下使用： 在$.post()前把ajax设置为同步：$.ajaxSettings.async = false; 在$.post()后把ajax改回为异步：$.ajaxSettings.async = true; 如： 12345$.ajaxSettings.async = false;$.post(&quot;/finance/getLastTimeCard&quot;, data, function(result) &#123;// 请求处理&#125;,&quot;json&quot;);$.ajaxSettings.async = true;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Web","slug":"技术知识/Web","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Web/"}],"tags":[{"name":"Html","slug":"Html","permalink":"http://aner1001.gitee.io/tags/Html/"},{"name":"Ajax","slug":"Ajax","permalink":"http://aner1001.gitee.io/tags/Ajax/"}]},{"title":"Java SPI机制","slug":"技术知识/Java/基础/Java-SPI机制","date":"2021-04-02T02:40:55.000Z","updated":"2021-04-02T02:40:55.000Z","comments":true,"path":"posts/2021/04/02/324abd964bf7/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/04/02/324abd964bf7/","excerpt":"SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。","text":"SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。我们经常遇到的就是java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，mysql和postgresql都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。 ☀1、什么是SPI？ 如上图所示，接口对应的抽象SPI接口；实现方实现SPI接口；调用方依赖SPI接口。 SPI接口的定义在调用方，在概念上更依赖调用方；组织上位于调用方所在的包中，实现位于独立的包中。 当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务实现的工具类是：java.util.ServiceLoader。 ☀2、SPI的用途 数据库DriverManager、Spring、ConfigurableBeanFactory等都用到了SPI机制，这里以数据库DriverManager为例，看一下其实现的内幕。 DriverManager是jdbc里管理和注册不同数据库driver的工具类。针对一个数据库，可能会存在着不同的数据库驱动实现。我们在使用特定的驱动实现时，不希望修改现有的代码，而希望通过一个简单的配置就可以达到效果。 在使用mysql驱动的时候，会有一个疑问，DriverManager是怎么获得某确定驱动类的？我们在运用Class.forName(&quot;com.mysql.jdbc.Driver&quot;)加载mysql驱动后，就会执行其中的静态代码把driver注册到DriverManager中，以便后续的使用。 ☀Driver实现 1234567891011121314151617package com.mysql.jdbc;import java.sql.DriverManager;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;); &#125; &#125;&#125; 驱动的类的静态代码块中，调用DriverManager的注册驱动方法new一个自己当参数传给驱动管理器。 ☀Mysql DriverManager实现 12345678/** * Load the initial JDBC drivers by checking the System property * jdbc.properties and then use the &#123;@code ServiceLoader&#125; mechanism */static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;);&#125; 可以看到其内部的静态代码块中有一个loadInitialDrivers方法，loadInitialDrivers用法用到了上文提到的spi工具类ServiceLoader: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private static void loadInitialDrivers() &#123; String drivers; try &#123; drivers = AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; return System.getProperty(&quot;jdbc.drivers&quot;); &#125; &#125;); &#125; catch (Exception ex) &#123; drivers = null; &#125; // If the driver is packaged as a Service Provider, load it. // Get all the drivers through the classloader // exposed as a java.sql.Driver.class service. // ServiceLoader.load() replaces the sun.misc.Providers() AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); /* Load these drivers, so that they can be instantiated. * It may be the case that the driver class may not be there * i.e. there may be a packaged driver with the service class * as implementation of java.sql.Driver but the actual class * may be missing. In that case a java.util.ServiceConfigurationError * will be thrown at runtime by the VM trying to locate * and load the service. * * Adding a try catch block to catch those runtime errors * if driver not available in classpath but it&#x27;s * packaged as service and that service is there in classpath. */ try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; &#125; catch(Throwable t) &#123; // Do nothing &#125; return null; &#125; &#125;); println(&quot;DriverManager.initialize: jdbc.drivers = &quot; + drivers); if (drivers == null || drivers.equals(&quot;&quot;)) &#123; return; &#125; String[] driversList = drivers.split(&quot;:&quot;); println(&quot;number of Drivers:&quot; + driversList.length); for (String aDriver : driversList) &#123; try &#123; println(&quot;DriverManager.Initialize: loading &quot; + aDriver); Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); &#125; catch (Exception ex) &#123; println(&quot;DriverManager.Initialize: load failed: &quot; + ex); &#125; &#125; 先查找jdbc.drivers属性的值，然后通过SPI机制查找驱动 12345public final class ServiceLoader&lt;S&gt; implements Iterable&lt;S&gt;&#123; private static final String PREFIX = &quot;META-INF/services/&quot;; 123456789101112131415161718192021222324private boolean hasNextService() &#123; if (nextName != null) &#123; return true; &#125; if (configs == null) &#123; try &#123; String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); &#125; catch (IOException x) &#123; fail(service, &quot;Error locating configuration files&quot;, x); &#125; &#125; while ((pending == null) || !pending.hasNext()) &#123; if (!configs.hasMoreElements()) &#123; return false; &#125; pending = parse(service, configs.nextElement()); &#125; nextName = pending.next(); return true; &#125; 可以看到加载META-INF/services/ 文件夹下类名为文件名（这里相当于Driver.class.getName()）的资源，然后将其加载到虚拟机。 注释有这么一句“Load these drivers, so that they can be instantiated.” 意思是加载SPI扫描到的驱动来触发他们的初始化。即触发他们的static代码块 123456789101112131415161718192021222324252627282930/** * Registers the given driver with the &#123;@code DriverManager&#125;. * A newly-loaded driver class should call * the method &#123;@code registerDriver&#125; to make itself * known to the &#123;@code DriverManager&#125;. If the driver is currently * registered, no action is taken. * * @param driver the new JDBC Driver that is to be registered with the * &#123;@code DriverManager&#125; * @param da the &#123;@code DriverAction&#125; implementation to be used when * &#123;@code DriverManager#deregisterDriver&#125; is called * @exception SQLException if a database access error occurs * @exception NullPointerException if &#123;@code driver&#125; is null * @since 1.8 */ public static synchronized void registerDriver(java.sql.Driver driver, DriverAction da) throws SQLException &#123; /* Register the driver if it has not already been added to our list */ if(driver != null) &#123; registeredDrivers.addIfAbsent(new DriverInfo(driver, da)); &#125; else &#123; // This is for compatibility with the original DriverManager throw new NullPointerException(); &#125; println(&quot;registerDriver: &quot; + driver); &#125; 将自己注册到驱动管理器的驱动列表中 123456public class DriverManager &#123; // List of registered JDBC drivers private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;(); 当获取连接的时候调用驱动管理器的连接方法从列表中获取。 1234567891011121314@CallerSensitive public static Connection getConnection(String url, String user, String password) throws SQLException &#123; java.util.Properties info = new java.util.Properties(); if (user != null) &#123; info.put(&quot;user&quot;, user); &#125; if (password != null) &#123; info.put(&quot;password&quot;, password); &#125; return (getConnection(url, info, Reflection.getCallerClass())); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static Connection getConnection( String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException &#123; /* * When callerCl is null, we should check the application&#x27;s * (which is invoking this class indirectly) * classloader, so that the JDBC driver class outside rt.jar * can be loaded from here. */ ClassLoader callerCL = caller != null ? caller.getClassLoader() : null; synchronized(DriverManager.class) &#123; // synchronize loading of the correct classloader. if (callerCL == null) &#123; callerCL = Thread.currentThread().getContextClassLoader(); &#125; &#125; if(url == null) &#123; throw new SQLException(&quot;The url cannot be null&quot;, &quot;08001&quot;); &#125; println(&quot;DriverManager.getConnection(\\&quot;&quot; + url + &quot;\\&quot;)&quot;); // Walk through the loaded registeredDrivers attempting to make a connection. // Remember the first exception that gets raised so we can reraise it. SQLException reason = null; for(DriverInfo aDriver : registeredDrivers) &#123; // If the caller does not have permission to load the driver then // skip it. if(isDriverAllowed(aDriver.driver, callerCL)) &#123; try &#123; println(&quot; trying &quot; + aDriver.driver.getClass().getName()); Connection con = aDriver.driver.connect(url, info); if (con != null) &#123; // Success! println(&quot;getConnection returning &quot; + aDriver.driver.getClass().getName()); return (con); &#125; &#125; catch (SQLException ex) &#123; if (reason == null) &#123; reason = ex; &#125; &#125; &#125; else &#123; println(&quot; skipping: &quot; + aDriver.getClass().getName()); &#125; &#125; // if we got here nobody could connect. if (reason != null) &#123; println(&quot;getConnection failed: &quot; + reason); throw reason; &#125; println(&quot;getConnection: no suitable driver found for &quot;+ url); throw new SQLException(&quot;No suitable driver found for &quot;+ url, &quot;08001&quot;); &#125; 12345678910111213141516private static boolean isDriverAllowed(Driver driver, ClassLoader classLoader) &#123; boolean result = false; if(driver != null) &#123; Class&lt;?&gt; aClass = null; try &#123; aClass = Class.forName(driver.getClass().getName(), true, classLoader); &#125; catch (Exception ex) &#123; result = false; &#125; result = ( aClass == driver.getClass() ) ? true : false; &#125; return result; &#125;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"SPI","slug":"SPI","permalink":"http://aner1001.gitee.io/tags/SPI/"}]},{"title":"飞机场","slug":"技术知识/工具/飞机场","date":"2021-03-26T06:45:52.000Z","updated":"2021-03-26T06:45:52.000Z","comments":true,"path":"posts/2021/03/26/b74f0c188680/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/26/b74f0c188680/","excerpt":"飞机场起飞，翻墙经验。","text":"飞机场起飞，翻墙经验。 ☀访问Github 飞机场网站： https://www.ipaddress.com/ 每台主机ip不同查询自己的节点： 查询 github.global.ssl.fastly.net https://fastly.net.ipaddress.com/github.global.ssl.fastly.net 查询github.com https://github.com.ipaddress.com/ 设置主机的host文件，使用1，2的查询结果。 12140.82.114.3 github.com 199.232.69.194 github.global.ssl.fastly.net","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"LRU,LFU,FIFO","slug":"技术知识/算法/LRU-LFU-FIFO","date":"2021-03-18T02:25:55.000Z","updated":"2021-03-18T02:25:55.000Z","comments":true,"path":"posts/2021/03/18/257a48eebf6e/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/18/257a48eebf6e/","excerpt":"介绍与理解LRU、LFU、FIFO算法，用于缓存回收等机制。","text":"介绍与理解LRU、LFU、FIFO算法，用于缓存回收等机制。 ☀LRU 这个缓存算法将最近使用的条目存放到靠近缓存顶部的位置。当一个新条目被访问时，LRU将它放置到缓存的顶部。当缓存达到极限时，较早之前访问的条目将从缓存底部开始被移除。这里会使用到昂贵的算法，而且它需要记录“年龄位”来精确显示条目是何时被访问的。此外，当一个LRU缓存算法删除某个条目后，“年龄位”将随其他条目发生改变。 ☀LFU 这个缓存算法使用一个计数器来记录条目被访问的频率。通过使用LFU缓存算法，最低访问数的条目首先被移除。这个方法并不经常使用，因为它无法对一个拥有最初高访问率之后长时间没有被访问的条目缓存负责。 ☀FIFO FIFO是英文First In First Out 的缩写，是一种先进先出的数据缓存器，他与普通存储器的区别是没有外部读写地址线，这样使用起来非常简单，但缺点就是只能顺序写入数据，顺序的读出数据，其数据地址由内部读写指针自动加1完成，不能像普通存储器那样可以由地址线决定读取或写入某个指定的地址。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"算法","slug":"技术知识/算法","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://aner1001.gitee.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"HaspMap和HashTable区别","slug":"技术知识/Java/基础/HaspMap和HashTable区别","date":"2021-03-16T22:28:32.000Z","updated":"2021-03-16T22:28:32.000Z","comments":true,"path":"posts/2021/03/16/eddba7ef8af9/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/16/eddba7ef8af9/","excerpt":"","text":"☀1.同步性 HashTable是同步的,线程安全的。 里面所有的方法，isEmpty(),isSize(),contains()，get()方法都加了synchronized关键字进项同步。所以效率很低。 HashMap是线程不安全的。所以效率高。 综合效率和安全，所以我们通常亏考虑oncurrentHashMap，不会把整个方法全部锁住，会采用分段锁的方式。进项数据的锁定。 ☀2.继承的父类不同。 回答面试官的时候，可以说看过，知道他们继承了不同的父类，是什么父类忘了。 HashTable继承了Distionary. HashMap继承了AbstractMap. ☀3.对于Null Key和Null Value的支持不同 针对put方法而言的。 HashTable，的value会有非空判断。key如果是空也会报空指针。 HashMap允许为空，判断key为null的时候，就将hash值之设为0。不为null就计算实际的hash。 ☀4.遍历方法不同： Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 HashTable 迭代器都是先判断有没有下一个。取出下一个。 ☀5. 内部实现使用的数组初始化和扩容方式不同 ☀内部初始化： HashTable默认初始化使用11.在调用构造方法的时候就初始化了数组。 HashMap构造方法不会进行初始化。初始化值为16。 第一次调用put的时候，才会开辟出数组，进行存储。 重新扩充的方法里 进行初始化构建数组。 ☀扩容： HashMap 扩容是原来的两倍。HashMap处处体现考虑了效率，使用位运算比x2快。2是整数，需要转换为二进制才能运算，转换的过程耗费资源。 HashTable 2倍+1. ☀6.计算hash值和下标的方法不同 HashMap 如果key是null则哈希值为0，如果不为0，是字符串的hash方法，是对象是对象本身的hash方法，计算出一个值，高16位向低16位右移，右移16位，高位和爹日同时参数与异或运算，计算出一个新的hash值。为什么右移16位，是int值，int是32位，使得高位参与运算，避免某些hash值计算结果频繁出现在高位。使得分布均匀。 下标的计算： 容量减一参与下标计算。与当前的hash进行与运算。 所以HashMap容量必须保证是2的次幂。 初始化构造方法的时候使用tableSizeFor。 初始化容量可以填任意一个参数。都能够算出离得最近的2的次幂。 HashTable 下标的计算： 将hash的符号位舍去(hash &amp; 0x7FFFFFFF)，取余数.其实int就是32位最大容量-1。 HashTable和HashMap理念上就是保留部分hash值的方法。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"HashTable","slug":"HashTable","permalink":"http://aner1001.gitee.io/tags/HashTable/"}]},{"title":"家庭电路基础知识","slug":"生活知识/经验感悟/家庭电路基础知识","date":"2021-03-10T22:29:51.000Z","updated":"2021-03-10T22:29:51.000Z","comments":true,"path":"posts/2021/03/10/e867f40dc642/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/10/e867f40dc642/","excerpt":"","text":"☀基本常识 ☀电压，电流，电阻。 电压，也称作电势差或电位差，是衡量单位电荷在静电场中由于电势不同所产生的能量差的物理量。此概念与水位高低所造成的“水压”相似。需要指出的是，“电压”一词一般只用于电路当中，“电势差”和“电位差”则普遍应用于一切电现象当中。 电流，是指电荷的定向移动。电源的电动势形成了电压，继而产生了电场力，在电场力的作用下，处于电场内的电荷发生定向移动，形成了电流。电流的大小称为电流强度（简称电流，符号为I），是指单位时间内通过导线某一截面的电荷量，每秒通过1库仑的电量称为1「安培」（A）。安培是国际单位制中所有电性的基本单位。 除了A，常用的单位有毫安（mA）、微安(μA)。 电阻，物质对电流的阻碍作用就叫该物质的电阻。电阻小的物质称为电导体，简称导体。电阻大的物质称为电绝缘体，简称绝缘体。 ☀电路的三种状态 电路的三种状态:通路、短路和断路 由电子原件组成的,用来完成某种特定功能的线路,叫电路。通常情况下,电路有三种状态,即 通路：特指某一种电流信号，流经的路径，处处接通的电路。 断路：又叫开路，是某处断开的电路，电流信号本应该汨着设计好的固有的通路来传播,但是由于故障，(中间某 个电子元件坏了，或者电线断了)造成的电流信号的阻断。 短路：电源的正负极直接相碰了，将导线直接连接到电源两端的电路。 ☀串联和并联 串联电路的特点： 1、所有串联元件中的电流是同一个电流。 2、元件串联后的总电压是所有元件的端电压之和。 并联电路的特点： 1、所有并联元件的端电压是同一个电压。 2、并联电路的总电流是所有元件的电流之和。 ❀家装电路一般是并联。 家里电器都是使用220V电压，只能并联安装才能正常工作。如果串联后，电器分压，每个电器都达不到额定电压，就不能正常工作了，故采用并联。并联，某个电器烧坏不会影响其他电器的使用。 [ ☀漏电 正常情况 I1 - I2=0. —》 I1=I2 如果是漏电 I1 - I2&gt;0. —》 I1&gt;I2 造成漏电的原因，个人理解是不走零线的并联。就是火线+其他0伏特的材质(墙壁、地板等)。 比如说人体接触了电（火线+地板），会造成漏电。从而触发漏电保护器。断闸。 地线保护，也是通过并联原理。人提触电时，地线和人体并联，并联分流原理，地线比人体电阻小250倍，使得走地线的电流比人体大250倍，总电流过大，直接跳闸，保护人体。 原理总结： 漏电保护器时计算出和入的电流差，跳闸保护。 地线是漏电，触时使得火线接地短路，导致电流过大，跳闸保护。 最保险的就是漏电保护器+地线保护双重保护。 ☀家用操作注意： 下图为带电未断闸时候，能够允许的安全操作。家用操作大闸断开后，也需要按此规范，防范于未然更加安全。 ☀绝对不能的操作： 同时操作火线和零线。 操作火线，不带绝缘体。 一个人两只手都抓着火线，如果此时人体的其它部位不和地接触，人不会触电。照明电路里的两根电线，一根叫火线，另一根则叫零线。火线和零线的区别在于它们对地的电压不同：火线对地电压为220V；零线的对地的电压等于零（它本身跟大地相连接在一起的）。 所以当人的一部分碰上了火线，另一部分站在地上，人的这两个部分之间的电压等于220V，就有触电的危险了。反之人即使用手去抓零线，如果人是站在地上的话，由于零线的对地的电压等于零，所以人的身体各部分之间的电压等于零，人就没有触电的危险。 ☀相对安全的操作： 1.这种情况保证零线不断路的情况下才能操作。也就是测电笔测零线不亮的时候操作零线。 2.带着绝缘凳一起操作，绝缘等相当于无限大的电阻，按照串联原理计算电流，电流基本不能通过，此时电源不能形成闭合回路。 ☀家庭电路解析 家用电是指我们常说的220伏电，也叫单相电，有两根线,一根火线一根零线，火线经过负载，如灯泡等用电器后经零线形成回路，用电器才能正常工作，零线在发电厂也是接地的。 大致结构： ☀农村用电 农村TN-C接零保护系统 三火+1零。零线与地线合并为一条零线。 农村做地线需要很专业技术，地线做的不好危险会害人，安全隐患更多，做得好保护。农村技术不满足。不需要地线，安装漏电保护开关就可以满足了。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"家具","slug":"家具","permalink":"http://aner1001.gitee.io/tags/%E5%AE%B6%E5%85%B7/"}]},{"title":"Linux学习笔记2-CentOS安装文档","slug":"技术知识/计算机/Linux/Linux学习笔记2-CentOS安装文档","date":"2021-03-05T02:27:02.000Z","updated":"2021-03-05T02:27:02.000Z","comments":true,"path":"posts/2021/03/05/1c9a43ac0b33/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/05/1c9a43ac0b33/","excerpt":"","text":"☀使用VMware安装CentOS 6.4 环境：Windows7 , VMware Workstation10, CentOS6.4 为什么选择CentOS ? 主流： 目前的Linux操作系统主要应用于生产环境，主流企业级Linux系统仍旧是RedHat或者CentOS 免费： RedHat 和CentOS差别不大，CentOS是一个基于Red Hat Linux 提供的可自由使用源代码的企业级Linux发行版本 更新方便：CentOS独有的yum命令支持在线升级，可以即时更新系统，不像RED HAT那样需要花钱购买支持服务！ ☀镜像下载地址 官网下载链接：http://isoredirect.centos.org/centos/7/isos/x86_64/ 阿里云站点：http://mirrors.aliyun.com/centos/7/isos/x86_64/ ☀安装步骤 第1步：首先安装VMware Workstation，只需点下一步即可，安装过程略。 第2步：文件 → 新建虚拟机 或 直接点击 创建新的虚拟机 第3步：选择 典型（推荐）→ 下一步 第4步：稍后安装操作系统 第5步：选择操作系统和版本 第6步：输入虚拟机名称和安装路径 第7步：设置磁盘大小 第8步：自定义硬件 第9步：选择CentOS安装镜像文件 第10步：点击完成 第11步：启动虚拟机 第12步：选择第一项，安装全新操作系统或升级现有操作系统 第13步：Tab键进行选择，选择Skip，退出检测 第14步：点击Next 第15步：选择语言，这里选择的是中文简体 第16步：选择键盘样式 第17步：选择存储设备 如果以前安装过虚拟机，会出现这个警告，选择是，忽略所有数据 第18步：输入主机名 第19步：配置网络 第20步：设置时区，勾选使用UTC时间 第21步：输入根用户（root）的密码 如果密码过于简单会出现提示，点击无论如何都使用 第22步：根据此Linux具体功能，选择不同的方式 Centos7选择： 第23步：选择现在自定义，自定义安装需要的软件，如桌面配置 可以根据具体的情况来配置，如可安Eclipse 还可以安装Java平台、Perl支持等 选择语言支持 第24步：点击下一步，开始安装 第25步：安装完成后，点击重新导引 第26步：点击前进按钮 第27步：点击是，同意许可，再点击前进按钮 第28步：创建用户 第29步：设置日期和时间，如果可以上网，勾选在网上同步日期和时间 最后点击前进，完成安装！ ☀工具安装 如果使用yum install xxxx，会找到安装包之后，询问你Is this OK[y/d/N]，需要你手动进行选择。但是如果加上参数-y，就会自动选择y，不需要你再手动选择！ 12345yum -y install 包名（支持*） ：自动选择y，全自动yum install 包名（支持*） ：手动选择y or nyum remove 包名（不支持*）rpm -ivh 包名（支持*）：安装rpm包rpm -e 包名（不支持*）：卸载rpm包 ☀ifconfig 1）通过ping一下百度了解网卡是否启用 能ping通的话，说明网卡有启用，并能获取IP地址来上网。（如果不能可以通过vi /etc/sysconfig/network-scripts/ifcfg-enp0s3 ，把ONBOOT改为yes。BOOTPROTO改为dhcp，或者改为手动获取IP地址，详见在centos7网络配置） 注：修改完后需要重启网卡（命令：service network restart） 2）通过输入ip addr 查看是否能获取IP地址来确定网卡是否启用 能通ip addr 查到获取的IP地址，证明网卡是启用。如果获取不了请修改网络配置文件。注：修改完后需要重启网卡（命令：service network restart） 3）通过cat /etc/sysconfig/network-scripts/ifcfg-enp0s3 (ifcfg-enp0s3是网卡名，不同的机器是不一样的。)下的NBOOT是否开启（意思就是网卡是否开启）。 通过cat /etc/sysconfig/network-scripts/ifcfg-enp0s3 查看网卡是否启用，如果没有使用vi /etc/sysconfig/network-scripts/ifcfg-enp0s3 修改网络配置文件。 使用yum provides ifconfig 来查看那个包提供ifconfig，并安装一下。 然后执行 yum install net-tools 然后输入：ifconfig 命令测试一下 在这可以显示出net-tools包的版本，并能查看到IP地址相关的信息。 ☀vim 1yum install vim ☀wget 1yum -y install wget ☀iptables contos6版本默认安装iptables 1yum install iptables-services 查看防火墙状态： 1service iptables status 启动防火墙 1service iptables start 停止： 1service iptables stop 永远停用: 1chkconfig iptables off; #永远停用d 停用后开启: 1chkconfig iptables on 添加开放端口记录 #vim /etc/sysconfig/iptables 在 -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT 后面添加以下内容 1234-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 6379 -j ACCEPT 重启防火墙 12chkconfig iptables onservice iptables restart ☀firewalld ☀安装 在Centos7中默认已经安装了firewalld，如果需要自行安装，可以直接使用yum安装 1yum install firewalld 如果需要使用图形化配置工具还需要安装firewall-config 1yum install firewall-config 这样firewalld就安装完成了，不过要注意firewalld跟iptables不能同时使用，所以在使用firewalld之前首先需要将iptables停用。 ☀维护命令 firewalld的维护相对来说是非常简单的，其命令主要分为三大类：启动停止和查询状态、设置开机自动启动以及更新规则。 ☀启动停止和查询状态 在Centos7中默认将原来的服务管理工具service升级为了systemctl，其实原来的service只是一个脚本执行工具，而systemctl的功能非常强大，关于systemctl的详细用法大家可以阅读linux中国的一篇文章，地址是：https://linux.cn/article-5926-1.html，这篇文章写的非常详细，所以学生就不再给大家做补充了，下面来说一说怎么用它来操作firewalld。 启动 1systemctl start firewalld 停止 1systemctl stop firewalld 重启 1systemctl restart firewalld 查询状态 1systemctl status firewalld 另外，对于firewalld来说还可以使用自身的firewall-cmd工具来查询运行状态 1firewall-cmd --state ☀设置开机自动启动 设置开机自动启动也是使用systemctl来操作的，命令如下 启用开机自动启动 1systemctl enable firewalld 禁用开机自动启动 1systemctl disable firewalld 查看自动启动状态 1systemctl is-enabled firewalld 当然，systemctl的这些命令不只适用于firewalld，也适用于其他服务，使用时只要将firewalld换成相应服务的名称就可以了。 gcc-c++ 1yum -y install gcc-c++ ☀git 1yum -y install git ☀常用操作 ☀Linux虚拟机配置固定IP 参考帖子：https://www.cnblogs.com/lfhappy/p/10798400.html 达到的如下效果： 1、笔记本主机IP为设置自动获取，不管什么情况下，不受虚拟机影响，只要连接外网就可以正常上网； 2、只要笔记本主机可以正常访问外网，启动虚拟机中的CentOS 7系统就可以正常访问外网，无需再进行任何设置； 3、虚拟机设置为固定IP，不管主机在什么网络环境下，是断网环境，还是连接任何网段访问外网的环境下，虚拟机的IP都固定不变，而且使用终端连接，始终不变，正常连接； 4、虚拟机的固定IP可以按照自己想设置的IP地址网段随意设置，比如我就想设置固定IP为192.168.2.2。 以上4点，网上我没有找到一个帖子可以达到我要求的效果，经过我这段时间研究，经过各种尝试，期间出现各种问题，测试稳定后，总结如下分享给大家，希望对大家有所帮助，少走弯路。 采用方式为NAT模式+固定IP的模式。 配置环境说明：主机为Win10家庭版，虚拟机为VMware Workstation 12 Pro中文版，虚拟机中的Linux系统为CentOS 7 64位。 (✿◡‿◡)1.设置虚拟机的网络连接方式： 按照如下图设置，英文版的对照设置即可 (✿◡‿◡)2.配置虚拟机的NAT模式具体地址参数： （1）编辑–虚拟网络编辑器–更改设置（部分系统可能没有图中第2步） （2）选择VMnet8–取消勾选使用本地DHCP–设置子网IP–网关IP设置（记住此处设置，后面要用到），如下图 说明：修改子网IP设置，实现自由设置固定IP，若你想设置固定IP为192.168.2.2-255，比如192.168.2.2，则子网IP为192.168.2.0；建议不要用： 192.168.1.2-255，亲测1网段无法成功； （3）网关IP可以参照如下格式修改：192.168.2.1 (✿◡‿◡)3.配置笔记本主机具体VMnet8本地地址参数： 说明：第6步中的IP地址随意设置，但是要保证不能跟你要设置虚拟机的固定IP一样。 (✿◡‿◡)4.修改虚拟机中的CentOS 7系统为固定IP的配置文件： （1）进入centos7命令行界面，修改如下内容： 123#cd /etc/sysconfig/network-scripts/#ls#vi ifcfg-eno16777736 说明： 1234567#将IPV6…..协议都注释；BOOTPROTO=static #开机协议，有dhcp及static；ONBOOT=yes #设置为开机启动；DNS1=114.114.114.114 #这个是国内的DNS地址，是固定的；IPADDR=192.168.2.2 #你想要设置的固定IP，理论上192.168.2.2-255之间都可以，请自行验证；NETMASK=255.255.255.0 #子网掩码，不需要修改；GATEWAY=192.168.2.1 #网关，这里是你在“2.配置虚拟机的NAT模式具体地址参数”中的（2）选择VMnet8--取消勾选使用本地DHCP--设置子网IP--网关IP设置。 （2）重启网络服务 1service network restart (✿◡‿◡)5.检验配置是否成功 （1）查看修改后的固定IP为192.168.2.2，配置正确； 1ifconfig（不支持ifconfig命令，则使用ip addr） （2）测试虚拟机中的CentOS 7系统是否能连外网，有数据返回，说明可以连接外网； 1ping www.baidu.com （3）测试本机是否能ping通虚拟机的固定IP，有数据返回，说明可以使用终端工具正常连接； 鼠标放到开始菜单右键，选择命令提示符（管理员），打开命令操作界面： 1ping 192.168.2.2 (✿◡‿◡)6.远程终端连接 （1）遇到问题，若连接失败是因为CentOS 7的防火墙端口没有打开，比如开启80，3306端口，最后一定要重启防火墙； 12345678#查看防火墙状态systemctl status firewalld #开启80端口firewall-cmd --zone=public --add-port=80/tcp --permanent #开启3306端口firewall-cmd --zone=public --add-port=3306/tcp --permanent #重启防火墙：firewall-cmd --reload （2）连接成功 以上要求的效果全部达到，且完全可以将虚拟机中的CentOS 7做为服务器，在上面部署各种服务啦！！！ ☀安装源替换 ☀配置EPEL源 EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux. 参考链接：https://www.cnblogs.com/xiaochina/p/5912031.html 执行命令： 1234yum install -y epel-releasewget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repoyum clean allyum makecache ☀问题记录 ☀文件中文名乱码问题： 原因在于，Windows 的文件名中文编码默认为GBK，压缩或者上传后，文件名还会是GBK编码，而Linux中默认文件名编码为UTF8，由于编码不一致所以导致了文件名乱码的问题。 解决方案： 这个问题需要对文件名进行转码。 CentOS7下中文文件名显示乱码 centos7 文件名中文乱码_linux中文文件名乱码解决 直接安装中文版的Centos系统。 使用locale命令检查。中文版为：zh_CN.UTF-8 英文版为：en_US.UTF-8","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://aner1001.gitee.io/tags/Linux/"}]},{"title":"家具选购经验","slug":"生活知识/经验感悟/家具选购经验","date":"2021-03-05T00:15:28.000Z","updated":"2021-03-05T00:15:28.000Z","comments":true,"path":"posts/2021/03/05/bc95e0b1ed74/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/05/bc95e0b1ed74/","excerpt":"","text":"超过3000块的沙发不要去宜家买，都是喜乐门代工的。 北欧表情 宫御家具 北欧家居 样子生活 Mini More 吱音 涵客家居 北欧印象 青木堂 格度 沙发不是越贵越好.看坐感和坐姿.贵的软,便宜的硬. 沙发坐包越厚,堆料越丰富,坐感就越舒服. 圆弧形沙发好看,偏硬,高靠背舒服,但又不好看,最舒服的沙发基本造型,方正敦厚. 评价再好的沙发,价格五千以上一定要去线下买.舒不舒服体验后才知道. 硬的4000以上的沙发,可以考虑线上买. 看底部做工,做工干净才是好沙发. 千元以下的多是金属框架加上两个大软包. 木头是松木\\橡胶木等廉价木材.还有多层板,环保比较难保证. 23千的布艺沙发,就是和普通家庭.座包下面有绷带和弹簧,海绵层更厚,弹性支撑也够, 真皮沙发56千往上就能买到比较好的了. 单人沙发和躺椅如果是小户型就买.物美价廉占地小,调整灵活还舒服. 大几万的沙发,舒适性上不一定能比得过一两千的单人躺椅,买沙发和床垫一样,越贵的沙发,用料越多越软,座包和座椅就强调一个包裹感. 普通千元左右的沙发,就是一个木头或者金属的框架,加两个海绵做的大枕头,一个座包,一个靠包,如果你比较喜欢硬一点的坐感,或者是用来待客的做的比较端正,这个价位差不多了.再贵就是挑好一点的面料,或者做工再精细一些.而且这种沙发的造型反而更好看. 两三千的沙发,开始会在底层加上绷带和弹簧.坐上去更有弹性,海绵的密度也会更高.做起来支撑性什么的也会更好. 56千网上.就能买到比较好的真皮沙发了. 包裹感好的沙发,造型越容易显得臃肿.笨重. 舒服又好看的款式一定是方方正正的.坐进去有特别蓬松.但是腰部的支撑不可避免要用到靠枕.圆弧形的,靠背式圆弧形的,其实都很硬. 颈椎不好的人,一个高靠背的扶手椅,反而会比几万元的沙发更适合. 家里不一定要用大沙发,家里人一人一张单人沙发,再准备几把椅子给客人舒服又有格调. 所以挑沙发,造型是其次,做重要的是看要什么样的坐感,没必要非得买最贵的.","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"家具","slug":"家具","permalink":"http://aner1001.gitee.io/tags/%E5%AE%B6%E5%85%B7/"}]},{"title":"Linux学习笔记","slug":"技术知识/计算机/Linux/Linux学习笔记","date":"2021-03-04T13:33:33.000Z","updated":"2021-03-04T13:33:33.000Z","comments":true,"path":"posts/2021/03/04/3d827be8af75/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/04/3d827be8af75/","excerpt":"","text":"☀Linux的概述： ☀学习Linux之前先了解Unix Unix是一个强大的多用户、多任务操作系统。于1969年在AT&amp;T的贝尔实验室开发。UNIX的商标权由国际开放标准组织（The Open Group）所拥有。UNIX操作系统是商业版，需要收费，价格比Microsoft Windows正版要贵一些。 ☀Linux的概述： Linux是基于Unix的 Linux是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、台式计算机 诞生于1991 年10 月5 日。是由芬兰赫尔辛基大学学生Linus Torvalds和后来加入的众多爱好者共同开发完成 ☀Linux的历史： Linux最初是由芬兰赫尔辛基大学学生Linus Torvalds由于自己不满意教学中使用的MINIX操作系统， 所以在1990年底由于个人爱好设计出了LINUX系统核心。后来发布于芬兰最大的ftp服务器上，用户可以免费下载，所以它的周边的程序越来越多，Linux本身也逐渐发展壮大起来，之后Linux在不到三年的时间里成为了一个功能完善，稳定可靠的操作系统. ☀Linux系统的应用： 服务器系统Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等； 嵌入式系统路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等， 高性能运算、计算密集型应用Linux有强大的运算能力。 桌面应用系统 移动手持系统 ☀Linux的版本 **Linux的版本分为两种：内核版本和发行版本；**内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号 ； ☀Linux的主流版本 ☀Linux的安装： ☀虚拟机安装： ☀什么是虚拟机 虚拟机：一台虚拟的电脑. 虚拟机软件: VmWare :收费的. VirtualBox :免费的. ☀安装VmWare 打开虚拟机软件，选择好盘符，傻瓜式下一步安装就可以。 ☀CentOS的安装 参考Linux学习笔记-CentOS6安装 ☀Linux的远程访问 ☀安装一个远程访问的软件:CRT ☀连接Linux: 需要录入linux的ip地址及用户名密码. 查看ip地址ifconfig. ☀设置背景颜色,Linux风格。 打开Options-&gt;Session Options-&gt;Emulation ☀设置字体和编码格式 打开Options-&gt;Session Options-&gt;Appearance ☀Linux的目录结构： root管理员的home目录root 其他用户的home目录home目录中 ☀常用目录： 路径 作用 /etc/init.d 存放服务启动项的各种脚本。service命令依赖于此脚本。 ☀Linux的常用命令 ☀切换目录命令cd： 命令 描述 cd app 切换到app目录 cd .. 切换到上一层目录 cd / 切换到系统根目录 cd ~ 切换到用户主目录 cd ~/abc 切换到用户主目录下的某个文件夹中。 cd - 切换到上一个所在目录 tab 补全文件路径 ☀列出文件列表：ls ll ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式：ls\\[参数\\] \\[路径或文件名\\] 常用： 在linux中以 . 开头的文件都是隐藏的文件 命令 描述 ls 显示所有文件或目录 ls -a 显示所有文件或目录（包含隐藏的文件） ls -l 缩写成ll,显示所有文件或目录(详细信息,大小,创建时间,权限等) ls -l /etc 显示etc下的所有文件。 ☀创建目录和移除目录：mkdir rmdir 命令 描述 mkdir(make directory) mkdir app 在当前目录下创建 mkdir --p app2/test 级联创建aap2以及test目 rmdir(remove directory) 删除&quot;空&quot;的子目录：rmdir app 删除app目录 ☀浏览文件 命令 描述 cat 用于显示全部文件的内容。格式：cat[参数]&lt;文件名&gt;，内容太大受滚轮限制，显示不全。cat 命令后，直接可以加全路径的文件名。这样可以实现跨包访问。 more 一般用于要显示的内容会超过一个画面长度的情况。空格键显示下一个画面。回车显示下一行内容。 less less用法和more类似，不同的是less可以通过PgUp、PgDn、↑、↓键来控制。。 q 退出【cat、more、less】查看。 tail tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。 tail -10 /etc/passwd 查看后10行数据 tail -f catalina.log 动态查看日志(*****) ctrl+c 结束tail查看 ☀文件操作： ☀【rm】删除 命令 描述 rm 删除文件用法：rm [选项]… 文件…rm a.txt 删除a.txt文件删除需要用户确认，y/nrm 删除不询问但是不能删除文件夹。 rm -f a.txt 不询问，直接删除rm 删除目录 rm -r a 递归删除不询问递归删除（慎用）删除文件夹及文件。 rm -rf a 不询问递归删除 rm -rf * 删除当前目录下所有文件。(危险，慎用) rm -rf /* 自杀,删除根目录下所有文件。 ☀【cp、mv】复制 cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。 命令 描述 cp a.txt b.txt 将a.txt复制为b.txt文件 cp b.tar.gz aa 复制文件并且重命名。 cp a.txt ../ 将a.txt文件复制到上一层目录中cp 复制文件到某个文件夹： 可以不带路径/ cp .../* aa 将某个路径文件夹下的所有文件复制到指定的文件夹中。 mv 移动或者重命名 mv a.txt ../ 将a.txt文件移动到上一层目录中 mv a.txt b.txt 将a.txt文件重命名为b.txt cp -r dir 复制整个目录. ☀【tar】命令:(***** 打包或解压) tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数： 命令 描述 -c 创建一个新tar文件 -v 显示运行过程的信息 -f 指定文件名 -z 调用gzip压缩命令进行压缩 -t 查看压缩文件的内容 -x 解开tar文件 tar -cvf xxx.tar ./* 打包 tar -zcvf xxx.tar.gz ./* 打包并且压缩 tar -xvf xxx.tartar -zxvf xxx.tar.gz -C /usr/aaatar xf xxx.tar.gz 解压，三种解压方式都可以用。最后一种规避io，减小压力。 ☀【find】命令 find指令用于查找符合条件的文件 示例： find / -name ins*find / -name catal*.log / 表示从根目录查找查找文件名称是以ins开头的文件 find / -name ins*&quot; -ls -ls 显示查找到文件的详细信息。 find / -user itcast -ls 查找用户itcast的文件 find / -user itcast -type d -ls 查找用户itcast的目录 find / -perm -777 --type d -ls 查找权限是777的文件 ☀【grep】命令 查找文件里符合条件的字符串。 用法: grep [选项]… PATTERN [FILE]…示例： 命令 描述 grep lang anaconda-ks.cfg 在文件中查找lang grep lang anaconda-ks.cfg --color 高亮显示 grep lang anaconda-ks.cfg --color -A1 after，A1显示，后一行。 grep lang anaconda-ks.cfg --color -A1 -B1 before,B1显示前一行。 ☀其他常用命令 命令 描述 pwd 显示当前所在目录 touchtouch a.txt 创建一个空文件 clear/ crtl + L 清屏 yum install 软件名称 安装软件 yum remove 软件名称 卸载软件 yum update 软件名称 更新软件 yum list 列出所有可安装的软件包 yum list updates 列出所有可更新的软件包 yum list installed 列出所有已安装的软件包 yum info updates 列出所有可更新的软件包信息 yum info installed 列出所有已安裝的软件包信息 yum search 软件包名称 查询yum库中可安装包版本信息的。 目录/可执行的文件,例:./nginx,/tomcat/bin/startup.sh 执行命令的时候需要带上./，当前文件夹下的参数不需要。 chkconfig --list [name] 显示服务列表，和运行级别。 chkconfig --add [name] 添加服务，默认2，3，4，5，达到开机自启的效果，够用。 chkconfig --del [name] 删除服务。 chkconfig [--level levels] name &lt;on|off|reset&gt; 改变启动信息以及检查特定服务的启动状态 chkconfig 服务名 on 单独开启某一服务的命令 chkconfig 服务名 off 单独关闭某一服务的命令 /etc/intd.d/服务名 status 查看某一服务的状态 date 显示当前系统时间. echo $var 显示当前进程中的变量。 echo $PATH 查看环境变量的某个值。 ./test.sh &amp; 从后台执行脚本。 ☀Vi和Vim编辑器 ☀Vim编辑器： 在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。 💖vim时vi的升级版，功能支持更多，界面你显示更加友善，支持高亮。； 切换到命令行模式：按Esc键； 切换到插入模式：按 i 、o、a键； 切换到底行模式：按 :（冒号）； 打开文件：vim file ，如果打开的文件不存在，则会创建出文件。 退出：esc :q 修改文件：输入i进入插入模式 保存并退出：esc :wq 不保存退出：esc:q! 基本命令： 命令 描述 i 在当前位置前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 dd 快速删除一行 yy 复制当前行 nyy 从当前行向后复制几行 p 粘贴 R 替换 /查找内容 命令行模式搜索内容。 更多详细用法，查询笔记，linux-vi ☀重定向输出&gt;和&gt;&gt; &gt; 重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，又追加功能；示例： 命令 描述 cat /etc/passwd &gt; a.txt 将输出定向到a.txt中 cat /etc/passwd &gt;&gt; a.txt 输出并且追加 ifconfig &gt; ifconfig.txt 只要是控制台可以显示的信息，都可以重定向输出到指定的文件中。 ☀系统管理命令 命令 描述 ps 正在运行的某个进程的状态 ps -ef 查看所有进程 ps -ef | grep ssh 查找某一进程 kill 2868 杀掉2868编号的进程 kill -9 2868 强制杀死进程 kill -9 2868 2869 2870` 强制杀死多个进程. ☀管道 | 管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例 命令 描述 ls --help | more 分页显示查询帮助信息 ps -ef | grep java 查询名称中包含java的进程 ifconfig | more 分页显示主机ip信息。 cat index.html | more 分页显示index.html，直接用more🤣 管道深入理解： 管道的左右两边都会出发创建子进程。 ☀Linux的权限命令 ☀文件权限 属主（user） 属组（group） 其他用户 r w x r w x r w x 4 2 1 4 2 1 4 2 1 r:对文件是指可读取内容 对目录是可以ls w:对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件) x:对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录 ☀Linux三种文件类型： 普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 设备文件： Linux系统把每一个设备都看成是一个文件 ☀文件类型标识 普通文件（-）目录（d）符号链接（l） 进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p） ☀文件权限管理： chmod 变更文件或目录的权限。 命令 描述 chmod u=rwx,g=rx,o=rx a.txt u当前用户权限，g当前用户组其他成员权限，o其他用户组成员权限。 chmod 755 a.txt 使用数字替换。4+2+1，4+1，4+1. chmod +x xxx.sh 当前用户附加上可以执行权限。 ☀Linux上常用网络操作 ☀主机名配置 命令 描述 hostname 查看主机名 hostname xxx 修改主机名 重启后无效 ✔如果想要永久生效，可以修改/etc/sysconfig/network文件。 ☀IP地址配置 命令 描述 ifconfig 查看(修改)ip地址(重启后无效) ifconfig eth0 192.168.12.22 修改ip地址 ipv4地址是自动自动分配的。如果想要永久生效。修改 &lt;/etc/sysconfig/network-scripts/ifcfg-eth0&gt;文件 12345678DEVICE=eth0 #网卡名称BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none)HWADDR=00:0C:29:B5:B2:69 #MAC地址IPADDR=192.168.177.129 #IP地址NETMASK=255.255.255.0 #子网掩码NETWORK=192.168.177.0 #网络地址BROADCAST=192.168.0.255 #广播地址NBOOT=yes #系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。 修改完后，重启Linux网络服务生效。 1service network restart ☀域名映射 &lt;/etc/hosts&gt;文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的&lt;C:\\Windows\\System32\\drivers\\etc\\hosts文件的功能 ☀网络服务管理 命令 描述 service network status 查看指定服务的状态 service network stop 停止指定服务 service network start 启动指定服务 service network restart 重启指定服务 service --status-all 查看系统中所有后台服务 netstat --nltp 查看系统中网络进程的端口监听情况 防火墙设置 防火墙根据配置文件&lt;/etc/sysconfig/iptables&gt;来控制本机的&quot;出&quot;、&quot;入&quot;网络访问行为。 命令 描述 service iptables status 查看防火墙状态 service iptables stop 关闭防火墙 service iptables start 启动防火墙 chkconfig iptables off 禁止防火墙自启 ☀Linux上软件安装 ❤️编译就是将源码变成可执行文件。安装就是拷贝的过程。 Linux上的软件安装有以下几种常见方式介绍 二进制发布包 软件已经针对具体平台编译打包发布，只要解压，修改配置即可 RPM包 软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装 Yum在线安装 软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题 源码编译安装 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。 ☀上传与下载工具介绍 FileZilla 显示文件名乱码解决方案： 解决方案： 1、filezilla连接上站点后，点击菜单栏的“文件”选项，下拉选择“添加当前连接到站点管理器”。 2、在弹出的“站点管理器”窗口中，左侧选择“新站点”，右侧切换到“字符集”选项卡后，勾选“使用自定义的字符集 ”并将编码设置为“gb2312”，或者选择”强制UTF-8″ ，两者编码选择其一，就能解决乱码问题 lrzsz 我们可以使用yum安装方式安装 yum install lrzsz 注意：必须有网络 可以在crt中设置上传与下载目录 上传： 下载 sftp 使用alt + p 组合键打开sftp窗口 使用put 命令上传 😄小技巧：输入put命令后，进入电脑的某个目录，可以使用tab进行提示，需要上传哪个文件。 使用get命令下载 默认下载位置在当前计算的的文档位置 ☀在Linux上安装JDK: 检查系统的位数，下载对应的软件。 1getconf LONG_BIT 【步骤一】：上传JDK到Linux的服务器. # 查看jdk版本 1java --version # 查看安装的jdk信息 1rpm -qa | grep java # 卸载jdk，如果系统默认安装了， 卸载open-JDK 12rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686 #上传JDK，通过sftp快速本地上传。 【步骤二】：在Linux服务器上安装JDK. * 通常将软件安装到/usr/local * 直接解压就可以 1tar --xvf jdk.tar.gz -C 目标路径 【步骤三】：配置JDK的环境变量. 配置环境变量： ① 1vim /etc/profile ② 在末尾行添加 12345#set java environmentJAVA_HOME=/usr/local/jdk/jdk1.7.0_71CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 保存退出 ③ 使更改的配置立即生效 1source /etc/profile ☀在Linux上使用Mysql: ☀安装 ☀【步骤一】：将mysql的安装文件上传到Linux的服务器. 将mysql的tar解压 将系统自带的mysql卸载，详细卸载步骤，请看下方。 1rpm -qa|grep -i mysql 1rpm -ev MySQL-client-5.5.25a-1.rhel5 --nodeps ☀【步骤二】：安装MYSQL服务端 可能会出现的错误信息: MySQL-server-5.6.25-1.el6.x86_64 conflicts with file from package mariadb-libs-1:5.5.68-1.el7.x86_64 **解决办法:**删除冲突的包 1yum -y remove mariadb-libs-1:5.5.68-1.el7.x86_64 FATAL ERROR: please install the following Perl modules before executing /usr/bin/mysql_install_db: **解决方法 ：**安装autoconf库 1yum -y install autoconf 下面的提示是告诉我们root用户的密码第一次是随机生成的，它保存在/root/.mysql_secret中，第一次登录需要修改root密码 ☀【步骤三】：安装MYSQL客户端 查看生成的root密码 报错:原因是没有启动mysql服务 ☀【步骤四】：开启MYSQL服务 需要开启mysql服务 centos6命令：service mysql start centos7命令：systemctl start mysql 可能会出现的错误信息: Starting MySQL. ERROR! The server quit without updating PID file (/var/lib/mysql/localhost.localdomain.pid). **解决方案:**执行命令 1/usr/bin/mysql_install_db --user=mysql 注意执行,此命令后会生成mysql的初始密码。 登陆后修改mysql的root用户密码： 1234mysql -u root -pnew-passwordmysql&gt; use mysql;mysql&gt; UPDATE user SET password = PASSWORD(&#x27;新密码&#x27;) WHERE user = &#x27;root&#x27;;mysql&gt; FLUSH PRIVILEGES; 执行命令show databases;报错，原因是第一次操作mysql必须修改root用户的密码 设置root用户的密码 ☀【步骤五】：关于mysql远程访问设置 12grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;root&#x27;;flush privileges; 在linux中很多软件的端口都被&quot;防火墙&quot;限止，我们需要将防火墙关闭 防火墙打开3306端口 123/sbin/iptables -I INPUT -p tcp \\--dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save/etc/init.d/iptables status 学习阶段我们也可以直接将防火墙关闭 123service iptables stop; #Centos6systemctl stop firewalld; #Centos7 ☀【步骤六】：Mysql服务加入到系统服务并自动启动操作： 123456添加自动启动配置：chkconfig --add mysql启动：chkconfig mysql on查询列表：chkconfig ☀卸载 ☀一、使用以下命令查看当前安装mysql情况，查找以前是否装有mysql 1rpm -qa| &#x27;grep&#x27; -i mysql 可以看到如下图的所示： 显示之前安装了： MySQL-client-5.5.25a-1.rhel5 MySQL-server-5.5.25a-1.rhel5 ☀2、停止mysql服务、删除之前安装的mysql 删除命令：rpm -e –nodeps 包名 12rpm -ev MySQL-client-5.5.25a-1.rhel5rpm -ev MySQL-server-5.5.25a-1.rhel5 如果提示依赖包错误，则使用以下命令尝试 1rpm -ev MySQL-client-5.5.25a-1.rhel5 --nodeps 如果提示错误：error: %preun(xxxxxx) scriptlet failed, exit status 1 则用以下命令尝试： 1rpm -e --noscripts MySQL-client-5.5.25a-1.rhel5 ☀3、查找之前老版本mysql的目录、并且删除老版本mysql的文件和库 1find / -name mysql 查找结果如下： 12345find / -name mysql#结果/var/lib/mysql/var/lib/mysql/mysql/usr/lib64/mysql 删除对应的mysql目录 123rm -rf /var/lib/mysqlrm -rf /var/lib/mysqlrm -rf /usr/lib64/mysql 具体的步骤如图：查找目录并删除 **注意：**卸载后/etc/my.cnf不会删除，需要进行手工删除 1rm -rf /etc/my.cnf ☀4、再次查找机器是否安装mysql 1rpm -qa| grep -i mysql ☀配置mysql默认编码格式 安装完成后，mysql数据库的默认编码是latin1，可以使用下面代码查看数据库编码。 1show variables like &quot;%character%&quot;; 默认的latin1编码，会导致无法插入中文。 需要修改mysql的配置文件,并且重启mysql服务： 1.查找mysql配置文件位置： 1find / -name my.cnf 2.找到后，使用vim修改。添加内容具体如下： 12345678910[client]default-character-set = utf8[mysqld]character-set-server = utf8[mysql]default-character-set = utf8[mysql.server]default-character-set = utf8[mysqld_safe]default-character-set = utf8 3.重启mysql服务 1systemctl restart mysql 经过上面的修改后，以后数据库创建的表默认的编码都是utf8，可以插入中文了，但是在修改编码前已经创建的表和库编码还是latin1，还是不能插入中文，有两种解决办法： 1.第一种方法：最直接明了，删表重建。 2.第二种方法：使用下面语句，tablename换成你的表名，该语句的作用就是把表的编码换成utf8 alter table tablename convert to character set utf8; 3.在已经创建的默认latin1编码的库中，创建新表默认还会是latin1，所以，删除库或者修改库的默认编码。 ☀在Linux上安装tomcat 1.Tomcat上传到linux上 2.将上传的tomcat解压 3.在tomcat/bin目录下执行 startup.sh（注意防火墙） 4.查看目标 tomcat/logs/catalina.out ☀在Linux上安装redis 【步骤一】安装gcc-c++ redis是C语言开发，安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境。 输入命令: yum -y install gcc-c++ ✔️yum install gcc 查看gcc版本 1gcc -v 安装命令没有带y参数，输入y确认下载 输入y确认安装 安装 gcc 成功！ 【步骤二】安装redis 下载redis wget http://download.redis.io/releases/redis-3.0.4.tar.gz 解压 tar -xzvf redis-3.0.4.tar.gz 编译安装、 切换至程序目录，并执行make命令编译： cd redis-3.0.4 执行安装命令make make时出现如下错误，redis版本6太高，安装5即可。 make[1]: *** [server.o] 错误 1 make PREFIX=/usr/local/redis install make install安装完成后，会在/usr/local/redis/bin目录下生成下面几个可执行文件，它们的作用分别是： redis-server：Redis服务器端启动程序 redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作 redis-benchmark：Redis性能测试工具 redis-check-aof：数据修复工具 redis-check-dump：检查导出工具 【步骤三】配置redis 复制配置文件到/usr/local/redis/bin目录： cd redis-3.0.4 cp redis.conf /usr/local/redis/bin 【步骤四】测试启动redis 进入redis/bin目录 cd redis/bin 启动redis服务端 ./redis-server redis.conf 克隆新窗口，启动redis客户端 ./redis-cli 【步骤五】 配置添加redis客户端和服务端程序的环境变量。 1234vi /etc/profileREDIS_HOME=/usr/local/redisPATH=$REDIS_HOME/bin:$PATHexport REDIS_HOME PATH 【步骤六】进入util目录执行服务安装脚本。 12cd utils./install_server.sh 安装过程中，配置好端口名，其他使用默认即可。 【步骤七】检查已安装好的服务启动脚本。 1cd /etc/init.d/","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://aner1001.gitee.io/tags/Linux/"}]},{"title":"Git学习笔记","slug":"技术知识/工具/Git学习笔记","date":"2021-03-04T02:14:11.000Z","updated":"2021-03-04T02:10:11.000Z","comments":true,"path":"posts/2021/03/04/e55aa0d7a71b/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/04/e55aa0d7a71b/","excerpt":"Git工具学习笔记。主要参考了廖雪峰老师的学习网站。","text":"Git工具学习笔记。主要参考了廖雪峰老师的学习网站。 注：本文中如果使用了,，&lt;&gt;这些标签为了好的区分和显示效果才加上。实际写命令时不需要带上&lt;&gt;,直接写里面的名称内容就可以。 ☀命令整理： ☀创建版本库 init 1git init 将当前所在目录变成Git可以管理的仓库。初始化本地版本库。 clone 1git clone &lt;url&gt; #从远程仓库克隆,并关联远程仓库。 ☀修改和提交 add 1234git add [文件名] #添加单个文件git add [文件名] [文件名] #添加多个文件git add . #将所有修改的文件添加到暂存区。git add -f #强制添加。 参数 描述 -f 强制添加到git,使其修改被跟踪，跳过忽略文件验证。 commit 12git commit –m ”提交备注信息” #将文件提交到本地仓库。提交的是暂存区的版本。git commit --amend #覆盖上一次的提交内容和修改上一次提交描述。 参数 描述 --amend 覆盖上一次的提交内容和修改上一次提交描述。 status 1git status 查看仓库的状态(文件的修改和提交状态)。 ⭐️当需要切换分支时，如果status命令查出当前分支有修改，先要stash，再切换，符合规范。否则会造成，切换后，被修改的文件，无法切换成目标分支所对应的实际状态。 diff 123456git diff [文件名] #比较指定文件修改的地方。当前工作区中指定的文件进行比较。暂存区有add时，优先和暂存区比。未加到暂存区，和本地版本库最新的提交版本进行比较。git diff #如果不写文件名，比较所有被修改的文件，功能相同，下方类似。git diff HEAD [文件名] #比较的是工作区中指定的文件与版本库中文件的差异。HEAD指针指向当前，也可以写为HEAD^或者commit_idgit diff HEAD #比较所有被修改的文件。git diff --cached #比较暂存区和版本库的所有文件差异。git diff --cached [文件名] #指定文件进行比较。 参数 说明 --cached--staged 指定为暂存区文件。 rm 1git rm &lt;file&gt; 删除文件，文件区删除了文件，也需要将删除文件的修改操作记录到暂存区，才能commit。 stash 123456git stash #保存工作现场,工作区和暂存区。git stash apply #恢复工作现场。git stash drop #删除工作现场。git stash pop #恢复并删除工作现场。git stash list #查看保存的工作现场列表。git stash apply/drop/pop stash@&#123;0&#125; #操作指定工作现场。 ☀查看提交日志 log 12345git log #查看版本库从开始直到当前的commit记录日志，最新的提交显示在第一行。git log –-pretty=oneline #美化成一行显示修改日志。git log --graph #可以看到分支合并图。git log --graph --pretty=oneline --abbrev-commit #美化查看分支合并情况。git log -p &lt;file&gt; #查看指定文件的提交历史。 输入wq可以退出查看日志。 参数 描述 --pretty=oneline 显示成一行。 --graph 将合并情况显示成图表形式。 --abbrev-commit 简化CommitId，取前几位显示。 reflog 1git reflog # 查看所有commit版本的提交和回退的记录。 git reflog用来记录你的每一次命令。 blame 1git blame &lt;file&gt; #以列表的方式查看指定文件的提交历史。 ☀撤销 reset 123456789git reset --hard HEADgit reset --hard HEADgit reset --hard commit_id #版本强制回退，HEAD^表示上一版本 HEAD^^表示上上版本，以此类推。这个版本回退是针对commit管理的所有版本库中的文件，包括了新增和删除的文件和单个文件本身内容的删除和修改。回退时，会将暂存区和文件区版本都被覆盖，和本地仓库指定回退到的版本一致。可以用cimmit_id来代替。git reset HEAD &lt;file&gt;git reset HEAD^ &lt;file&gt;git reset Commit_id &lt;file&gt;#重置指定文件的暂存区内容,工作区内容不变。当HEAD为当前最新提交时，是丢弃暂存区。HEAD指向历史提交，则是将历史版本放入暂存区中。 checkout/restore 12git checkout &lt;file&gt;git restore &lt;file&gt; #(新版) 两个语句功能一致，撤销工作区的修改，回到让这个文件回到最近一次git commit或git add时的状态。 revert 1git revert &lt;commitId&gt; #撤销指定的提交。针对cherry-pick命令。单个的commitId回退操作。某个提交夹在了中间，就可以将该提交抽出来撤销掉。 ☀分支与标签 branch 12345678git branch #查看本地的所有分支，已经当前指向的分支。git branch dev #基于当前分支的版本，创建一个平行的分支。git branch -d dev #删除本地某个分支。如果创建后进行提交过，则此命令会失效。git branch -D Feature #强制删除本地某个分支。git barnch -r #查看远程的分支。git branch -a #查看本地和远程的所有分支。git branch -d -r &lt;branchname&gt; #删除远程分支(只是在本地上删除，删除后还需推送到服务器).git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; #重命名本地分支 参数 描述 -d,--delete 删除分支。 -f,--force 强制。 -D,--delete --force 强制删除，即使分支上有过修改和提交。 -r,--remote 远程操作。 -a,--all 查看本地和远程的所有分支。 -m,--move 移动或重命名。 -M,-move --force 强制移动或重命名。 checkout 12git checkout dev #切换分支。git checkout -b dev #创建并切换分支 参数 描述 -b 创建分支。 switch 12git switch dev #切换分支(新)。git switch -c dev #创建并切换分支(新)。 参数 描述 -c 创建分支。 👿注意： 分支的切换，工作区会保留已修改的内容，暂存区会保存已添加到暂存区的内容。已提交但是还没被修改的内容会在工作区实时同步。 所以切换分支使用前，尽量将所有分支内容都提交或者如果不能提交的stash起来，更加符合分支的时用思想。 tag 12345678git tag V1.0 #为当前分支最新的commit创建标签。git tag #查看所有标签。git tag tagName commitId #为历史中指定的commit打上标签。git tag -a tagName -m &quot;message&quot; commitId #创建带说明的标签git show tagName #查看标签信息所关联的提交信息(commitid，提交信息等)。git tag -d tagName #删除标签(删除的是本地的标签)。git push origin &lt;tagname&gt; #推送某个标签到远程。git push origin --tags #一次性推送尚未推送的所有标签到远程。 标签和commitId都没有分支划分，是针对整个仓库的。 ☀合并 merge 123git merge dev #合并分支。git merge --no-ff -m &quot;merge with no-ff&quot; dev #记录分支历史合并法。就是普通模式合并。git merge --abort #回滚到合并之前 参数 描述 --no-ff 普通模式合并。不会覆盖当前提交，生成新的提交。 --abort 回滚到合并之前。 merge从合并的角度可理解为合并merge右侧指定的分支到当前分支。 cherry-pick 1git cherry-pick commitId #针对某次修改的提交，合并到当前分支。 rebase 12git rebase #整理历史提交记录为一条直线。git rebase &lt;branch&gt; #指定分支操作。 如果是先提交，后拉取的操作，合并后，历史提交记录中会有合并产生。历史日志记录会显示合并的分叉线。该命令修改优化提交记录了抓变成先拉取后提交的操作，抹去合并的记录，使日志展现为一条直线。 ☀远程操作 remote 123456git remote #查看远程库。git remote show origin #查看本地分支和追踪情况。git remote -v #查看远程库详细信息。git remote add origin git@server-name:path/repo-name.git #添加远程库地址。git remote rm origin #删除已有的远程仓库origin。git remote prune origin #同步删除远程已删除的远程分支。 push 123456git push -u origin master #远程库推送并绑定。git push origin master #指定远程库和分支进行推送。git push --force #强制提交。git push origin:&lt;branchname&gt; #删除分支后推送至服务器。git push origin &lt;tagname&gt; #推送某个标签到远程。git push origin --tags #一次性推送尚未推送的所有标签到远程。 参数 描述 -u 将当前分支与远程库分支绑定。一般在第一次本地提交远程的时候使用。因为已经绑定，以后直接使用简写git push命令即可。拉取的时候使用git pull。 –force 进行强制覆盖提交。 –tags 一次性推送尚未推送的所有标签到远程。 checkout 12git checkout -b dev origin/dev #创建本地库中拉取到的远程origin的dev分支，到本地并关联绑定.git branch --set-upstream-to=origin/dev dev #将本地分支与远程分支绑定，绑定后才能使用fetch和pull拉取。 本地分支与远程分支绑定，如果未绑定是不能抓取分支的。(master分支再clone的时候默认绑定了。)(一般是本地push上去的分支，需要使用这个语句再绑定。名字尽量起得一样。) pull 123git pull #抓取并合并已绑定的分支。git pull git@github.com:aner1001/gitlearn1.git master --allow-unrelated-histories #将本地仓库从一个commit不一致，无关的远程仓库中拉取，甚至名字都不一样。git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; #将远程主机的某个分支的更新取回，并与本地指定的分支合并，如果不指定，就是默认当前分支。 参数 描述 --allow-unrelated-histories 将本地仓库从一个commit不一致，无关的远程仓库中拉取。 -f,--force 强制覆盖本地版本。 fetch 123git fetch &lt;远程主机名&gt; #这个命令将某个远程主机的更新全部取回本地.git fetch &lt;远程主机名&gt; &lt;分支名&gt; #只想取回特定分支的更新,注意之间有空格. 本地会产生一个 FETCH_HEAD分支。 ☀验证 check-ignore 1git check-ignore -v db.ini #验证查看文件匹配到的忽略ignore规则。 ☀子模块 submodule 1234567git submodule add 仓库地址 路径 #1.为当前工程添加submodule。git submoudle init #2.初始化子模块。git submoudle update #3.更新子模块。git submodule update --init --recursive #递归初始化并拉取更新所有子模块，效果=2和3.git submodule foreach git checkout master #foreach对每个子模块进行操作。这里是切换到主分支。git submodule foreach git pull #拉取所有子模块，跳过父工程的版本号记录。git submodule deinit &lt;submodule-name&gt; #删除子模块。不是真正的删除，下方常用操作中详细说明。 ☀配置 config 1234git config --global user.name &quot;Your Name&quot; #设置终端管理git仓库的用户名。git config --global user.email &quot;email@example.com&quot; #设置终端管理git仓库的邮件地址。git config --golbal color.ui.true #让Git显示颜色，会让命令输出看起来更醒目。git config --golbal alias.st status #为命令配置别名。 参数 描述 --global global参数表示终端所有的仓库中都会使用这个配置，也可以对某个仓库指定不同的用户名和Email地址。配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 ☀常用操作 ☀生成SSH密钥，绑定Git服务器。 生成密钥: 命令： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 绑定git服务器 登陆Git服务器，找到类似“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 完成后在命令行链接测试，首次建立链接会要求信任主机。 命令: 1ssh -T git@具体git服务器域名 ☀本地库关联远程库，推送远程库 这种情况针对于先有本地后有远程库。 关联远程库。 1git remote add origin git@server-name:path/repo-name.git 参数注释： 参数 描述 orgin 远程地址库标识变量名。 server-name git网站地址。 path 账户名 repo-name 远程仓库名 当本地项目没有生成秘钥，或者不方便生成秘钥，配置在服务器上。比如云端自动化部署场景。也可以使用https协议，在远程地址上添加用户名和密码或者使用生成的token，进行拉取和上传操作，密码和token类的一般存放在环境变量中比较安全。 12git remote add origin https://用户名:密码@github.com/用户名/仓库名.gitgit remote add origin https://$&#123;GITHUB_TOKEN&#125;@github.com/用户名/仓库名.git 在.git配置文件中可以进行修改。 将本地库的内容推送到远程库上。 1git push -u origin master 参数注释： 参数 描述 -u Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 origin 远程库标识名 master 分支名 ☀从远程仓库克隆 命令： 123git clone git@github.com:michaelliao/gitskills.git #SSH协议拉取。git clone https://github.com/aner1001/gitskills.git #Https协议。git clone -b dev https://github.com/aner1001/gitskills.git #指定分支拉取。 参数 描述 -b 指定分支进行拉取。 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 ☀撤回修改 1.需要丢弃工作期的修改，已提交到暂存区的，回退单最近的暂存区状态。未提交到暂存区，回退到最新的版本库状态。 12git checkout filegit restore file（高版本） 2.丢弃已提交到暂存区的修改文件，丢弃后工作区内容不变。HEAD指向当前最新提交。 1git reset HEAD file 3.已经提交了一次到版本库，要撤回提交。使用版本撤回命令，回到上一版本，但是是针对所有文件的。 1git reset --hard HEAD^ 4.针对单个文件恢复到版本库的状态，但是已提交了一版到暂存区。1和2配合使用。 12git reset HEAD file #1git checkout file #2 ​ 5.针对单个文件恢复到历史版本库的某个状态。 12git reset HEAD^/Commit_id file #1.将文件的历史版本拉到暂存区。git checkout file #2.从暂存区中将历史版本同步到文件区。 ❤️理解reset命令： 当HEAD为当前最新提交时，是丢弃暂存区。指向历史提交，则是将历史版本放入暂存区中。可以体会一下Git体会一下GIt丢弃暂存区和存入暂存区的想法。指向最新提交***丢弃*暂存区是因为版本库当前就是最新提交，checkout/restore直接就可以恢复到最新版，不需要再放到暂存区。指向历史版本存入**暂存区是因为，checkout/restore命令，首先恢复的是暂存区中的内容，就会直接恢复到指定历史版本，而不会恢复最新版本库中的提交了。 ☀改写提交 1git commit --amend #覆盖上一次的提交内容和修改上一次提交描述。 ☀删除分支同步远程 123git branch -d &lt;branchname&gt; #删除本地分支。git branch -d -r &lt;branchname&gt; #删除本地记录的远程分支。git push origin:&lt;branchname&gt; #将删除的分支同步到远程。 ☀重命名分支 1234git branch -m &lt;oldbranch&gt; &lt;newbranch&gt; #重命名分支git branch -d -r &lt;oldbranch&gt; #删除旧远程分支。git push origin:&lt;branchname&gt; #将删除旧分支同步到远程。git push -u origin &lt;newbranch&gt; #push本地新分支到远程服务器。 ☀同步已删除的远程分支 123git remote show origin #查看分支的追踪情况。git remote prune origin #同步已删除的远程分支。git remote -D &lt;branchname&gt; #删除本地多余分支。 ☀解决冲突 当两个分支都在原修改基础上做过提交，合并时，对于修改同一个内容的地方会存在冲突。 1git merge feature1 这个时候使用合并分支语句，Git无法判断，只能试图把各自的修改合并起来。**这时候就必须首先解决冲突。解决冲突后，再提交，合并完成。**Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，&lt;&lt;&lt;&lt;&lt;&lt;&lt;和&gt;&gt;&gt;&gt;&gt;&gt;&gt;对应不同分支中的内容，=======表示间隔。 注意：参与和合成的feature分支内容不会被改变。合成后，可以删除。如果feature分支要继续使用合并后的内容，直接和现有的master分支合并就可以，这时候就不会有冲突，应为已经合并过了，直接指向的是master分支。 Fast Forward 和 no fast foward 翻译为中文是： 快速向前合并，和非快速向前合并。 合并分支时，如果可能，在非指定的情况下git会使用Fast Forward模式，这时候会将当前的修改ID和被合并的修改内容直接对应覆盖原修改内容，放弃了原分支的修改内容，会丢掉此次的修改信息。 如果使用no fast foward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 命令： 1git merge --no-ff -m &quot;merge with no-ff&quot; dev 图文理解： no fast foward --no-ff 模式： Fast Forward 模式(默认) ☀分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： Feature分支当开发一个新功能时，创建Feature分支。但是当该功能不需要，也不需要再合并到主分支的时候，需要将其销毁。 销毁命令： Feature还未修改时，小D还可以验证，Feature是否已经被合并。 1git branch -d Feature Feature已修改，但是还没有合并，使用大D，强制删除。 1git branch -D Feature ☀处理紧急BUG，但是当前分支有修改还不能提交 场景：当需要放下手头现在正在开发的工作，现在的工作还没开发完成，无法提交。而要立马去从事其他开发工作，例如短时间的修复BUG，或者紧急功能开发。 保存工作现场 1git stash 保存对象：——&gt;工作区的修改,和暂存区的修改与文件。 没有被Git管理的文件不会被保存。 保存之后，当前工作区和暂存区所有的内容都被还原。 当修复BUG完后，回到刚才的工作分支，需要还原之前保存的工作现场。 查看保存的工作现场列表 1git stash list 恢复工作现场 1git stash apply 删除工作现场 1git stash drop 恢复并删除工作现场 1git stash pop 操作指定的工作现场 1git stash apply stash@&#123;0&#125; 注意：当文件恢复时，如果修改的地方有冲突，那么会像合并分支一样，产生冲突文件。需要手工去解决冲突。 当修改BUG后，BUG分支已经合并到主分支，并且BUG分支已经删除。这时候想在其他分支上也修复此BUG，但是其他分支不能和主分支完全合并，只需要修改BUG的那个提交。 针对某次提交到当前分支。 1git cherry-pick commitId ❤️个人理解：针对某个单次提交进行的合并。merge实际上是针对所有的提交，多次的提交进行合并。合并的单操作和多操作的区别。 ☀拉取fetch&amp;pull 可以简单的概括为：git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。 git fetch 命令： 1git fetch &lt;远程主机名&gt; #这个命令将某个远程主机的所有分支的更新全部取回本地。 如果只想取回特定分支的更新，可以指定分支名： 1git fetch &lt;远程主机名&gt; &lt;分支名&gt; #注意之间有空格 最常见的命令如取回origin 主机的master 分支： 1git fetch origin master 取回更新后，会返回一个FETCH_HEAD ，指的是某个branch在服务器上的最新状态，我们可以在本地通过它查看刚取回的更新信息： 1git log -p FETCH_HEAD 可以看到返回的信息包括更新的文件名，更新的作者和时间，以及更新的代码（19行红色[删除]和绿色[新增]部分）。我们可以通过这些信息来判断是否产生冲突，以确定是否将更新merge到当前分支。 前面提到，git pull 的过程可以理解为： 123git fetch origin master #从远程主机的master分支拉取最新内容git merge FETCH_HEAD #将拉取下来的最新内容合并到当前所在的分支中git merge origin/master #这样写应该也可以。拉个多个远程分支下来的时候。 git pull命令： 即将远程主机的某个分支的更新取回，并与本地指定的分支合并，完整格式可表示为： 1git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 如果远程分支是与当前分支合并，则冒号后面的部分可以省略： 1git pull origin next -f 参数，远程库强制覆盖本地版本。push 指令后也可以加入，强制提交覆盖远程版本。 ☀Rebase 整理历史提交记录为一条直线。 针对多人合作的单条分支上，单人的分支合并仍然会显示三角。 1git rebase 会将GIt合并(远程与本地同分支)的三叉分支，整理为一条直线。但是这样也看不出来那几个分支做了合并。根据实际情况，需要再使用。 会将pull的版本提前，使其顺理成章的变成一条直线。 rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 缺点是本地的分叉提交已经被修改过了。相当于将pull放在commit顺序后，重新进行了按次序多次修改，重新生成了commitID，变成了本地的最后一次commitID。需要再重新pull一次。 ☀忽略特殊文件： 忽略某些文件时，需要编写.gitignore 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 GitHub上已经成型的准备好的配置文件库，可在线浏览， https://github.com/github/gitignore 忽略文件的原则是： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 查看文件匹配到的忽略规则 1git check-ignore -v db.ini 强制添加到Git,使其修改被跟踪，跳过忽略文件验证。 1git add -f Desktop.ini 如果强制添加到Git的文件，就匹配不到规则了。 ☀配置别名 1234git config --global alias.st statusgit config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branch 撤销暂存区提交 1git config --global alias.unstage &#x27;reset HEAD&#x27; 显示最后一次提交信息 1git config --global alias.last &#x27;log -1&#x27; 配置漂亮的log 1git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot; 🐤效果展示： ☀配置文件 1.每个仓库单独的Git配置文件都放在.git/config文件中 1cat .git/config 2.当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中。也就是—global 时配置的会保存在这里面。 删除别名时，修改这个配置文件，找到对应的行，删除即可。需要全部重新配置，删除配置文件，重新配置也可以。单独修改时，重新输入命令修改，覆盖原配置。 ☀子模块共代码库的版本管理 开发过程中，经常会有一些通用的部分希望抽取出来做成一个公共库来提供给别的工程来使用，而公共代码库的版本管理是个麻烦的事情。使用git的git submodule命令，问题迎刃而解了。 ☀添加子模块 为当前工程添加submodule，命令如下： 1git submodule add 仓库地址 路径 仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径 注意：路径不能以 / 结尾（会造成修改不生效）、不能是现有工程已有的目录（不能順利 Clone） 命令执行完成，会在当前工程根路径下生成一个名为“.gitmodules”的文件，其中记录了子模块的信息。添加完成以后，再将子模块所在的文件夹添加到工程中即可，远程仓库中则会出现子模块@版本号的快捷方式。 ☀查看子模块 查看 .gitmodules ☀下载子模块 当使用git clone下来的工程中带有submodule时，初始的时候，submodule的内容并不会自动下载下来的，此时，只需执行如下命令： 方式1： 12git submoudle init #注：这个方法是根据.gitmodule的配置在.git的config配置中增加子模块配置。git submoudle update #注意：这个方法的意思是，更新到父工程中记录的子模块版本号，不会更新子模块版本库中最新的版本号。 方式2： 1git submodule update --init --recursive 即可将子模块内容下载下来后工程才不会缺少相应的文件。 方式3： 12#在克隆父工程时，直接使用递归命令git clone 父工程地址 --recursive ☀❤子模块切换主线分支 当子模块有多个分支时，根据实际的使用情况。cd到子模块目录中，切换主线分支。否则修改子模块会被记录到临时创建的分支上。 12cd &#x27;submodule&#x27;git checkout master 全部统一切换： 1git submodule foreach git checkout master ☀更新子模块 场景1：当父工程记录的子模块版本更新后，更新父工程中的子模块。 1git submodule update 场景2：子模块更新，但是父工程记录的子模块未更新时，更新子模块操作。 单个子模块更新： 进入子模块中，调整主线分支，使用git操作pull。最终父工程再提交一次，记录子模块更新后的版本。 多个子模块跟新： 1git submodule foreach git pull #拉取所有子模块，跳过父工程的版本号记录。 更新完成后，需要将父工程中新的子模块版本号，commit +push。 ☀删除 经过网上的各个版本总结的一个有效方案： 删除子模块文件和.git config的配置信息。 1git submodule deinit &lt;submodule-name&gt; 删除子模块缓存： 123git rm --cached path_to_submodule#补充：参数-r =递归git rm -r --cached . #文件夹下的所有文件缓存删除。如果缓存删不干净用这个。 删除子模块空文件夹 1rm -rf 子模块文件夹 删除.git下的缓存模块。 1rm -rf .git/module/path_to_submodule 删除.gitmodules中的配置信息，在全部清除的情况下或者整个文件都可以删除。 前五部就将子模块删除干净了。如果需要重新添加子模块。git submodule add新子模块即可。 ☀自定义第三方库，同时保持第三方库的官方更新。 自己有一个 fork 的三方项目。没有的话直接去第三方项目fork。 克隆自己fork的第三方项目,或者添加到子模块的方式，将fork库添加到本地。 1git clone / git submodule add [address] [path] cd进入仓库，查看远程库信息。 1git remote -v 自己fork的项目中，本地添加一个三方的源。 1git remote add dist_upstream [第三方源地址] 在自己fork的项目进行自定义改造并提交。如果是子模块则按照子模块的方式提交。 当原第三方库有了更新后。需要将更新纳入自己的fork中时。 方法1： pull拉取合并一个分支的方式. 1git pull dist_upstream master 如果有冲突，解决冲突合并后,进行提交。 1git push origin master 方法2： fetch拉取全部的分支，选择一个合并的分支,如果有冲突，解决冲突后，进行提交。 123git fetch dist_upstreamgit merge dist_upstream/mastergit push origin master +++ ☀知识整理 图片、视频、Word文件这些二进制文件，git无法跟踪变化，只能知道改动大小。 千万不要使用Windows自带的记事本编辑任何文本文件。 原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。使用EditPlus或者比较主流的编辑器。 Git中存在指向本地支线的一个指针叫HEAD。 HEAD与master 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。 id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 Git支持多种传输协议 ssh协议: git@github.com:michaelliao/gitskills.git -本地Git仓库和远程仓库之间的传输是通过SSH加密的。 ​ https协议: https://github.com/michaelliao/gitskills.git ​ 区别：使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。SSH协议只认机器，HTTPS协议只认账号；也即为： 如果使用SSH操作远程仓库的话，我们需要使用公钥和私钥对来做权限的认证，如果使用HTTPS操作远程 仓库，则需要使用账号密码来做权限的认证。无论是公钥私钥对，还是账号密码，都只做权限的认证； 邮箱： 1.关于git邮箱涉及到三处： 1）git config 时为仓库配置的提交者邮箱。$ git config --global user.email “email@example.com” 2）git 生成秘钥时，所使用的的邮箱。 $ ssh-keygen -t rsa -C youremail@example.com 3）git网站，账号所注册的邮箱。 2.三个邮箱有没有直接关联和验证同步。 测试结果：当git生成秘钥时所使用的邮箱和git网站所注册的邮箱不一致时，仍然可以进行操作网站中的git仓库。 3.理解： 1 )git config 时为仓库配置的提交者邮箱，只为了远程仓库记录下这些操作是由谁来完成的。远程仓库里需要记录这些提交记录是由谁来完成的；所以我们需要给本地的git设置用户名和邮箱，用于从本地仓库向远程仓库提交记录时，在远程仓库记录下这些操作是由谁来完成的。 ​ 2 )生成秘钥的邮箱只为了，验证机器而存在。 ​ 3 ) git网站所注册的邮箱，就是注册时绑定的，可能用来找回密码，或者GIt上做了一些操作进行实时通知。 4、官方解释： 1）为什么要配置用户名和邮箱？ 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址（名字和邮箱都不会进行验证），这样远程仓库才知道哪次提交是由谁完成的。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 2）配置的用户名和邮箱对push代码到远程仓库有什么影响？ 首先，配置的用户名和邮箱对push代码到远程仓库时的身份验证没有作用，即不用他们进行身份验证；他们仅仅会出现在远程仓库的commits里。 其次，按正常操作来说，你应该配置你的真实用户名和邮箱，这样一来在远程仓库的commits里可以看到哪个操作是你所为。 最后，这个用户名和邮箱是可以随便配置的（不提倡），如果你配置的邮箱是github里真实存在的邮箱，则commits里显示的是这个邮箱对应的账号；如果配置的邮箱是一个在github里不存在的邮箱，则commits里显示的是你配置的用户名。 Git的优秀之处： 因为Git跟踪并管理的是修改，而非文件。 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ **下载：**如果下载太慢可以用镜像网站：https://npm.taobao.org/mirrors/git-for-windows/","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://aner1001.gitee.io/tags/Git/"}]},{"title":"Springboot学习笔记5-数据源配置","slug":"技术知识/Java/框架/Springboot/Springboot学习笔记5-数据源配置","date":"2021-03-03T13:27:01.000Z","updated":"2021-03-03T13:27:01.000Z","comments":true,"path":"posts/2021/03/03/477e70e48710/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/03/477e70e48710/","excerpt":"","text":"springboot配置数据源 ​ Spring Framework 为 SQL 数据库提供了广泛的支持。从直接使用 JdbcTemplate 进行 JDBC 访问到完全的对象关系映射（object relational mapping）技术，比如 Hibernate。Spring Data 提供了更多级别的功能，直接从接口创建的 Repository 实现，并使用了约定从方法名生成查询。 ☀1、JDBC 1、创建项目，导入需要的依赖 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 2、配置数据源 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.85.111:3306/sakila?serverTimezone=UTC&amp;useUnicode=true@characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver 3、测试类代码 1234567891011121314151617181920212223242526package com.mashibing;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootTestclass DataApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException &#123; System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); connection.close(); &#125;&#125;//可以看到默认配置的数据源为class com.zaxxer.hikari.HikariDataSource，我们没有经过任何配置，说明springboot默认情况下支持的就是这种数据源，可以在DataSourceProperties.java文件中查看具体的属性配置 4、crud操作 ​ 1、有了数据源(com.zaxxer.hikari.HikariDataSource)，然后可以拿到数据库连接(java.sql.Connection)，有了连接，就可以使用连接和原生的 JDBC 语句来操作数据库 ​ 2、即使不使用第三方第数据库操作框架，如 MyBatis等，Spring 本身也对原生的JDBC 做了轻量级的封装，即 org.springframework.jdbc.core.JdbcTemplate。 ​ 3、数据库操作的所有 CRUD 方法都在 JdbcTemplate 中。 ​ 4、Spring Boot 不仅提供了默认的数据源，同时默认已经配置好了 JdbcTemplate 放在了容器中，程序员只需自己注入即可使用 ​ 5、JdbcTemplate 的自动配置原理是依赖 org.springframework.boot.autoconfigure.jdbc 包下的 org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration 类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.mashibing.contoller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RestController;import java.util.List;import java.util.Map;@RestControllerpublic class JDBCController &#123; @Autowired JdbcTemplate jdbcTemplate; @GetMapping(&quot;/emplist&quot;) public List&lt;Map&lt;String,Object&gt;&gt; empList()&#123; String sql = &quot;select * from emp&quot;; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(sql); return maps; &#125; @GetMapping(&quot;/addEmp&quot;) public String addUser()&#123; String sql = &quot;insert into emp(empno,ename) values(1111,&#x27;zhangsan&#x27;)&quot;; jdbcTemplate.update(sql); return &quot;success&quot;; &#125; @GetMapping(&quot;/updateEmp/&#123;id&#125;&quot;) public String updateEmp(@PathVariable(&quot;id&quot;) Integer id)&#123; String sql = &quot;update emp set ename=? where empno = &quot;+id; String name = &quot;list&quot;; jdbcTemplate.update(sql,name); return &quot;update success&quot;; &#125; @GetMapping(&quot;/deleteEmp/&#123;id&#125;&quot;) public String deleteEmp(@PathVariable(&quot;id&quot;)Integer id)&#123; String sql = &quot;delete from emp where empno = &quot;+id; jdbcTemplate.update(sql); return &quot;delete success&quot;; &#125;&#125; ☀2、自定义数据源DruidDataSource 通过源码查看DataSourceAutoConfiguration.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configuration(proxyBeanMethods = false)@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)@EnableConfigurationProperties(DataSourceProperties.class)@Import(&#123; DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class &#125;)public class DataSourceAutoConfiguration &#123; @Configuration(proxyBeanMethods = false) @Conditional(EmbeddedDatabaseCondition.class) @ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;) @Import(EmbeddedDataSourceConfiguration.class) protected static class EmbeddedDatabaseConfiguration &#123; &#125; @Configuration(proxyBeanMethods = false) @Conditional(PooledDataSourceCondition.class) @ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;) @Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class, DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;) protected static class PooledDataSourceConfiguration &#123; &#125; /** * &#123;@link AnyNestedCondition&#125; that checks that either &#123;@code spring.datasource.type&#125; * is set or &#123;@link PooledDataSourceAvailableCondition&#125; applies. */ static class PooledDataSourceCondition extends AnyNestedCondition &#123; PooledDataSourceCondition() &#123; super(ConfigurationPhase.PARSE_CONFIGURATION); &#125; @ConditionalOnProperty(prefix = &quot;spring.datasource&quot;, name = &quot;type&quot;) static class ExplicitType &#123; &#125; @Conditional(PooledDataSourceAvailableCondition.class) static class PooledDataSourceAvailable &#123; &#125; &#125; 1、添加druid的maven配置 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt;&lt;/dependency&gt; 2、添加数据源的配置 1234567spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTC&amp;useUnicode=true@characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource 3、测试发现数据源已经更改 4、druid是数据库连接池，可以添加druid的独有配置 12345678910111213141516171819202122232425262728spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTC&amp;useUnicode=true@characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #Spring Boot 默认是不注入这些属性值的，需要自己绑定 #druid 数据源专有配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true #配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入 #如果允许时报错 java.lang.ClassNotFoundException: org.apache.log4j.Priority #则导入 log4j 依赖即可，Maven 地址： https://mvnrepository.com/artifact/log4j/log4j filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 测试类，发现配置的参数没有生效 12345678910111213141516171819202122232425262728293031package com.mashibing;import com.alibaba.druid.pool.DruidDataSource;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootTestclass DataApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException &#123; System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); DruidDataSource druidDataSource = (DruidDataSource)dataSource; System.out.println(druidDataSource.getMaxActive()); System.out.println(druidDataSource.getInitialSize()); connection.close(); &#125;&#125; 需要定义druidDatasource的配置类，绑定参数 123456789101112131415161718package com.mashibing.config;import com.alibaba.druid.pool.DruidDataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.sql.DataSource;@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125;&#125; Druid数据源还具有监控的功能，并提供了一个web界面方便用户进行查看。 加入log4j的日志依赖 123456&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; 向DruidConfig中添加代码，配置druid监控管理台的servlet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mashibing.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import com.alibaba.druid.support.http.WebStatFilter;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import javax.servlet.Servlet;import javax.sql.DataSource;import java.util.Arrays;import java.util.HashMap;import java.util.Map;@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = &quot;spring.datasource&quot;) @Bean public DataSource druidDataSource()&#123; return new DruidDataSource(); &#125; @Bean public ServletRegistrationBean druidServletRegistrationBean()&#123; ServletRegistrationBean&lt;Servlet&gt; servletRegistrationBean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(),&quot;/druid/*&quot;); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;); initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;); //后台允许谁可以访问 //initParams.put(&quot;allow&quot;, &quot;localhost&quot;)：表示只有本机可以访问 //initParams.put(&quot;allow&quot;, &quot;&quot;)：为空或者为null时，表示允许所有访问 initParams.put(&quot;allow&quot;,&quot;&quot;); //deny：Druid 后台拒绝谁访问 //initParams.put(&quot;msb&quot;, &quot;192.168.1.20&quot;);表示禁止此ip访问 servletRegistrationBean.setInitParameters(initParams); return servletRegistrationBean; &#125; //配置 Druid 监控 之 web 监控的 filter //WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计 @Bean public FilterRegistrationBean webStatFilter() &#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); //exclusions：设置哪些请求进行过滤排除掉，从而不进行统计 Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(&quot;exclusions&quot;, &quot;*.js,*.css,/druid/*&quot;); bean.setInitParameters(initParams); //&quot;/*&quot; 表示过滤所有请求 bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;)); return bean; &#125;&#125; ☀3、springboot配置多数据源并动态切换 ​ DataSource是和线程绑定的，动态数据源的配置主要是通过继承AbstractRoutingDataSource类实现的，实现在AbstractRoutingDataSource类中的 protected Object determineCurrentLookupKey()方法来获取数据源，所以我们需要先创建一个多线程线程数据隔离的类来存放DataSource，然后在determineCurrentLookupKey()方法中通过这个类获取当前线程的DataSource，在AbstractRoutingDataSource类中，DataSource是通过Key-value的方式保存的，我们可以通过ThreadLocal来保存Key，从而实现数据源的动态切换。 1、修改配置文件类 123456789101112spring: datasource: local: username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver jdbc-url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC&amp;useUnicode=true@characterEncoding=utf-8 remote: username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver jdbc-url: jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTC&amp;useUnicode=true@characterEncoding=utf-8 jdbc-url参数用于HikariCP数据源。 url参数用于Druid数据源。 2、创建数据源枚举类 123456package com.mashibing.mult;public enum DataSourceType &#123; REMOTE, LOCAL&#125; 3、数据源切换处理 ​ 创建一个数据源切换处理类，有对数据源变量的获取、设置和情况的方法，其中threadlocal用于保存某个线程共享变量。 12345678910111213141516171819202122232425262728293031323334package com.mashibing.mult;public class DynamicDataSourceContextHolder &#123; /** * 使用ThreadLocal维护变量，ThreadLocal为每个使用该变量的线程提供独立的变量副本， * 所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 */ private static final ThreadLocal&lt;String&gt; CONTEXT_HOLDER = new ThreadLocal&lt;&gt;(); /** * 设置数据源变量 * @param dataSourceType */ public static void setDataSourceType(String dataSourceType)&#123; System.out.printf(&quot;切换到&#123;%s&#125;数据源&quot;, dataSourceType); CONTEXT_HOLDER.set(dataSourceType); &#125; /** * 获取数据源变量 * @return */ public static String getDataSourceType()&#123; return CONTEXT_HOLDER.get(); &#125; /** * 清空数据源变量 */ public static void clearDataSourceType()&#123; CONTEXT_HOLDER.remove(); &#125;&#125; 4、继承AbstractRoutingDataSource ​ 动态切换数据源主要依靠AbstractRoutingDataSource。创建一个AbstractRoutingDataSource的子类，重写determineCurrentLookupKey方法，用于决定使用哪一个数据源。这里主要用到AbstractRoutingDataSource的两个属性defaultTargetDataSource和targetDataSources。defaultTargetDataSource默认目标数据源，targetDataSources（map类型）存放用来切换的数据源。 1234567891011121314151617181920212223242526package com.mashibing.mult;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;import javax.sql.DataSource;import java.util.Map;public class DynamicDataSource extends AbstractRoutingDataSource &#123; public DynamicDataSource(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources) &#123; super.setDefaultTargetDataSource(defaultTargetDataSource); super.setTargetDataSources(targetDataSources); // afterPropertiesSet()方法调用时用来将targetDataSources的属性写入resolvedDataSources中的 super.afterPropertiesSet(); &#125; /** * 根据Key获取数据源的信息 * * @return */ @Override protected Object determineCurrentLookupKey() &#123; return DynamicDataSourceContextHolder.getDataSourceType(); &#125;&#125; 5、注入数据源 123456789101112131415161718192021222324252627282930313233343536package com.mashibing.mult;import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import javax.sql.DataSource;import java.util.HashMap;import java.util.Map;@Configurationpublic class DataSourceConfig &#123; @Bean @ConfigurationProperties(&quot;spring.datasource.remote&quot;) public DataSource remoteDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(&quot;spring.datasource.local&quot;) public DataSource localDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean(name = &quot;dynamicDataSource&quot;) @Primary public DynamicDataSource dataSource(DataSource remoteDataSource, DataSource localDataSource) &#123; Map&lt;Object, Object&gt; targetDataSources = new HashMap&lt;&gt;(); targetDataSources.put(DataSourceType.REMOTE.name(), remoteDataSource); targetDataSources.put(DataSourceType.LOCAL.name(), localDataSource); return new DynamicDataSource(remoteDataSource, targetDataSources); &#125;&#125; 6、自定义多数据源切换注解 ​ 设置拦截数据源的注解，可以设置在具体的类上，或者在具体的方法上 12345678910111213package com.mashibing.mult;import java.lang.annotation.*;@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface DataSource &#123; /** * 切换数据源名称 */ DataSourceType value() default DataSourceType.REMOTE;&#125; 7、AOP拦截类的实现 ​ 通过拦截上面的注解，在其执行之前处理设置当前执行SQL的数据源的信息，CONTEXT_HOLDER.set(dataSourceType)这里的数据源信息从我们设置的注解上面获取信息，如果没有设置就是用默认的数据源的信息。 1234567891011121314151617181920212223242526272829303132333435363738package com.mashibing.mult;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.springframework.core.annotation.Order;import org.springframework.stereotype.Component;import java.lang.reflect.Method;@Aspect@Order(1)@Componentpublic class DataSourceAspect &#123; @Pointcut(&quot;@annotation(com.mashibing.mult.DataSource)&quot;) public void dsPointCut() &#123; &#125; @Around(&quot;dsPointCut()&quot;) public Object around(ProceedingJoinPoint point) throws Throwable &#123; MethodSignature signature = (MethodSignature) point.getSignature(); Method method = signature.getMethod(); DataSource dataSource = method.getAnnotation(DataSource.class); if (dataSource != null) &#123; DynamicDataSourceContextHolder.setDataSourceType(dataSource.value().name()); &#125; try &#123; return point.proceed(); &#125; finally &#123; // 销毁数据源 在执行方法之后 DynamicDataSourceContextHolder.clearDataSourceType(); &#125; &#125;&#125; 8、使用切换数据源注解 12345678910111213141516171819202122232425262728293031package com.mashibing.mult;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;import java.util.Map;@RestControllerpublic class EmpController &#123; @Autowired JdbcTemplate jdbcTemplate; @GetMapping(&quot;/local&quot;) @DataSource(value = DataSourceType.LOCAL) public List&lt;Map&lt;String, Object&gt;&gt; local()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(&quot;select * from emp&quot;); return maps; &#125; @GetMapping(&quot;/remote&quot;) @DataSource(value = DataSourceType.REMOTE) public List&lt;Map&lt;String, Object&gt;&gt; remote()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps = jdbcTemplate.queryForList(&quot;select * from emp&quot;); return maps; &#125;&#125; 9、在启动项目的过程中会发生循环依赖的问题，直接修改启动类即可 12345678910111213package com.mashibing;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)public class SpringbootDataApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDataApplication.class, args); &#125;&#125; ☀4、springboot整合mybatis 1、导入mybatis的依赖 1234567&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.1&lt;/version&gt;&lt;/dependency&gt; 2、配置数据源 123456spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTC&amp;useUnicode=true@characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver 3、测试类 123456789101112131415161718192021222324252627package com.mashibing;import com.alibaba.druid.pool.DruidDataSource;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;@SpringBootTestclass DataApplicationTests &#123; @Autowired DataSource dataSource; @Test void contextLoads() throws SQLException &#123; System.out.println(dataSource.getClass()); Connection connection = dataSource.getConnection(); System.out.println(connection); System.out.println(connection.getMetaData().getURL()); connection.close(); &#125;&#125; 4、创建实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.mashibing.entity;import java.sql.Date;import java.util.Objects;public class Emp &#123; private Integer empno; private String ename; private String job; private Integer mgr; private Date hiredate; private Double sal; private Double comm; private Integer deptno; public Emp() &#123; &#125; public Emp(Integer empno, String ename) &#123; this.empno = empno; this.ename = ename; &#125; public Emp(Integer empno, String ename, String job, Integer mgr, Date hiredate, Double sal, Double comm, Integer deptno) &#123; this.empno = empno; this.ename = ename; this.job = job; this.mgr = mgr; this.hiredate = hiredate; this.sal = sal; this.comm = comm; this.deptno = deptno; &#125; public Integer getEmpno() &#123; return empno; &#125; public void setEmpno(Integer empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public Integer getMgr() &#123; return mgr; &#125; public void setMgr(Integer mgr) &#123; this.mgr = mgr; &#125; public Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(Date hiredate) &#123; this.hiredate = hiredate; &#125; public Double getSal() &#123; return sal; &#125; public void setSal(Double sal) &#123; this.sal = sal; &#125; public Double getComm() &#123; return comm; &#125; public void setComm(Double comm) &#123; this.comm = comm; &#125; public Integer getDeptno() &#123; return deptno; &#125; public void setDeptno(Integer deptno) &#123; this.deptno = deptno; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Emp)) return false; Emp emp = (Emp) o; return Objects.equals(empno, emp.empno) &amp;&amp; Objects.equals(ename, emp.ename) &amp;&amp; Objects.equals(job, emp.job) &amp;&amp; Objects.equals(mgr, emp.mgr) &amp;&amp; Objects.equals(hiredate, emp.hiredate) &amp;&amp; Objects.equals(sal, emp.sal) &amp;&amp; Objects.equals(comm, emp.comm) &amp;&amp; Objects.equals(deptno, emp.deptno); &#125; @Override public int hashCode() &#123; return Objects.hash(empno, ename, job, mgr, hiredate, sal, comm, deptno); &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;empno=&quot; + empno + &quot;, ename=&#x27;&quot; + ename + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, mgr=&quot; + mgr + &quot;, hiredate=&quot; + hiredate + &quot;, sal=&quot; + sal + &quot;, comm=&quot; + comm + &quot;, deptno=&quot; + deptno + &#x27;&#125;&#x27;; &#125;&#125; 5、配置Mapper接口类 1234567891011121314151617181920212223package com.mashibing.mapper;import com.mashibing.entity.Emp;import org.apache.ibatis.annotations.Mapper;import org.springframework.stereotype.Repository;import java.util.List;@Mapper@Repositorypublic interface EmpMapper &#123; List&lt;Emp&gt; selectEmp(); Emp selectEmpById(Integer empno); Integer addEmp(Emp emp); Integer updateEmp(Emp emp); Integer deleteEmp(Integer empno);&#125; 6、在resources下创建Emp.xml文件 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.mapper.EmpMapper&quot;&gt; &lt;select id=&quot;selectEmp&quot; resultType=&quot;Emp&quot;&gt; select * from emp &lt;/select&gt; &lt;select id=&quot;selectEmpById&quot; resultType=&quot;Emp&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt; &lt;insert id=&quot;addEmp&quot; parameterType=&quot;Emp&quot;&gt; insert into emp (empno,ename) values (#&#123;empno&#125;,#&#123;ename&#125;) &lt;/insert&gt; &lt;update id=&quot;updateEmp&quot; parameterType=&quot;Emp&quot;&gt; update emp set ename=#&#123;ename&#125; where empno = #&#123;empno&#125; &lt;/update&gt; &lt;delete id=&quot;deleteEmp&quot; parameterType=&quot;int&quot;&gt; delete from emp where empno = #&#123;empno&#125;&lt;/delete&gt;&lt;/mapper&gt; 7、添加配置文件 123456789spring: datasource: username: root password: 123456 url: jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTC&amp;useUnicode=true@characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Drivermybatis: mapper-locations: classpath:mybatis/mapper/*.xml type-aliases-package: com.mashibing.entity 8、编写controller 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.mashibing.contoller;import com.mashibing.entity.Emp;import com.mashibing.mapper.EmpMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class EmpController &#123; @Autowired private EmpMapper empMapper; //选择全部用户 @GetMapping(&quot;/selectEmp&quot;) public String selectEmp()&#123; List&lt;Emp&gt; emps = empMapper.selectEmp(); for (Emp Emp : emps) &#123; System.out.println(Emp); &#125; return &quot;ok&quot;; &#125; //根据id选择用户 @GetMapping(&quot;/selectEmpById&quot;) public String selectEmpById()&#123; Emp emp = empMapper.selectEmpById(1234); System.out.println(emp); return &quot;ok&quot;; &#125; //添加一个用户 @GetMapping(&quot;/addEmp&quot;) public String addEmp()&#123; empMapper.addEmp(new Emp(1234,&quot;heheda&quot;)); return &quot;ok&quot;; &#125; //修改一个用户 @GetMapping(&quot;/updateEmp&quot;) public String updateEmp()&#123; empMapper.updateEmp(new Emp(1234,&quot;heihei&quot;)); return &quot;ok&quot;; &#125; //根据id删除用户 @GetMapping(&quot;/deleteEmp&quot;) public String deleteEmp()&#123; empMapper.deleteEmp(1234); return &quot;ok&quot;; &#125;&#125; 9、测试即可","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://aner1001.gitee.io/tags/Springboot/"}]},{"title":"Springboot学习笔记4-thymeleaf","slug":"技术知识/Java/框架/Springboot/Springboot学习笔记4-thymeleaf","date":"2021-03-03T11:10:45.000Z","updated":"2021-03-03T11:10:45.000Z","comments":true,"path":"posts/2021/03/03/dda4b76dd228/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/03/dda4b76dd228/","excerpt":"","text":"thymeleaf模板引擎的使用 ​ 在早期开发的时候，我们完成的都是静态页面也就是html页面，随着时间轴的发展，慢慢的引入了jsp页面，当在后端服务查询到数据之后可以转发到jsp页面，可以轻松的使用jsp页面来实现数据的显示及交互，jsp有非常强大的功能，但是，在使用springboot的时候，整个项目是以jar包的方式运行而不是war包，而且还嵌入了tomcat容器，因此，在默认情况下是不支持jsp页面的。如果直接以纯静态页面的方式会给我们的开发带来很大的麻烦，springboot推荐使用模板引擎。 ​ 模板引擎有很多种，jsp,freemarker,thymeleaf，模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些值，从哪来呢，我们来组装一些数据，我们把这些数据找到。然后把这个模板和这个数据交给我们模板引擎，模板引擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只不过不同的模板引擎语法不同而已，下面重点学习下springboot推荐使用的thymeleaf模板引擎，语法简单且功能强大 ☀1、thymeleaf的介绍 官网地址：https://www.thymeleaf.org/ thymeleaf在github的地址：https://github.com/thymeleaf/thymeleaf 中文网站：https://raledong.gitbooks.io/using-thymeleaf/content/ 导入依赖： 123456789&lt;!--thymeleaf模板--&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;&lt;/dependency&gt; 在springboot中有专门的thymeleaf配置类：ThymeleafProperties 123456789101112131415161718192021222324252627282930313233@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8; public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;; public static final String DEFAULT_SUFFIX = &quot;.html&quot;; /** * Whether to check that the template exists before rendering it. */ private boolean checkTemplate = true; /** * Whether to check that the templates location exists. */ private boolean checkTemplateLocation = true; /** * Prefix that gets prepended to view names when building a URL. */ private String prefix = DEFAULT_PREFIX; /** * Suffix that gets appended to view names when building a URL. */ private String suffix = DEFAULT_SUFFIX; /** * Template mode to be applied to templates. See also Thymeleaf&#x27;s TemplateMode enum. */ private String mode = &quot;HTML&quot;; /** * Template files encoding. */ private Charset encoding = DEFAULT_ENCODING; /** * Whether to enable template caching. */ private boolean cache = true; ☀2、thymeleaf使用模板 在java代码中写入如下代码： 123456@RequestMapping(&quot;/hello&quot;)public String hello(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;Hello&quot;); //classpath:/templates/hello.html return &quot;hello&quot;;&#125; html页面中写入如下代码： 1234567&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;div th:text=&quot;$&#123;msg&#125;&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ☀3、thymeleaf的表达式语法 123456789101112131415161718192021222324252627282930Simple expressions: Variable Expressions: $&#123;...&#125; Selection Variable Expressions: *&#123;...&#125; Message Expressions: #&#123;...&#125; Link URL Expressions: @&#123;...&#125; Fragment Expressions: ~&#123;...&#125;Literals Text literals: &#x27;one text&#x27;, &#x27;Another one!&#x27;,… Number literals: 0, 34, 3.0, 12.3,… Boolean literals: true, false Null literal: null Literal tokens: one, sometext, main,…Text operations: String concatenation: + Literal substitutions: |The name is $&#123;name&#125;|Arithmetic operations: Binary operators: +, -, *, /, % Minus sign (unary operator): - Boolean operations: Binary operators: and, or Boolean negation (unary operator): !, notComparisons and equality: Comparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le) Equality operators: ==, != (eq, ne) Conditional operators: If-then: (if) ? (then) If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)Special tokens: No-Operation: _ 指令： Thymeleaf崇尚模板是纯正的html代码，脱离模板引擎，在纯静态环境也可以直接运行。现在如果我们直接在html中编写 $&#123;&#125;这样的表达式，显然在静态环境下就会出错，这不符合Thymeleaf的理念。 Thymeleaf中所有的表达式都需要写在&quot;指令&quot;中，指令是HTML5中的自定义属性，在Thymeleaf中所有指令都是以th:开头。因为表达式$&#123;user.name&#125;是写在自定义属性中，因此在静态环境下，表达式的内容会被当做是普通字符串，浏览器会自动忽略这些指令，这样就不会报错了。 如果我们不经过SpringMVC，而是直接用浏览器打开编写的页面：在静态环境下,th指令不会被识别，但是也不会报错，而是显示标签的缺省默认值：“请跟我来” 指令的设计，正是Thymeleaf的高明之处，也是它优于其它模板引擎的原因。动静结合的设计，使得无论是前端开发人员还是后端开发人员可以完美契合。 向下兼容 但是要注意，如果浏览器不支持Html5怎么办？ 如果不支持这种th:的命名空间写法，那么可以把th:text换成 data-th-text，Thymeleaf也可以兼容。 变量_ognl表达式的语法糖 刚才获取变量值，我们使用的是经典的对象.属性名方式。但有些情况下，我们的属性名可能本身也是变量，怎么办？ ognl提供了类似js的语法方式： 例如：$&#123;user.name&#125; 可以写作$&#123;user['name']&#125; ☀4、thymeleaf实例演示 ☀1、th的常用属性值 ​ 一、th:text ：设置当前元素的文本内容，相同功能的还有th:utext，两者的区别在于前者不会转义html标签，后者会。优先级不高：order=7 ​ 二、th:value：设置当前元素的value值，类似修改指定属性的还有th:src，th:href。优先级不高：order=6 ​ 三、th:each：遍历循环元素，和th:text或th:value一起使用。注意该属性修饰的标签位置，详细往后看。优先级很高：order=2 ​ 四、th:if：条件判断，类似的还有th:unless，th:switch，th:case。优先级较高：order=3 ​ 五、th:insert：代码块引入，类似的还有th:replace，th:include，三者的区别较大，若使用不恰当会破坏html结构，常用于公共代码块提取的场景。优先级最高：order=1 ​ 六、th:fragment：定义代码块，方便被th:insert引用。优先级最低：order=8 ​ 七、th:object：声明变量，一般和*{}一起配合使用，达到偷懒的效果。优先级一般：order=4 ​ 八、th:attr：修改任意属性，实际开发中用的较少，因为有丰富的其他th属性帮忙，类似的还有th:attrappend，th:attrprepend。优先级一般：order=5 thymeleaf.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text=&quot;$&#123;thText&#125;&quot;&gt;&lt;/p&gt; &lt;p th:utext=&quot;$&#123;thUText&#125;&quot;&gt;&lt;/p&gt; &lt;input type=&quot;text&quot; th:value=&quot;$&#123;thValue&#125;&quot;&gt; &lt;div th:each=&quot;message:$&#123;thEach&#125;&quot;&gt; &lt;p th:text=&quot;$&#123;message&#125;&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p th:text=&quot;$&#123;message&#125;&quot; th:each=&quot;message:$&#123;thEach&#125;&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;p th:text=&quot;$&#123;thIf&#125;&quot; th:if=&quot;$&#123;not #strings.isEmpty(thIf)&#125;&quot;&gt;&lt;/p&gt; &lt;div th:object=&quot;$&#123;thObject&#125;&quot;&gt; &lt;p&gt;name:&lt;span th:text=&quot;*&#123;name&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;age:&lt;span th:text=&quot;*&#123;age&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;gender:&lt;span th:text=&quot;*&#123;gender&#125;&quot;/&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ThymeleafController.java 12345678910111213141516171819202122package com.mashibing.controller;import com.mashibing.entity.Person;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ThymeleafController &#123; @RequestMapping(&quot;thymeleaf&quot;) public String thymeleaf(ModelMap map)&#123; map.put(&quot;thText&quot;,&quot;th:text设置文本内容 &lt;b&gt;加粗&lt;/b&gt;&quot;); map.put(&quot;thUText&quot;,&quot;th:utext 设置文本内容 &lt;b&gt;加粗&lt;/b&gt;&quot;); map.put(&quot;thValue&quot;,&quot;thValue 设置当前元素的value值&quot;); map.put(&quot;thEach&quot;,&quot;Arrays.asList(\\&quot;th:each\\&quot;, \\&quot;遍历列表\\&quot;)&quot;); map.put(&quot;thIf&quot;,&quot;msg is not null&quot;); map.put(&quot;thObject&quot;,new Person(&quot;zhangsan&quot;,12,&quot;男&quot;)); return &quot;thymeleaf&quot;; &#125;&#125; ☀2、标准表达式语法 ​ ${…} 变量表达式，Variable Expressions ​ *{…} 选择变量表达式，Selection Variable Expressions ​ 一、可以获取对象的属性和方法 ​ 二、可以使用ctx，vars，locale，request，response，session，servletContext内置对象 12session.setAttribute(&quot;user&quot;,&quot;zhangsan&quot;);th:text=&quot;$&#123;session.user&#125;&quot; ​ 三、可以使用dates，numbers，strings，objects，arrays，lists，sets，maps等内置方法 standardExpression.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!--一、strings：字符串格式化方法，常用的Java方法它都有。比如：equals，equalsIgnoreCase，length，trim，toUpperCase，toLowerCase，indexOf，substring，replace，startsWith，endsWith，contains，containsIgnoreCase等二、numbers：数值格式化方法，常用的方法有：formatDecimal等三、bools：布尔方法，常用的方法有：isTrue，isFalse等四、arrays：数组方法，常用的方法有：toArray，length，isEmpty，contains，containsAll等五、lists，sets：集合方法，常用的方法有：toList，size，isEmpty，contains，containsAll，sort等六、maps：对象方法，常用的方法有：size，isEmpty，containsKey，containsValue等七、dates：日期方法，常用的方法有：format，year，month，hour，createNow等--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;thymeleaf内置方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;#strings &lt;/h3&gt; &lt;div th:if=&quot;$&#123;not #strings.isEmpty(Str)&#125;&quot; &gt; &lt;p&gt;Old Str : &lt;span th:text=&quot;$&#123;Str&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;toUpperCase : &lt;span th:text=&quot;$&#123;#strings.toUpperCase(Str)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;toLowerCase : &lt;span th:text=&quot;$&#123;#strings.toLowerCase(Str)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;equals : &lt;span th:text=&quot;$&#123;#strings.equals(Str, &#x27;blog&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;equalsIgnoreCase : &lt;span th:text=&quot;$&#123;#strings.equalsIgnoreCase(Str, &#x27;blog&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;indexOf : &lt;span th:text=&quot;$&#123;#strings.indexOf(Str, &#x27;r&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;substring : &lt;span th:text=&quot;$&#123;#strings.substring(Str, 2, 4)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;replace : &lt;span th:text=&quot;$&#123;#strings.replace(Str, &#x27;it&#x27;, &#x27;IT&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;startsWith : &lt;span th:text=&quot;$&#123;#strings.startsWith(Str, &#x27;it&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text=&quot;$&#123;#strings.contains(Str, &#x27;IT&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#numbers &lt;/h3&gt; &lt;div&gt; &lt;p&gt;formatDecimal 整数部分随意，小数点后保留两位，四舍五入: &lt;span th:text=&quot;$&#123;#numbers.formatDecimal(Num, 0, 2)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;formatDecimal 整数部分保留五位数，小数点后保留两位，四舍五入: &lt;span th:text=&quot;$&#123;#numbers.formatDecimal(Num, 5, 2)&#125;&quot;/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#bools &lt;/h3&gt; &lt;div th:if=&quot;$&#123;#bools.isTrue(Bool)&#125;&quot;&gt; &lt;p th:text=&quot;$&#123;Bool&#125;&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#arrays &lt;/h3&gt; &lt;div th:if=&quot;$&#123;not #arrays.isEmpty(Array)&#125;&quot;&gt; &lt;p&gt;length : &lt;span th:text=&quot;$&#123;#arrays.length(Array)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text=&quot;$&#123;#arrays.contains(Array,2)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;containsAll : &lt;span th:text=&quot;$&#123;#arrays.containsAll(Array, Array)&#125;&quot;/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#lists &lt;/h3&gt; &lt;div th:if=&quot;$&#123;not #lists.isEmpty(List)&#125;&quot;&gt; &lt;p&gt;size : &lt;span th:text=&quot;$&#123;#lists.size(List)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;contains : &lt;span th:text=&quot;$&#123;#lists.contains(List, 0)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;sort : &lt;span th:text=&quot;$&#123;#lists.sort(List)&#125;&quot;/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#maps &lt;/h3&gt; &lt;div th:if=&quot;$&#123;not #maps.isEmpty(hashMap)&#125;&quot;&gt; &lt;p&gt;size : &lt;span th:text=&quot;$&#123;#maps.size(hashMap)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;containsKey : &lt;span th:text=&quot;$&#123;#maps.containsKey(hashMap, &#x27;thName&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;containsValue : &lt;span th:text=&quot;$&#123;#maps.containsValue(hashMap, &#x27;#maps&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;/div&gt; &lt;h3&gt;#dates &lt;/h3&gt; &lt;div&gt; &lt;p&gt;format : &lt;span th:text=&quot;$&#123;#dates.format(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;custom format : &lt;span th:text=&quot;$&#123;#dates.format(Date, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;day : &lt;span th:text=&quot;$&#123;#dates.day(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;month : &lt;span th:text=&quot;$&#123;#dates.month(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;monthName : &lt;span th:text=&quot;$&#123;#dates.monthName(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;year : &lt;span th:text=&quot;$&#123;#dates.year(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;dayOfWeekName : &lt;span th:text=&quot;$&#123;#dates.dayOfWeekName(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;hour : &lt;span th:text=&quot;$&#123;#dates.hour(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;minute : &lt;span th:text=&quot;$&#123;#dates.minute(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;second : &lt;span th:text=&quot;$&#123;#dates.second(Date)&#125;&quot;/&gt;&lt;/p&gt; &lt;p&gt;createNow : &lt;span th:text=&quot;$&#123;#dates.createNow()&#125;&quot;/&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ThymeleafController.java 1234567891011121314@RequestMapping(&quot;standardExpression&quot;) public String standardExpression(ModelMap map)&#123; map.put(&quot;Str&quot;, &quot;Blog&quot;); map.put(&quot;Bool&quot;, true); map.put(&quot;Array&quot;, new Integer[]&#123;1,2,3,4&#125;); map.put(&quot;List&quot;, Arrays.asList(1,3,2,4,0)); Map hashMap = new HashMap(); hashMap.put(&quot;thName&quot;, &quot;$&#123;#...&#125;&quot;); hashMap.put(&quot;desc&quot;, &quot;变量表达式内置方法&quot;); map.put(&quot;Map&quot;, hashMap); map.put(&quot;Date&quot;, new Date()); map.put(&quot;Num&quot;, 888.888D); return &quot;standardExpression&quot;; &#125; ​ @{…} 链接表达式，Link URL Expressions 12345678910111213&lt;!--不管是静态资源的引用，form表单的请求，凡是链接都可以用@&#123;...&#125; 。这样可以动态获取项目路径，即便项目名变了，依然可以正常访问链接表达式结构无参：@&#123;/xxx&#125;有参：@&#123;/xxx(k1=v1,k2=v2)&#125; 对应url结构：xxx?k1=v1&amp;k2=v2引入本地资源：@&#123;/项目本地的资源路径&#125;引入外部资源：@&#123;/webjars/资源在jar包中的路径&#125;--&gt;&lt;link th:href=&quot;@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;&lt;link th:href=&quot;@&#123;/main/css/123.css&#125;&quot; rel=&quot;stylesheet&quot;&gt;&lt;form class=&quot;form-login&quot; th:action=&quot;@&#123;/user/login&#125;&quot; th:method=&quot;post&quot; &gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/login.html(l=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt;&lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@&#123;/login.html(l=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt; ​ #{…} 消息表达式，Message Expressions 123&lt;!--消息表达式一般用于国际化的场景。结构：th:text=&quot;#&#123;msg&#125;&quot;--&gt; ​ ~{…} 代码块表达式，Fragment Expressions fragment.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!--支持两种语法结构推荐：~&#123;templatename::fragmentname&#125;支持：~&#123;templatename::#id&#125;templatename：模版名，Thymeleaf会根据模版名解析完整路：/resources/templates/templatename.html，要注意文件的路径。fragmentname：片段名，Thymeleaf通过th:fragment声明定义代码块，即：th:fragment=&quot;fragmentname&quot;id：HTML的id选择器，使用时要在前面加上#号，不支持class选择器。代码块表达式的使用代码块表达式需要配合th属性（th:insert，th:replace，th:include）一起使用。th:insert：将代码块片段整个插入到使用了th:insert的HTML标签中，th:replace：将代码块片段整个替换使用了th:replace的HTML标签中，th:include：将代码块片段包含的内容插入到使用了th:include的HTML标签中，--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--th:fragment定义代码块标识--&gt;&lt;footer th:fragment=&quot;copy&quot;&gt; 2019 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!--三种不同的引入方式--&gt;&lt;div th:insert=&quot;fragment::copy&quot;&gt;&lt;/div&gt;&lt;div th:replace=&quot;fragment::copy&quot;&gt;&lt;/div&gt;&lt;div th:include=&quot;fragment::copy&quot;&gt;&lt;/div&gt;&lt;!--th:insert是在div中插入代码块，即多了一层div--&gt;&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;!--th:replace是将代码块代替当前div，其html结构和之前一致--&gt;&lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!--th:include是将代码块footer的内容插入到div中，即少了一层footer--&gt;&lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; ☀5、国际化的配置 ​ 在很多应用场景下，我们需要实现页面的国际化，springboot对国际化有很好的支持， 下面来演示对应的效果。 1、在idea中设置统一的编码格式，file-&gt;settings-&gt;Editors-&gt;File Encoding,选择编码格式为utf-8 2、在resources资源文件下创建一个i8n的目录，创建一个login.properties的文件，还有login_zh_CN.properties,idea会自动识别国际化操作 3、创建三个不同的文件，名称分别是：login.properties，login_en_US.properties，login_zh_CN.properties 内容如下： 123456789101112131415#login.propertieslogin.password=密码1login.remmber=记住我1login.sign=登录1login.username=用户名1#login_en_US.propertieslogin.password=Passwordlogin.remmber=Remember Melogin.sign=Sign Inlogin.username=Username#login_zh_CN.propertieslogin.password=密码~login.remmber=记住我~login.sign=登录~login.username=用户名~ 4、配置国际化的资源路径 123spring: messages: basename: i18n/login 5、编写html页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556初始html页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;label &gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot; &gt; &lt;label &gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; &gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot;/&gt; Remember Me &lt;/label&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=&quot;submit&quot;&gt;Sign in&lt;/button&gt; &lt;br&gt; &lt;br&gt; &lt;a&gt;中文&lt;/a&gt; &lt;a&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;修改后的页面&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;label th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#&#123;login.username&#125;&quot;&gt; &lt;label th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot;/&gt; [[#&#123;login.remmber&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=&quot;submit&quot; th:text=&quot;#&#123;login.sign&#125;&quot;&gt;Sign in&lt;/button&gt; &lt;br&gt; &lt;br&gt; &lt;a&gt;中文&lt;/a&gt; &lt;a&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 可以看到通过浏览器的切换语言已经能够实现，想要通过超链接实现的话，如下所示： 添加WebMVCConfig.java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.mashibing.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.util.StringUtils;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;@Configurationpublic class WebMVCConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;); registry.addViewController(&quot;/login.html&quot;).setViewName(&quot;login&quot;); &#125; @Bean public LocaleResolver localeResolver()&#123; return new NativeLocaleResolver(); &#125; protected static class NativeLocaleResolver implements LocaleResolver&#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String language = request.getParameter(&quot;language&quot;); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(language))&#123; String[] split = language.split(&quot;_&quot;); locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; &#125; &#125;&#125; login.html页面修改为： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;/&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;label th:text=&quot;#&#123;login.username&#125;&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Username&quot; th:placeholder=&quot;#&#123;login.username&#125;&quot;&gt; &lt;label th:text=&quot;#&#123;login.password&#125;&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#&#123;login.password&#125;&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;div&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot;/&gt; [[#&#123;login.remmber&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;br&gt; &lt;button type=&quot;submit&quot; th:text=&quot;#&#123;login.sign&#125;&quot;&gt;Sign in&lt;/button&gt; &lt;br&gt; &lt;br&gt; &lt;a th:href=&quot;@&#123;/login.html(language=&#x27;zh_CN&#x27;)&#125;&quot;&gt;中文&lt;/a&gt; &lt;a th:href=&quot;@&#123;/login.html(language=&#x27;en_US&#x27;)&#125;&quot;&gt;English&lt;/a&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 国际化的源码解释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//MessageSourceAutoConfigurationpublic class MessageSourceAutoConfiguration &#123; private static final Resource[] NO_RESOURCES = new Resource[0]; public MessageSourceAutoConfiguration() &#123; &#125; @Bean @ConfigurationProperties(prefix = &quot;spring.messages&quot;) //我们的配置文件可以直接放在类路径下叫： messages.properties， 就可以进行国际化操作了 public MessageSourceProperties messageSourceProperties() &#123; return new MessageSourceProperties(); &#125; @Bean public MessageSource messageSource(MessageSourceProperties properties) &#123; ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource(); if (StringUtils.hasText(properties.getBasename())) &#123; //设置国际化文件的基础名（去掉语言国家代码的） messageSource.setBasenames(StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename()))); &#125; if (properties.getEncoding() != null) &#123; messageSource.setDefaultEncoding(properties.getEncoding().name()); &#125; messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale()); Duration cacheDuration = properties.getCacheDuration(); if (cacheDuration != null) &#123; messageSource.setCacheMillis(cacheDuration.toMillis()); &#125; messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat()); messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage()); return messageSource; &#125;&#125;//WebMvcAutoConfiguration @Bean @ConditionalOnMissingBean @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;locale&quot;) public LocaleResolver localeResolver() &#123; if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;//AcceptHeaderLocaleResolver @Override public Locale resolveLocale(HttpServletRequest request) &#123; Locale defaultLocale = getDefaultLocale(); if (defaultLocale != null &amp;&amp; request.getHeader(&quot;Accept-Language&quot;) == null) &#123; return defaultLocale; &#125; Locale requestLocale = request.getLocale(); List&lt;Locale&gt; supportedLocales = getSupportedLocales(); if (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123; return requestLocale; &#125; Locale supportedLocale = findSupportedLocale(request, supportedLocales); if (supportedLocale != null) &#123; return supportedLocale; &#125; return (defaultLocale != null ? defaultLocale : requestLocale); &#125;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://aner1001.gitee.io/tags/Springboot/"}]},{"title":"个人所得税年度汇算经验","slug":"生活知识/经验感悟/个人所得税年度汇算经验","date":"2021-03-03T06:01:12.000Z","updated":"2021-03-03T06:01:12.000Z","comments":true,"path":"posts/2021/03/03/77f494b11bb0/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/03/77f494b11bb0/","excerpt":"","text":"个人所得税年度汇算,奖金计算方式选择，选择算下来高的那个。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"税收","slug":"税收","permalink":"http://aner1001.gitee.io/tags/%E7%A8%8E%E6%94%B6/"}]},{"title":"Springboot学习笔记3-Springboot web开发","slug":"技术知识/Java/框架/Springboot/Springboot学习笔记3-Springboot-web开发","date":"2021-03-03T05:26:31.000Z","updated":"2021-03-03T05:26:31.000Z","comments":true,"path":"posts/2021/03/03/f4ae1b183518/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/03/f4ae1b183518/","excerpt":"springboot在开发web项目的时候具备天然的优势，现在的很多企业级开发都是依托于springboot的。","text":"springboot在开发web项目的时候具备天然的优势，现在的很多企业级开发都是依托于springboot的。 使用springboot的步骤： ​ 1、创建一个SpringBoot应用，选择我们需要的模块，SpringBoot就会默认将我们的需要的模块自动配置好。 ​ 2、手动在配置文件中配置部分配置项目就可以运行起来了。 ​ 3、专注编写业务代码，不需要考虑以前那样一大堆的配置了。 ☀1、springboot整合servlet ​ 很多同学在刚接触web开发的时候第一个接触的都是servlet，下面我们来使用springboot整合servlet ​ （1）编写servlet类 12345678@WebServlet(name = &quot;myServlet&quot;,urlPatterns = &quot;/srv&quot;)public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;111&quot;); super.doGet(req, resp); &#125;&#125; ​ （2）在启动类上添加如下配置 12345678910111213141516171819@SpringBootApplication@ServletComponentScanpublic class ConfigApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigApplication.class, args); &#125; /* 或者启动如下方式，servlet上不需要添加注解 @Bean public ServletRegistrationBean&lt;MyServlet&gt; getServletRegistrationBean()&#123; ServletRegistrationBean&lt;MyServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new MyServlet()); ArrayList&lt;String&gt; url = new ArrayList&lt;&gt;(); url.add(&quot;/srv&quot;); bean.setUrlMappings(url); bean.setLoadOnStartup(1); return bean; &#125; */&#125; ​ （3）编写filter类 123456789101112131415161718@WebFilter(filterName = &quot;MyFilter&quot;, urlPatterns = &quot;/filter&quot;)public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println(&quot;init&quot;); &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println(&quot;filter&quot;); chain.doFilter(request,response); &#125; @Override public void destroy() &#123; System.out.println(&quot;destory&quot;); &#125;&#125; ​ （4）编写监听器 ​ listener是servlet规范定义的一种特殊类，用于监听servletContext,HttpSession和ServletRequest等域对象的创建和销毁事件。监听域对象的属性发生修改的事件，用于在事件发生前、发生后做一些必要的处理。可用于以下方面：1、统计在线人数和在线用户2、系统启动时加载初始化信息3、统计网站访问量4、记录用户访问路径。 编写监听器类 123456789101112131415161718192021package com.mashibing.config;import javax.servlet.http.HttpSessionEvent;import javax.servlet.http.HttpSessionListener;public class MyHttpSessionListener implements HttpSessionListener &#123; public static int online=0; @Override public void sessionCreated(HttpSessionEvent se) &#123; System.out.println(&quot;创建session&quot;); online++; &#125; @Override public void sessionDestroyed(HttpSessionEvent se) &#123; System.out.println(&quot;销毁session&quot;); &#125;&#125; 添加到配置类 1234567891011121314151617181920package com.mashibing.config;import org.springframework.boot.web.servlet.ServletListenerRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.LocaleResolver;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Bean public ServletListenerRegistrationBean listenerRegist()&#123; ServletListenerRegistrationBean srb = new ServletListenerRegistrationBean(); srb.setListener(new MyHttpSessionListener()); System.out.println(&quot;listener&quot;); return srb; &#125;&#125; 添加控制层代码 12345678910111213141516171819202122232425package com.mashibing.controller;import com.mashibing.config.MyHttpSessionListener;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;@Controllerpublic class ThymeleafController &#123; @RequestMapping(&quot;/login&quot;) public String login(HttpServletRequest request)&#123; HttpSession session = request.getSession(true); return &quot;login&quot;; &#125; @RequestMapping(&quot;online&quot;) @ResponseBody public String online()&#123; return &quot;当前在线人数：&quot;+MyHttpSessionListener.online +&quot;人&quot;; &#125;&#125; 先发送login请求，然后再发送online的请求 ☀2、静态资源的配置 ​ 默认情况下，Spring Boot 将在 classpath 或者 ServletContext 根目录下从名为 /static （/public、/resources 或 /META-INF/resources）目录中服务静态内容。它使用了 Spring MVC 的 ResourceHttpRequestHandler，因此您可以通过添加自己的 WebMvcConfigurerAdapter 并重写 addResourceHandlers 方法来修改此行为。 1234567891011121314151617181920@Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; if (!this.resourceProperties.isAddMappings()) &#123; logger.debug(&quot;Default resource handling disabled&quot;); return; &#125; Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) &#123; customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); &#125; &#125; （1）加载webjars文件 ​ 在pom文件中添加jquery的相关依赖，直接可以通过浏览器访问到http://localhost:8080/webjars/jquery/3.4.1/jquery.js 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; （2）加载静态资源 ​ 当查找静态资源的时候能够发现静态资源的路径是/**，会去ResourceProperties这个类，可以看到对应的资源目录。 12345678910111213141516171819@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)public class ResourceProperties &#123; private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; /** * Locations of static resources. Defaults to classpath:[/META-INF/resources/, * /resources/, /static/, /public/]. */ private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; private String[] appendSlashIfNecessary(String[] staticLocations) &#123; String[] normalized = new String[staticLocations.length]; for (int i = 0; i &lt; staticLocations.length; i++) &#123; String location = staticLocations[i]; normalized[i] = location.endsWith(&quot;/&quot;) ? location : location + &quot;/&quot;; &#125; return normalized; &#125; ​ 可以看到静态资源的目录一共有如下几个： ​ “classpath:/resources/” ​ “classpath:/static/” ​ “classpath:/public/” （3）首页的配置信息 1234567891011121314151617@Beanpublic WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext, FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) &#123; WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping( new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern()); welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider)); return welcomePageHandlerMapping; &#125; private Optional&lt;Resource&gt; getWelcomePage() &#123; String[] locations = getResourceLocations(this.resourceProperties.getStaticLocations()); return Arrays.stream(locations).map(this::getIndexHtml).filter(this::isReadable).findFirst(); &#125;private Resource getIndexHtml(String location) &#123; return this.resourceLoader.getResource(location + &quot;index.html&quot;); &#125; ☀3、springmvc的扩展 ​ springmvc框架是一个mvc的web框架，springmvc允许创建@controller和@RestController bean来处理传入的HTTP请求，控制器种的方法通过@RequestMapping注解映射到HTTP。 ​ Springboot提供了适用于大多数Springmvc应用的自动配置。 12345678引入 ContentNegotiatingViewResolver 和 BeanNameViewResolver bean视图解析器。支持服务静态资源，包括对 WebJar 的支持。自动注册 Converter（网页传入的数据封装成对象，完成数据类型的转化）、GenericConverter 和 Formatter bean（将日期转换成规定的格式）。支持 HttpMessageConverter，用来转换http请求和响应。自动注册 MessageCodesResolver，定义错误代码生成规则。支持静态 index.html。支持自定义 Favicon。自动使用 ConfigurableWebBindingInitializer bean，将请求树绑定到javaBean中。 自动配置了ViewResolver，就是我们之前学习的SpringMVC的视图解析器：即根据方法的返回值取得视图对象（View），然后由视图对象决定如何渲染（转发，重定向）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//WebMvcAutoConfiguration@Bean //我们在这里确实看到已经给容器中注册了一个bean @ConditionalOnBean(&#123;ViewResolver.class&#125;) @ConditionalOnMissingBean( name = &#123;&quot;viewResolver&quot;&#125;, value = &#123;ContentNegotiatingViewResolver.class&#125; ) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) &#123; ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager((ContentNegotiationManager)beanFactory.getBean(ContentNegotiationManager.class)); resolver.setOrder(-2147483648); return resolver; &#125;//ContentNegotiatingViewResolver@Nullable public View resolveViewName(String viewName, Locale locale) throws Exception &#123; RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, &quot;No current ServletRequestAttributes&quot;); List&lt;MediaType&gt; requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) &#123; //获取候选的视图对象 List&lt;View&gt; candidateViews = this.getCandidateViews(viewName, locale, requestedMediaTypes); //选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) &#123; return bestView; &#125; &#125; String mediaTypeInfo = this.logger.isDebugEnabled() &amp;&amp; requestedMediaTypes != null ? &quot; given &quot; + requestedMediaTypes.toString() : &quot;&quot;; if (this.useNotAcceptableStatusCode) &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(&quot;Using 406 NOT_ACCEPTABLE&quot; + mediaTypeInfo); &#125; return NOT_ACCEPTABLE_VIEW; &#125; else &#123; this.logger.debug(&quot;View remains unresolved&quot; + mediaTypeInfo); return null; &#125; &#125;//getCandidateViewsprivate List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes) throws Exception &#123; List&lt;View&gt; candidateViews = new ArrayList&lt;&gt;(); if (this.viewResolvers != null) &#123; Assert.state(this.contentNegotiationManager != null, &quot;No ContentNegotiationManager set&quot;); for (ViewResolver viewResolver : this.viewResolvers) &#123; View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; candidateViews.add(view); &#125; for (MediaType requestedMediaType : requestedMediaTypes) &#123; List&lt;String&gt; extensions = this.contentNegotiationManager.resolveFileExtensions(requestedMediaType); for (String extension : extensions) &#123; String viewNameWithExtension = viewName + &#x27;.&#x27; + extension; view = viewResolver.resolveViewName(viewNameWithExtension, locale); if (view != null) &#123; candidateViews.add(view); &#125; &#125; &#125; &#125; &#125; if (!CollectionUtils.isEmpty(this.defaultViews)) &#123; candidateViews.addAll(this.defaultViews); &#125; return candidateViews; &#125;//initServletContext@Override protected void initServletContext(ServletContext servletContext) &#123; Collection&lt;ViewResolver&gt; matchingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values(); if (this.viewResolvers == null) &#123; this.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.size()); for (ViewResolver viewResolver : matchingBeans) &#123; if (this != viewResolver) &#123; this.viewResolvers.add(viewResolver); &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; this.viewResolvers.size(); i++) &#123; ViewResolver vr = this.viewResolvers.get(i); if (matchingBeans.contains(vr)) &#123; continue; &#125; String name = vr.getClass().getName() + i; obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name); &#125; &#125; AnnotationAwareOrderComparator.sort(this.viewResolvers); this.cnmFactoryBean.setServletContext(servletContext); &#125; 通过上面的代码分析，我们知道了springboot是在容器中去找视图解析器，因此，我们可以给容器自定义添加视图解析器,这个类会帮我们将他组合起来。 12345678910111213//自定义视图解析器 @Bean //放到bean中 public ViewResolver myViewResolver()&#123; return new MyViewResolver(); &#125; //我们写一个静态内部类，视图解析器就需要实现ViewResolver接口 private static class MyViewResolver implements ViewResolver&#123; @Override public View resolveViewName(String s, Locale locale) throws Exception &#123; return null; &#125; &#125; 扩展使用springmvc 1234567891011121314151617/*如果您想保留 Spring Boot MVC 的功能，并且需要添加其他 MVC 配置（interceptor、formatter 和视图控制器等），可以添加自己的 WebMvcConfigurerAdapter 类型的 @Configuration 类，但不能带 @EnableWebMvc 注解。如果您想自定义 RequestMappingHandlerMapping、RequestMappingHandlerAdapter 或者 ExceptionHandlerExceptionResolver 实例，可以声明一个 WebMvcRegistrationsAdapter 实例来提供这些组件。如果您想完全掌控 Spring MVC，可以添加自定义注解了 @EnableWebMvc 的 @Configuration 配置类*/package com.mashibing.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;@Configurationpublic class MyMvcConfig implements WebMvcConfigurer &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/msb&quot;).setViewName(&quot;success&quot;); &#125;&#125; 注意：将html添加到添加到Templates中,需要添加模板引擎。 12345678&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-java8time&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://aner1001.gitee.io/tags/Springboot/"}]},{"title":"Springboot学习笔记2-配置文件","slug":"技术知识/Java/框架/Springboot/Springboot学习笔记2-配置文件","date":"2021-03-03T05:16:43.000Z","updated":"2021-03-03T05:16:43.000Z","comments":true,"path":"posts/2021/03/03/22191f4e41ce/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/03/22191f4e41ce/","excerpt":"​ 在之前的项目开发中，我们可以使用xml,properties进行相关的配置，这种配置方式比较简单，但是在应对复杂的商业需求下，多环境和编程化的配置无法得到满足，因此springboot为我们提供了YAML的配置方式丰富功能和简化开发。","text":"​ 在之前的项目开发中，我们可以使用xml,properties进行相关的配置，这种配置方式比较简单，但是在应对复杂的商业需求下，多环境和编程化的配置无法得到满足，因此springboot为我们提供了YAML的配置方式丰富功能和简化开发。 ☀1、Properties配置详解 ​ 通常情况下，我们可以使用properties文件进行相关的配置。 ​ （1）在resources目录下创建application.properties 1234person.name=zhangsanperson.age=12person.gender=男person.desc=my name is $&#123;person.name&#125;,my age is $&#123;person.age&#125; ​ （2）创建对应的实体类对象 1234567891011121314151617181920212223242526272829@Componentpublic class Person &#123; @Value(&quot;$&#123;person.name&#125;&quot;) private String name; @Value(&quot;$&#123;person.age&#125;&quot;) private int age; private String sex; @Value(&quot;$&#123;person.desc&#125;&quot;) private String desc; public Person() &#123; &#125; public Person(String name, int age, String sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, desc=&#x27;&quot; + desc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ​ （3）创建对应的测试类 1234567891011@SpringBootTestclass ConfigApplicationTests &#123; @Autowired Person person; @Test void contextLoads() &#123; System.out.println(person); &#125;&#125; ​ 可以在properties文件中使用随机数 ​ （1）在application.properties文件中添加如下属性 123456my.secret=$&#123;random.value&#125;my.number=$&#123;random.int&#125;my.bignumber=$&#123;random.long&#125;my.uuid=$&#123;random.uuid&#125;my.number.less.than.ten=$&#123;random.int(10)&#125;my.number.in.range=$&#123;random.int[1024,65536]&#125; ​ （2）创建对应的实体类 123456789101112131415161718192021222324252627@Componentpublic class My &#123; @Value(&quot;$&#123;my.secret&#125;&quot;) private String screct; @Value(&quot;$&#123;my.number&#125;&quot;) private int number; @Value(&quot;$&#123;my.bignumber&#125;&quot;) private long bignumber; @Value(&quot;$&#123;my.uuid&#125;&quot;) private UUID uuid; @Value(&quot;$&#123;my.number.less.than.ten&#125;&quot;) private int lessThanTen; @Value(&quot;$&#123;my.number.in.range&#125;&quot;) private int numberInRangel; @Override public String toString() &#123; return &quot;My&#123;&quot; + &quot;screct=&quot; + screct + &quot;, number=&quot; + number + &quot;, bignumber=&quot; + bignumber + &quot;, uuid=&quot; + uuid + &quot;, lessThanTen=&quot; + lessThanTen + &quot;, numberInRangel=&quot; + numberInRangel + &#x27;&#125;&#x27;; &#125;&#125; ​ （3）创建对应的测试类 12345678910@SpringBootTestclass ConfigApplicationTests &#123; @Autowired My my; @Test void contextLoads() &#123; System.out.println(my); &#125;&#125; ​ 多环境配置 ​ 在实际开发中，我们的一套代码可能会被同时部署到开发、测试、生产等多个服务器中，每个环境中诸如数据库密码等这些个性化配置是避免不了的，虽然我们可以通过自动化运维部署的方式使用外部参数在服务启动时临时替换属性值，但这也意味着运维成本增高。 ​ 1、在resources目录下创建多个配置文件 ​ application-dev.properties ​ application-test.properties ​ application-prod.properties ​ application.properties 1spring.profiles.active=dev/test/prod ☀2、YAML ​ YAML是“YAML Ain’t Markup Language YAML不是一种标记语言”的外语缩写，但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。它是类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。 1234567基本原则：1、大小写敏感2、使用缩进表示层级关系3、禁止使用tab缩进，只能使用空格键4、缩进长度没有限制，只要元素对齐就表示这些元素属于一个层级。5、使用#表示注释6、字符串可以不用引号标注 （1）使用yaml完成多环境配置:application.yaml 12345678910111213spring: profiles: active: test---spring: profiles: devserver: port: 8080---spring: profiles: testserver: port: 8081 （2）使用yaml进行相关参数的设置 12345person: name: zhangsan age: 12 sex: 男 desc: my name is $&#123;person.name&#125;,my age is $&#123;person.age&#125; 对应的实体类对象 123456789101112131415161718192021222324252627282930@Component@ConfigurationProperties(prefix = &quot;person&quot;)public class Person &#123;// @Value(&quot;$&#123;person.name&#125;&quot;) private String name;// @Value(&quot;$&#123;person.age&#125;&quot;) private int age; private String sex;// @Value(&quot;$&#123;person.desc&#125;&quot;) private String desc; public Person() &#123; &#125; public Person(String name, int age, String sex) &#123; this.name = name; this.age = age; this.sex = sex; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, sex=&#x27;&quot; + sex + &#x27;\\&#x27;&#x27; + &quot;, desc=&#x27;&quot; + desc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ☀3、@ConfigurationProperties 与 @Value 对比 功能 @ConfigurationProperties @Value 松散绑定 是 否 元数据支持 是 否 spEL表达式 否 是 ☀属性松散绑定 表示驼峰式、下划线(_)、短横线(-) 标准方式 person.firstName 方式一 大写用- person.first-name 方式二 大写用_ person.first_name","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://aner1001.gitee.io/tags/Springboot/"}]},{"title":"Springboot学习笔记1-介绍与简单使用","slug":"技术知识/Java/框架/Springboot/Springboot学习笔记1-介绍与简单使用","date":"2021-03-02T00:57:04.000Z","updated":"2021-03-02T00:57:04.000Z","comments":true,"path":"posts/2021/03/02/0bb34a8f61f4/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/02/0bb34a8f61f4/","excerpt":"《SpringBoot 2.x》入门：框架介绍与HelloWorld MVC架构思想 使用STS构建SpringBoot项目 使用SpringBoot构建Mvc web项目 MVCWeb项目中的注入 热部署","text":"《SpringBoot 2.x》入门：框架介绍与HelloWorld MVC架构思想 使用STS构建SpringBoot项目 使用SpringBoot构建Mvc web项目 MVCWeb项目中的注入 热部署 ☀介绍 SpringBoot主要解决的是在微服务的架构下简化配置（有快速配置）、前后端分离、快速开发 优点： 提供了快速启动入门 开箱即用、提供默认配置 内嵌容器化web项目 没有冗余代码生成和xml配置要求 ☀运行Demo ☀创建项目 创建SpringBoot项目的几种方式： 官网的Initializr 使用Eclipse、STS、Idea等IDE创建Maven项目并引入依赖 使用STS插件的Spring Initializr创建项目 访问http://start.spring.io/ 进入Spring项目Initializr ​ 生成下载demo.zip ☀导入项目 ☀1.Import一个Maven项目 ☀2.选择要导入的文件 ☀3.项目骨架 ☀启动项目 直接run启动程序里的Main（）方法 安装过STS插件或使用STS可以在项目上右键RunAS-&gt;Spring Boot APP 运行成功提示信息： 如果运行报错，请参照常见问题。 ☀个性化 ☀修改启动banner 在resources目录下新建banner.txt http://www.network-science.de/ascii/ 英文 https://www.degraeve.com/img2txt.php 图片 ☀Eclipse的皮肤 菜单栏中 Help -&gt; EclipseMarketplace 搜索Theme 傻瓜式安装这个，安装完成会提示重启，跟随指引选择喜欢的风格。 ☀简单使用 ☀application.properties 把所有的配置全放在这个文件里，方便统一管理，maven也可以做到 ☀修改tomcat端口 server.port=90 ☀修改项目路径 server.servlet.context-path=/demo ☀多个入口main方法，打包之后找不到入库类 12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.mashibing.MyApp&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ☀HelloWorld ☀RestController RestController = @Controller+@ResponseBody 一个效果 123456789101112131415@RestControllerpublic class MyAppController &#123; @RequestMapping(&quot;/&quot;) public Map&lt;String, String&gt; index() &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(&quot;aaa&quot;, &quot;bbb&quot;); map.put(&quot;aaa&quot;, &quot;bbb&quot;); map.put(&quot;aaa&quot;, &quot;bbb&quot;); map.put(&quot;aaa&quot;, &quot;bbb&quot;); return map; &#125; ☀使用thymeleaf模板引擎 ☀Pom.xml引用 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; ☀Controller代码 12345678910111213@Controllerpublic class IndexController &#123; @RequestMapping(&quot;/&quot;) public String index(ModelMap map) &#123; // 加入一个属性，用来在模板中读取 map.addAttribute(&quot;msg&quot;, &quot;nihao~&quot;); return模板文件的名称，对应src/main/resources/templates/index.html return &quot;index&quot;; &#125;&#125; ☀模板文件代码 1&lt;h1 th:text=&quot;$&#123;msg&#125;&quot;&gt;hi!&lt;/h1&gt; ☀稍微复杂的restful api应用 ☀UserRestfulController 123456789101112131415161718192021UserRestfulController@RequestMapping(&quot;/&quot;)@RestControllerpublic class UserRestfulController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long,User&gt;()); @RequestMapping(value=&quot;/User&quot;,method=RequestMethod.GET) public List&lt;User&gt; getUserList()&#123; ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(users.values()); return list; &#125; @RequestMapping(value=&quot;User&quot;,method=RequestMethod.POST) public String addUser(@ModelAttribute User user) &#123; users.put(user.getId(), user); return &quot;addUser Success&quot;; &#125;&#125; ☀User 1234567public class User &#123; private Long id; private String loginName; private String password; private String nickName; ☀注入Service ☀UserRestfulController 1234567891011121314151617@Autowiredprivate UserService userSrv;@RequestMapping(value=&quot;/User&quot;,method=RequestMethod.GET)public List&lt;User&gt; getUserList()&#123; return userSrv.getUserList();&#125;@RequestMapping(value=&quot;User&quot;,method=RequestMethod.POST)public String addUser(@ModelAttribute User user) &#123; String msg = userSrv.addUser(user); return msg;&#125; ☀UserService 123456789101112131415@Servicepublic class UserService &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long,User&gt;()); public List&lt;User&gt; getUserList() &#123; ArrayList&lt;User&gt; list = new ArrayList&lt;&gt;(users.values()); return list; &#125; public String addUser(User user) &#123; users.put(user.getId(), user); return &quot;addUser Success&quot;; &#125;&#125; ☀前端模板显示 12345678910111213141516171819&lt;h1&gt;User list&lt;/h1&gt;&lt;table&gt; &lt;tr&gt; &lt;th&gt;NAME&lt;/th&gt; &lt;th&gt;loginName&lt;/th&gt; &lt;th&gt;nickName&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;user : $&#123;list&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;user.id&#125;&quot;&gt;id&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.loginName&#125;&quot;&gt;loginName&lt;/td&gt; &lt;td th:text=&quot;$&#123;user.nickName&#125;&quot;&gt;nickName&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;p&gt; &lt;a href=&quot;../home.html&quot; th:href=&quot;@&#123;/&#125;&quot;&gt;Return to home&lt;/a&gt;&lt;/p&gt; ☀常见问题 ☀Pom.xml Springboot项目必须要继承的parnet ☀Pom.xml第一行报错 进入本地库 for /r %i in (*.lastUpdated) do del %i 然后update ☀缺少或包错误 删掉 重新update ☀找不到主类 所有错误都解决后 Jar方式运行 首先得有这个jar包 先clean package 生成jar文件，然后再run main方法 ☀找不到jdk 把jre的路径换成jdk的 ☀启动后自动停止","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://aner1001.gitee.io/tags/Springboot/"}]},{"title":"Mybatis学习笔记4-使用mybatis-plus","slug":"技术知识/Java/框架/Mybatis/Mybatis学习笔记4-使用mybatis-plus","date":"2021-03-01T09:15:33.000Z","updated":"2021-03-01T09:15:33.000Z","comments":true,"path":"posts/2021/03/01/a33259cdd98b/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/01/a33259cdd98b/","excerpt":"MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。","text":"MyBatis-Plus（简称 MP）是一个 MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 ​ 特性： 无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑. 损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作. 强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求 支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错 支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题 支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作 支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ） 内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用 内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询 分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库 内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询 内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作 ☀1.mybatis-plus环境搭建 Emp.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.mashibing.bean;import java.util.Date;public class Emp &#123; private Integer empno; private String eName; private String job; private Integer mgr; private Date hiredate; private Double sal; private Double comm; private Integer deptno; public Emp() &#123; &#125; public Integer getEmpno() &#123; return empno; &#125; public void setEmpno(Integer empno) &#123; this.empno = empno; &#125; public String geteName() &#123; return eName; &#125; public void seteName(String eName) &#123; this.eName = eName; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public Integer getMgr() &#123; return mgr; &#125; public void setMgr(Integer mgr) &#123; this.mgr = mgr; &#125; public Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(Date hiredate) &#123; this.hiredate = hiredate; &#125; public Double getSal() &#123; return sal; &#125; public void setSal(Double sal) &#123; this.sal = sal; &#125; public Double getComm() &#123; return comm; &#125; public void setComm(Double comm) &#123; this.comm = comm; &#125; public Integer getDeptno() &#123; return deptno; &#125; public void setDeptno(Integer deptno) &#123; this.deptno = deptno; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;empno=&quot; + empno + &quot;, ename=&#x27;&quot; + eName + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, mgr=&quot; + mgr + &quot;, hiredate=&quot; + hiredate + &quot;, sal=&quot; + sal + &quot;, comm=&quot; + comm + &quot;, deptno=&quot; + deptno + &#x27;&#125;&#x27;; &#125;&#125; 数据库表sql语句 1234567891011CREATE TABLE `emp` ( `EMPNO` int(4) NOT NULL AUTO_INCREMENT, `E_NAME` varchar(10) DEFAULT NULL, `JOB` varchar(9) DEFAULT NULL, `MGR` int(4) DEFAULT NULL, `HIREDATE` date DEFAULT NULL, `SAL` double(7,2) DEFAULT NULL, `COMM` double(7,2) DEFAULT NULL, `DEPTNO` int(4) DEFAULT NULL, PRIMARY KEY (`EMPNO`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;mybatis_plus&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.19&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; mybatis-config.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt;&lt;/configuration&gt; log4j.properties 12345678# 全局日志配置log4j.rootLogger=INFO, stdout# MyBatis 日志配置log4j.logger.com.mashibing=truce# 控制台输出log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n db.properties 1234driverClassname=com.mysql.cj.jdbc.Driverusername=rootpassword=123456url=jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTC spring.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driverClassname&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.mashibing.dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; MyTest.java 123456789101112131415161718192021package com.mashibing;import com.alibaba.druid.pool.DruidDataSource;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.sql.SQLException;public class MyTest &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); @Test public void test01() throws SQLException &#123; DruidDataSource dataSource = context.getBean(&quot;dataSource&quot;, DruidDataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; ​ 在集成mybatis-plus的时候非常简单，只需要替换mybatis自己的sqlSessionFactoryBean对象即可 12345&lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.mashibing.bean&quot;&gt;&lt;/property&gt;&lt;/bean&gt; ☀2.简单的CRUD操作 ​ 如果我们下面要实现CRUD的基本操作，那么我们该如何实现呢？ ​ 在Mybatis中，我们需要编写对应的Dao接口，并在接口中定义相关的方法，然后提供与该接口相同名称的Dao.xml文件，在文件中填写对应的sql语句，才能完成对应的操作 ​ 在Mybatis-plus中，我们只需要定义接口，然后继承BaseMapper类即可，此前做的所有操作都是由Mybatis-plus来帮我们完成，不需要创建sql映射文件 EmpDao.java 123456789101112package com.mashibing.dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.mashibing.bean.Emp;/** * 在mybatis操作的时候，我们需要自己定义接口中实现的方法，并添加与之对应的EmpDao.xml文件，编写对应的sql语句 * 在mybatis-plus操作的时候，我们只需要继承BaseMapper接口即可，其中的泛型T表示我们要实际操作的实体类对象 */public interface EmpDao extends BaseMapper&lt;Emp&gt; &#123;&#125; ☀1.插入操作 MyTest.java 12345678910111213141516171819202122232425262728293031323334package com.mashibing;import com.alibaba.druid.pool.DruidDataSource;import com.mashibing.bean.Emp;import com.mashibing.dao.EmpDao;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.sql.SQLException;import java.util.Date;public class MyTest &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;); private EmpDao empDao = context.getBean(&quot;empDao&quot;,EmpDao.class);@Test public void testInsert()&#123; Emp emp = new Emp(); emp.seteName(&quot;zhangsan&quot;); emp.setJob(&quot;Teacher&quot;); emp.setMgr(100); emp.setSal(1000.0); emp.setComm(500.0); emp.setHiredate(new Date()); emp.setDeptno(10); int insert = empDao.insert(emp); System.out.println(insert); &#125;&#125; ​ 当运行上述代码的时候，大家发现报错了，原因在于你写的实体类的名称跟表的名称不匹配，因此在实现的是需要添加@TableName注解，指定具体的表的名称 12@TableName(&quot;emp&quot;)public class Emp &#123;//省略内容&#125; 上述代码运行通过之后，大家会发现结果能够正常的进行插入，但是在控制台会打印一个警告信息，说没有@TableId的注解，原因就在于定义实体类的时候并没有声明其中的主键是哪个列，以及使用什么样的主键生成策略，因此，可以在类的属性上添加如下注解，来消除此警告 1234567891011121314public class Emp &#123; @TableId(value = &quot;empno&quot;,type = IdType.AUTO) private Integer empno; private String eName; private String job; private Integer mgr; private Date hiredate; private Double sal; private Double comm; private Integer deptno; //set、get、tostring方法省略&#125; ​ 但是大家会发现，我们在写属性的时候，实体类属性名称跟表的属性名称并没有一一对应上，那么为什么会完成对应的操作呢？ ​ 其实原因就在于mybatis-plus的全局配置 在进行数据插入的是，如果我们输入的时候用的是全字段，那么sql语句中就会执行如下sql语句： INSERT INTO tbl_emp ( e_name, job, mgr, hiredate, sal, comm, deptno ) VALUES ( ?, ?, ?, ?, ?, ?, ? ) 但是如果我们在插入的时候，将对象中的某些属性值设置为空，那么会是什么效果呢？ 1234567891011121314 @Test public void testInsert()&#123; Emp emp = new Emp(); emp.seteName(&quot;zhangsan&quot;); emp.setJob(&quot;Teacher&quot;); emp.setMgr(100);// emp.setSal(1000.0);// emp.setComm(500.0);// emp.setHiredate(new Date());// emp.setDeptno(10); int insert = empDao.insert(emp); System.out.println(insert); System.out.println(emp.getEmpno()); &#125; INSERT INTO tbl_emp ( e_name, job, mgr ) VALUES ( ?, ?, ? ) 大家其实可以看到我们在插入的时候，mybatis-plus会根据我会输入的对象的字段的个数来动态的调整我们的sql语句插入的字段，这是大家需要注意的mybatis-plus比较灵活的地方。 ☀2.更新操作 1234567891011121314@Test public void testUpdate()&#123; Emp emp = new Emp(); emp.setEmpno(1); emp.seteName(&quot;lisi&quot;); emp.setJob(&quot;student&quot;); emp.setMgr(100); emp.setSal(1000.0); emp.setComm(500.0); emp.setHiredate(new Date()); emp.setDeptno(10); int update = empDao.updateById(emp); System.out.println(update); &#125; ☀3.删除操作 12345678910111213141516171819202122 @Test public void testDelete()&#123; // 1、根据id删除数据// int i = empDao.deleteById(1);// System.out.println(i); // 2、根据一组id删除数据// int i = empDao.deleteBatchIds(Arrays.asList(2, 3, 4));// System.out.println(i); // 3、根据条件删除数据// QueryWrapper queryWrapper = new QueryWrapper();// queryWrapper.in(&quot;empno&quot;,Arrays.asList(5,6,7));// int delete = empDao.delete(queryWrapper);// System.out.println(delete); // 4、条件封装map删除数据 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;empno&quot;,9); int i = empDao.deleteByMap(map); System.out.println(i); &#125; ☀4.查询操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 @Test public void testselect()&#123; // 1、根据id查询对象// Emp emp = empDao.selectById(1);// System.out.println(emp); // 2、根据实体包装类查询单个对象，返回的结果集有且仅能有一个对象// QueryWrapper&lt;Emp&gt; emp = new QueryWrapper&lt;Emp&gt;();// emp.eq(&quot;empno&quot;,2).eq(&quot;e_name&quot;,&quot;zhangsan&quot;);// Emp emp1 = empDao.selectOne(emp);// System.out.println(emp1); // 3、通过多个id值进行查询// List&lt;Emp&gt; list = empDao.selectBatchIds(Arrays.asList(1, 2, 3));// for (Emp emp : list) &#123;// System.out.println(emp);// &#125; // 4、通过map封装进行条件查询// Map&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;();// map.put(&quot;e_name&quot;,&quot;zhangsan&quot;);// map.put(&quot;sal&quot;,1000.0);// List&lt;Emp&gt; list = empDao.selectByMap(map);// for (Emp emp : list) &#123;// System.out.println(emp);// &#125; // 5、分页查询,需要添加分页插件 /** * &lt;property name=&quot;plugins&quot;&gt; * &lt;array&gt; * &lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt;&lt;/bean&gt; * &lt;/array&gt; * &lt;/property&gt; */ // Page&lt;Emp&gt; empPage = empDao.selectPage(new Page&lt;&gt;(2, 5), null); // List&lt;Emp&gt; records = empPage.getRecords(); // System.out.println(records); // 6、根据条件返回查询结果总数// QueryWrapper&lt;Emp&gt; queryWrapper = new QueryWrapper&lt;&gt;();// queryWrapper.eq(&quot;e_name&quot;,&quot;zhangsan&quot;);// Integer integer = empDao.selectCount(queryWrapper);// System.out.println(integer); // 7、根据条件查询所有结果返回list集合// List&lt;Emp&gt; list = empDao.selectList(null);// for (Emp emp : list) &#123;// System.out.println(emp);// &#125; // 8、根据条件查询结果封装成map的list结构// List&lt;Map&lt;String, Object&gt;&gt; maps = empDao.selectMaps(null);// System.out.println(maps); &#125; ☀3.Mybatis-plus的相关配置 ​ 在mybatis中我们可以在mybatis-config配置文件中可以添加标签，设置全局的默认策略，在MP中也具备相同的功能，只不过配置方式有所不同，我们可以在spring.xml文件中添加配置。 https://mp.baomidou.com/config/ 在此链接中包含了非常多的配置项，用户可以按照自己的需求添加需要的配置，配置方式如下： spring.xml 123456789101112131415161718&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;configuration&quot; ref=&quot;configuration&quot;/&gt; &lt;!-- 非必须 --&gt; &lt;property name=&quot;globalConfig&quot; ref=&quot;globalConfig&quot;/&gt; &lt;!-- 非必须 --&gt; ......&lt;/bean&gt;&lt;bean id=&quot;configuration&quot; class=&quot;com.baomidou.mybatisplus.core.MybatisConfiguration&quot;&gt; ......&lt;/bean&gt;&lt;bean id=&quot;globalConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig&quot;&gt; &lt;property name=&quot;dbConfig&quot; ref=&quot;dbConfig&quot;/&gt; &lt;!-- 非必须 --&gt; ......&lt;/bean&gt;&lt;bean id=&quot;dbConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig&quot;&gt; ......&lt;/bean&gt; ​ 通过这个配置文件的配置，大家可以进行回想上述问题的出现，mybatis-plus是如何解决这个问题的呢？ ​ 在mybatis-plus中会引入写默认的配置，这个选项的默认配置为true，因此可以完成对应的实现。 我们可以通过如下配置来禁用驼峰标识的操作，如下所示： 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driverClassname&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; &lt;bean id=&quot;sqlSessionFactoryBean&quot; class=&quot;com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.mashibing.bean&quot;&gt;&lt;/property&gt; &lt;property name=&quot;globalConfig&quot; ref=&quot;globalConfig&quot;&gt;&lt;/property&gt; &lt;property name=&quot;configuration&quot; ref=&quot;configuration&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.mashibing.dao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;configuration&quot; class=&quot;com.baomidou.mybatisplus.core.MybatisConfiguration&quot;&gt; &lt;property name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;globalConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig&quot;&gt; &lt;property name=&quot;dbConfig&quot; ref=&quot;dbConfig&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dbConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig&quot;&gt; &lt;/bean&gt;&lt;/beans&gt; 1、当添加上述配置之后，大家发现运行过程中报错， ​ Property ‘configuration’ and ‘configLocation’ can not specified with together ​ 表示这两个标签无法同时使用，因此我们可以选择将configLocation给禁用掉，就是不使用mybatis的配置，此时就能够正常使用了，但是放置属性的时候又报错了，原因就在于我们把驼峰标识给禁用了，重新开启即可。除此之外，我们还可以在属性的上面添加@TableField属性 12@TableField(value = &quot;e_name&quot;)private String eName; 2、此时发现日志功能又无法使用了，只需要添加如下配置即可 1234&lt;bean id=&quot;configuration&quot; class=&quot;com.baomidou.mybatisplus.core.MybatisConfiguration&quot;&gt; &lt;property name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;&gt;&lt;/property&gt; &lt;property name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.log4j.Log4jImpl&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 3、我们在刚刚插入数据的时候发现每个类可能都需要写主键生成策略，这是比较麻烦的，因此可以选择将主键配置策略设置到全局配置中。 1234&lt;bean id=&quot;dbConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig&quot;&gt; &lt;property name=&quot;idType&quot; ref=&quot;idType&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;util:constant id=&quot;idType&quot; static-field=&quot;com.baomidou.mybatisplus.annotation.IdType.AUTO&quot;&gt;&lt;/util:constant&gt; 4、如果你的表的名字都具备相同的前缀，那么可以设置默认的前缀配置策略，此时的话可以将实体类上的@TableName标签省略不写 12345&lt;bean id=&quot;dbConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig.DbConfig&quot;&gt; &lt;property name=&quot;idType&quot; ref=&quot;idType&quot;&gt;&lt;/property&gt; &lt;property name=&quot;tablePrefix&quot; value=&quot;tbl_&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;util:constant id=&quot;idType&quot; static-field=&quot;com.baomidou.mybatisplus.annotation.IdType.AUTO&quot;&gt;&lt;/util:constant&gt; 5、在mybatis-plus中如果需要获取插入的数据的主键的值，那么直接获取即可，原因就在于配置文件中指定了默认的属性为true ☀4.条件构造器Wrapper（看官网即可） ☀5.代码生成器 ​ AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。 ​ 其实在学习mybatis的时候我们就使用过逆向工程，根据我们的数据表来生成的对应的实体类，DAO接口和Mapper映射文件，而MyBatis-plus提供了更加完善的功能，下面来针对两种方式做一个基本的对比 ​ 1、MyBatis-plus是根据java代码开生成代码的，而Mybatis是根据XML文件的配置来生成的 ​ 2、MyBatis-plus能够生成实体类、Mapper接口、Mapper映射文件，Service层，Controller层，而Mybatis只能生成实体类，Mapper接口，Mapper映射文件 ☀操作步骤： ☀1.添加依赖 添加代码生成器依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt;&lt;/dependency&gt; 添加 模板引擎 依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎。 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.30&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.ibeetl&lt;/groupId&gt; &lt;artifactId&gt;beetl&lt;/artifactId&gt; &lt;version&gt;3.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; ☀2.编写生成类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;import org.junit.Test;public class MyTest &#123; @Test public void testGenerator()&#123; //此处默认有两个对应的实现类，大家不要导错包 GlobalConfig globalConfig = new GlobalConfig(); //设置全局的配置 globalConfig.setActiveRecord(true)//是否支持AR模式 .setAuthor(&quot;lian&quot;)//设置作者 .setOutputDir(&quot;e:\\\\self_project\\\\mybatisplus_generatorcode\\\\src\\\\main\\\\java&quot;)//设置生成路径 .setFileOverride(true)//设置文件覆盖 .setIdType(IdType.AUTO) //设置主键生成策略 .setServiceName(&quot;%sService&quot;)//设置生成的serivce接口的名字 .setBaseResultMap(true) //设置基本的结果集映射 .setBaseColumnList(true);//设置基本的列集合 //设置数据源的配置 DataSourceConfig dataSourceConfig = new DataSourceConfig(); dataSourceConfig.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;) .setUrl(&quot;jdbc:mysql://192.168.85.111:3306/mp?serverTimezone=UTC&quot;) .setUsername(&quot;root&quot;).setPassword(&quot;123456&quot;); // 进行策略配置 StrategyConfig strategyConfig = new StrategyConfig(); strategyConfig.setCapitalMode(true)//设置全局大写命名 .setNaming(NamingStrategy.underline_to_camel)//数据库表映射到实体的命名策略 .setTablePrefix(&quot;tbl_&quot;)//设置表名前缀 .setInclude(&quot;tbl_emp&quot;);//生成的表 // 进行包名的策略配置 PackageConfig packageConfig = new PackageConfig(); packageConfig.setParent(&quot;com.mashibing&quot;) .setMapper(&quot;mapper&quot;) .setService(&quot;service&quot;) .setController(&quot;controller&quot;) .setEntity(&quot;bean&quot;) .setXml(&quot;mapper&quot;); //整合配置 AutoGenerator autoGenerator = new AutoGenerator(); autoGenerator.setGlobalConfig(globalConfig).setDataSource(dataSourceConfig).setStrategy(strategyConfig) .setPackageInfo(packageConfig); autoGenerator.execute(); &#125;&#125; ​ 注意，当通过上述代码实现之后，大家发现可以在Controller层可以直接实现调用，这些调用的实现最核心的功能就在于ServiceImpl类，这个类中自动完成mapper的注入，同时提供了一系列CRUD的方法。 ☀6.插件扩展 MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) ☀1.分页插件 在spring.xml文件中添加如下配置引入插件 12345&lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor&quot;&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; 编写测试类 12345678910111213141516@Testpublic void TestPage()&#123; Page page = new Page(2,2); Page page1 = empDao.selectPage(page, null); List records = page1.getRecords(); for (Object record : records) &#123; System.out.println(record); &#125; System.out.println(&quot;==============&quot;); System.out.println(&quot;获取总条数：&quot;+page.getTotal()); System.out.println(&quot;当前页码：&quot;+page.getCurrent()); System.out.println(&quot;总页码：&quot;+page.getPages()); System.out.println(&quot;每页显示的条数：&quot;+page.getSize()); System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious()); System.out.println(&quot;是否有下一页：&quot;+page.hasNext());&#125; ☀2.乐观锁插件 当要更新一条记录的时候，希望这条记录没有被别人更新 乐观锁实现方式： 取出记录时，获取当前version 更新时，带上这个version 执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败 添加配置： 1&lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor&quot;&gt;&lt;/bean&gt; 修改实体类添加version字段并在表中添加version字段 编写测试类 12345678910@Test public void testOptimisticLocker()&#123; Emp emp = new Emp(); emp.setEmpno(22); emp.seteName(&quot;zhang&quot;); emp.setSal(10000.0); emp.setComm(1000.0); emp.setVersion(2); empDao.updateById(emp); &#125; ☀3.SQL执行分析插件，避免出现全表更新和删除 1234567&lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.SqlExplainInterceptor&quot;&gt; &lt;property name=&quot;sqlParserList&quot;&gt; &lt;list&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.extension.parsers.BlockAttackSqlParser&quot;&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 12345@Testpublic void testSqlExplain()&#123; int delete = empDao.delete(null); System.out.println(delete);&#125; ☀4.非法sql检查插件 12&lt;bean class=&quot;com.baomidou.mybatisplus.extension.plugins.IllegalSQLInterceptor&quot;&gt;&lt;/bean&gt; 123456789@Testpublic void testSqlIllegal()&#123; QueryWrapper&lt;Emp&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.or(); List&lt;Emp&gt; list = empDao.selectList(queryWrapper); for (Emp emp : list) &#123; System.out.println(emp); &#125;&#125; ☀7.SQL注入器 ​ 全局配置 sqlInjector 用于注入 ISqlInjector 接口的子类，实现自定义方法注入。也就是说我们可以将配置在xml中的文件使用注入的方式注入到全局中，就不需要再编写sql语句 自定义注入器 1234567891011121314151617package com.mashibing.injector;import com.baomidou.mybatisplus.core.injector.AbstractMethod;import com.baomidou.mybatisplus.core.injector.AbstractSqlInjector;import java.util.List;import java.util.stream.Collectors;import java.util.stream.Stream;public class MyInjector extends AbstractSqlInjector&#123; @Override public List&lt;AbstractMethod&gt; getMethodList(Class&lt;?&gt; mapperClass) &#123; return Stream.of(new DeleteAll()).collect(Collectors.toList()); &#125;&#125; 添加配置： 12345&lt;bean id=&quot;globalConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig&quot;&gt; &lt;property name=&quot;dbConfig&quot; ref=&quot;dbConfig&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlInjector&quot; ref=&quot;myinject&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myinject&quot; class=&quot;com.mashibing.injector.MyInjector&quot;&gt;&lt;/bean&gt; 123456789101112131415161718192021222324package com.mashibing.injector;import com.baomidou.mybatisplus.core.injector.AbstractMethod;import com.baomidou.mybatisplus.core.metadata.TableInfo;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.mapping.SqlSource;public class DeleteAll extends AbstractMethod &#123; @Override public MappedStatement injectMappedStatement(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo) &#123; String sql; MySqlMethod mySqlMethod = MySqlMethod.DELETE_ALL; if (tableInfo.isLogicDelete()) &#123; sql = String.format(mySqlMethod.getSql(), tableInfo.getTableName(), tableInfo, sqlWhereEntityWrapper(true,tableInfo)); &#125; else &#123; mySqlMethod = MySqlMethod.DELETE_ALL; sql = String.format(mySqlMethod.getSql(), tableInfo.getTableName(), sqlWhereEntityWrapper(true,tableInfo)); &#125; SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass); return addUpdateMappedStatement(mapperClass, modelClass, mySqlMethod.getMethod(), sqlSource); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839package com.mashibing.injector; /** * 自定义全局删除方法 */ public enum MySqlMethod &#123; /** * 删除全部 */ DELETE_ALL(&quot;deleteAll&quot;, &quot;根据 entity 条件删除记录&quot;, &quot;&lt;script&gt;\\nDELETE FROM %s %s\\n&lt;/script&gt;&quot;); private final String method; private final String desc; private final String sql; MySqlMethod(String method, String desc, String sql) &#123; this.method = method; this.desc = desc; this.sql = sql; &#125; public String getMethod() &#123; return method; &#125; public String getDesc() &#123; return desc; &#125; public String getSql() &#123; return sql; &#125;&#125; 123456789101112package com.mashibing.dao;import com.baomidou.mybatisplus.core.mapper.BaseMapper;import com.mashibing.bean.Emp;/** * 在mybatis操作的时候，我们需要自己定义接口中实现的方法，并添加与之对应的EmpDao.xml文件，编写对应的sql语句 * 在mybatis-plus操作的时候，我们只需要继承BaseMapper接口即可，其中的泛型T表示我们要实际操作的实体类对象 */public interface EmpDao extends BaseMapper&lt;Emp&gt; &#123; Integer deleteAll();&#125; ☀8.公共字段填充 实现元对象处理器接口：com.baomidou.mybatisplus.core.handlers.MetaObjectHandler 注解填充字段 @TableField(.. fill = FieldFill.INSERT) 生成器策略部分也可以配置！ metaobject:元对象，是mybatis提供的一个用于更加方便，更加优雅的访问对象的属性，给对象的属性设置值的一个对象，还会用于包装对象，支持Object,Map,Collection等对象进行包装。本质上metaobject是给对象的属性设置值，最终还是要通过Reflect获取到属性的对应方法的invoker，最终执行。 编写自定义的公共字段填充 12345678910111213141516171819202122package com.mashibing.fill;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import org.apache.ibatis.reflection.MetaObject;import java.time.LocalDateTime;import java.util.stream.Stream;public class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; this.strictInsertFill(metaObject, &quot;eName&quot;, String.class, &quot;lian&quot;); // 起始版本 3.3.0(推荐使用)// this.fillStrategy(metaObject, &quot;createTime&quot;, LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug请升级到之后的版本如`3.3.1.8-SNAPSHOT`) &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.strictUpdateFill(metaObject, &quot;eName&quot;, String.class,&quot;lian&quot;); // 起始版本 3.3.0(推荐使用)// this.fillStrategy(metaObject, &quot;updateTime&quot;, LocalDateTime.now()); // 也可以使用(3.3.0 该方法有bug请升级到之后的版本如`3.3.1.8-SNAPSHOT`) &#125;&#125; 添加到对应的配置中： 12345&lt;bean id=&quot;globalConfig&quot; class=&quot;com.baomidou.mybatisplus.core.config.GlobalConfig&quot;&gt; &lt;property name=&quot;dbConfig&quot; ref=&quot;dbConfig&quot;&gt;&lt;/property&gt; &lt;property name=&quot;metaObjectHandler&quot; ref=&quot;myMeta&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;myMeta&quot; class=&quot;com.mashibing.fill.MyMetaObjectHandler&quot;&gt;&lt;/bean&gt; 测试： 12345@Test public void testMeta()&#123; int insert = empDao.insert(new Emp()); System.out.println(insert); &#125;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://aner1001.gitee.io/tags/Mybatis/"}]},{"title":"Mybatis学习笔记3-整合与逆向工程","slug":"技术知识/Java/框架/Mybatis/Mybatis学习笔记3-整合与逆向工程","date":"2021-03-01T07:54:45.000Z","updated":"2021-03-01T07:54:45.000Z","comments":true,"path":"posts/2021/03/01/918150132c1d/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/01/918150132c1d/","excerpt":"三大框架整合. mybatis逆向工程","text":"三大框架整合. mybatis逆向工程 ☀1.三大框架整合 ​ 在老期的项目中，一般都是使用ssm项目做开发的，虽然现在的主流开发是springboot来做开发，但是ssm的基本整合还是需要掌握的。 ☀1.导入pom文件 1、导入spring的pom依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ☀2.编写各个框架的配置文件 web.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--springmvc的核心配置类--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--字符编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--支持rest风格的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--springmvc只扫描控制器--&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--静态资源的扫描--&gt; &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt; &lt;!--动态资源的扫描--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--配置视图管理器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; spring.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--Spring除了控制器不扫描，其他的组件都扫描，包括service，component等--&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;!--引入外部配置文件--&gt; &lt;context:property-placeholder location=&quot;classpath:db.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--配置数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverName&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置事务管理器的bean对象--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启基于注解的事务管理器的配置--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; &lt;!--添加mybatis的配置--&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!--指定配置文件的位置--&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/mashibing/dao/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建mybatis扫描器，批量配置映射文件--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.mashibing.dao&quot;&gt;&lt;/property&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.mashibing.bean&quot;/&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; db.properties 1234jdbc.username=rootjdbc.password=123456jdbc.url=jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTCjdbc.driverName=com.mysql.jdbc.Driver 拷贝映射文件，还是位于com.mashibing.dao目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace:编写接口的全类名，就是告诉要实现该配置文件是哪个接口的具体实现--&gt;&lt;mapper namespace=&quot;com.mashibing.dao.EmpDao&quot;&gt;&lt;!-- &lt;cache&gt;&lt;/cache&gt;--&gt;&lt;!-- &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;--&gt; &lt;!-- select:表示这个操作是一个查询操作 id表示的是要匹配的方法的名称 resultType:表示返回值的类型，查询操作必须要包含返回值的类型 #&#123;属性名&#125;：表示要传递的参数的名称 --&gt; &lt;select id=&quot;findEmpByEmpno&quot; resultType=&quot;emp&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt; &lt;!--增删改查操作不需要返回值，增删改返回的是影响的行数，mybatis会自动做判断--&gt; &lt;insert id=&quot;insertEmp&quot;&gt; insert into emp(empno,ename) values(#&#123;empno&#125;,#&#123;ename&#125;) &lt;/insert&gt; &lt;update id=&quot;updateEmp&quot;&gt; update emp set ename=#&#123;ename&#125; where empno = #&#123;empno&#125; &lt;/update&gt; &lt;delete id=&quot;deleteEmp&quot;&gt; delete from emp where empno = #&#123;empno&#125; &lt;/delete&gt; &lt;!-- 当查询语句中包含多个参数的是，如果使用#&#123;属性名称&#125;就无法获取具体的值了，那么应该如何使用呢？ 下面就是mybatis的参数传递方式 1、如果是单个参数， 基本类型：使用#&#123;随便写&#125; 引用类型：使用#&#123;类的属性名称&#125; 2、多个参数： 当查询的时候传入多个参数的时候，就无法简单的通过#&#123;参数名&#125;来获取值了， 只能通过arg0,arg1...或者param1,param2等方式来获取值 原因就在于，mybatis在传入多个参数的时候，会将这些参数封装到一个map中，此时map中的key就是 arg0,arg1,param1,param2这些值，但是很明显，这样的传值方式不是很友好，没有办法根据参数的名称来 获取具体的值，因此可以使用如下的方式来指定参数的key是什么 Emp selectEmpByNoAndName(@Param(&quot;empno&quot;) Integer empno, @Param(&quot;ename&quot;) String ename); 也就是通过@Param来指定存入map中的key值是什么 3、使用map来传递参数： 依然是直接使用#&#123;key&#125;来获取具体的属性值 --&gt; &lt;!-- 当使用#&#123;&#125;来获取值的时候会发现打印的sql语句如下： select * from emp where empno=? and ename=? 当使用$&#123;&#125;来获取值的时候会发现打印的sql语句如下： select * from emp where empno=7369 and ename=&#x27;SMITH&#x27; 通过刚刚的案例大家已经发现了存在的问题了， 使用#&#123;&#125;方式进行取值：采用的是参数预编译的方式，参数的位置使用？进行替代，不会出现sql注入的问题 使用$&#123;&#125;方式进行取值：采用的是直接跟sql语句进行拼接的方式 --&gt; &lt;select id=&quot;selectEmpByNoAndName&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from $&#123;t&#125; where empno=$&#123;empno&#125; and ename=$&#123;ename&#125; &lt;/select&gt; &lt;select id=&quot;selectEmpByNoAndName2&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where empno=#&#123;empno&#125; and ename=#&#123;ename&#125; &lt;/select&gt; &lt;!--当返回值的结果是集合的时候，返回值的类型依然写的是集合中具体的类型--&gt; &lt;select id=&quot;selectAllEmp&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;/select&gt; &lt;!--在查询的时候可以设置返回值的类型为map，当mybatis查询完成之后会把列的名称作为key 列的值作为value，转换到map中 --&gt; &lt;select id=&quot;selectEmpByEmpReturnMap&quot; resultType=&quot;map&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt; &lt;!--注意，当返回的结果是一个集合对象的是，返回值的类型一定要写集合具体value的类型 同时在dao的方法上要添加@MapKey的注解，来设置key是什么结果 @MapKey(&quot;empno&quot;) Map&lt;Integer,Emp&gt; getAllEmpReturnMap();--&gt; &lt;select id=&quot;getAllEmpReturnMap&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;/select&gt; &lt;!--再做查询的时候，有时候需要关联其他对象，因此需要使用关联查询 可以通过下面自定义结果集的方式实现 --&gt; &lt;select id=&quot;selectEmpAndDept&quot; resultMap=&quot;empDept&quot;&gt; select * from emp left join dept on emp.deptno = dept.deptno where empno = #&#123;empno&#125;; &lt;/select&gt; &lt;!--&lt;resultMap id=&quot;empDept&quot; type=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;result column=&quot;deptno&quot; property=&quot;dept.deptno&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dname&quot; property=&quot;dept.dname&quot;&gt;&lt;/result&gt; &lt;result column=&quot;loc&quot; property=&quot;dept.loc&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt;--&gt; &lt;!--在mybatis中还提供了一种简单的形式，使用association标签可以搞定 --&gt; &lt;resultMap id=&quot;empDept&quot; type=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; javaType=&quot;com.mashibing.bean.Dept&quot;&gt; &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt; &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectEmpAndDeptBySimple&quot; resultMap=&quot;simpleEmpAndDept&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt; &lt;resultMap id=&quot;simpleEmpAndDept&quot; type=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; select=&quot;com.mashibing.dao.DeptDao.getDeptAndEmpsBySimple&quot; column=&quot;deptno&quot; fetchType=&quot;eager&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectEmpByStep&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where deptno = #&#123;deptno&#125; &lt;/select&gt; &lt;!-- &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;where&gt; &lt;if test=&quot;empno!=null&quot;&gt; empno &gt; #&#123;empno&#125; &lt;/if&gt; &lt;if test=&quot;ename!=null&quot;&gt; and ename like #&#123;ename&#125; &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt; and sal &gt; #&#123;sal&#125; &lt;/if&gt; &lt;/where&gt;--&gt; &lt;!-- trim截取字符串： prefix：前缀，为sql整体添加一个前缀 prefixOverrides:去除整体字符串前面多余的字符 suffixOverrides:去除后面多余的字符串 --&gt; &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;empno!=null&quot;&gt; empno &gt; #&#123;empno&#125; and &lt;/if&gt; &lt;if test=&quot;ename!=null&quot;&gt; ename like #&#123;ename&#125; and &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt; sal &gt; #&#123;sal&#125; and &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; &lt;!--foreach是对集合进行遍历 collection=&quot;deptnos&quot; 指定要遍历的集合 close=&quot;&quot; 表示以什么结束 index=&quot;&quot; 给定一个索引值 item=&quot;&quot; 遍历的每一个元素的值 open=&quot;&quot; 表示以什么开始 separator=&quot;&quot; 表示多个元素的分隔符 --&gt; &lt;select id=&quot;getEmpByDeptnos&quot; resultType=&quot;Emp&quot;&gt; select * from emp where deptno in &lt;foreach collection=&quot;deptnos&quot; close=&quot;)&quot; index=&quot;idx&quot; item=&quot;deptno&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt; #&#123;deptno&#125; &lt;/foreach&gt; &lt;/select&gt; &lt;select id=&quot;getEmpByConditionChoose&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;empno!=null&quot;&gt; empno &gt; #&#123;empno&#125; &lt;/when&gt; &lt;when test=&quot;ename!=null&quot;&gt; ename like #&#123;ename&#125; &lt;/when&gt; &lt;when test=&quot;sal!=null&quot;&gt; sal &gt; #&#123;sal&#125; &lt;/when&gt; &lt;otherwise&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; &lt;update id=&quot;updateEmpByEmpno&quot;&gt; update emp &lt;set&gt; &lt;if test=&quot;empno!=null&quot;&gt; empno=#&#123;empno&#125;, &lt;/if&gt; &lt;if test=&quot;ename!=null&quot;&gt; ename = #&#123;ename&#125;, &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt;@ sal = #&#123;sal&#125; &lt;/if&gt; &lt;/set&gt; &lt;where&gt; empno = #&#123;empno&#125; &lt;/where&gt; &lt;/update&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.dao.DeptDao&quot;&gt; &lt;!--定义查询集合元素--&gt; &lt;select id=&quot;getDeptAndEmps&quot; resultMap=&quot;deptEmp&quot;&gt; select * from dept left join emp on dept.deptno = emp.deptno where dept.deptno=#&#123;deptno&#125; &lt;/select&gt; &lt;resultMap id=&quot;deptEmp&quot; type=&quot;com.mashibing.bean.Dept&quot;&gt; &lt;id property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/id&gt; &lt;result property=&quot;dname&quot; column=&quot;dname&quot;&gt;&lt;/result&gt; &lt;result property=&quot;loc&quot; column=&quot;loc&quot;&gt;&lt;/result&gt; &lt;!--封装集合类的元素 property：指定集合的属性 ofType:指定集合中的元素类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getDeptAndEmpsBySimple&quot; resultType=&quot;com.mashibing.bean.Dept&quot;&gt; select * from dept where deptno = #&#123;deptno&#125; &lt;/select&gt; &lt;select id=&quot;getDeptAndEmpsByStep&quot; resultMap=&quot;deptEmpByStep&quot;&gt; select * from dept where deptno = #&#123;deptno&#125; &lt;/select&gt; &lt;resultMap id=&quot;deptEmpByStep&quot; type=&quot;com.mashibing.bean.Dept&quot;&gt; &lt;id property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/id&gt; &lt;result property=&quot;dname&quot; column=&quot;dname&quot;&gt;&lt;/result&gt; &lt;result property=&quot;loc&quot; column=&quot;loc&quot;&gt;&lt;/result&gt; &lt;!--封装集合类的元素 property：指定集合的属性 ofType:指定集合中的元素类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.mashibing.bean.Emp&quot; select=&quot;com.mashibing.dao.EmpDao.selectEmpByStep&quot; column=&quot;deptno&quot; &gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 添加dao的接口 EmpDao.java 1234567891011121314151617181920212223242526272829303132333435363738394041package com.mashibing.dao;import com.mashibing.bean.Emp;import org.apache.ibatis.annotations.MapKey;import org.apache.ibatis.annotations.Param;import java.util.List;import java.util.Map;public interface EmpDao &#123; public Emp findEmpByEmpno(Integer empno); public int updateEmp(Emp emp); public int deleteEmp(Integer empno); public int insertEmp(Emp emp); Emp selectEmpByNoAndName(@Param(&quot;empno&quot;) Integer empno, @Param(&quot;ename&quot;) String ename, @Param(&quot;t&quot;) String tablename); Emp selectEmpByNoAndName2(Map&lt;String, Object&gt; map); List&lt;Emp&gt; selectAllEmp(); Map&lt;String,Object&gt; selectEmpByEmpReturnMap(Integer empno); @MapKey(&quot;empno&quot;) Map&lt;Integer,Emp&gt; getAllEmpReturnMap(); Emp selectEmpAndDept(Integer empno); Emp selectEmpAndDeptBySimple(Integer empno); List&lt;Emp&gt; selectEmpByStep(Integer deptno); public List&lt;Emp&gt; getEmpByCondition(Emp emp); public List&lt;Emp&gt; getEmpByConditionChoose(Emp emp); public List&lt;Emp&gt; getEmpByDeptnos(@Param(&quot;deptnos&quot;) List&lt;Integer&gt; deptnos); public int updateEmpByEmpno(Emp emp);&#125; ☀3.创建测试类 TestController.java 12345678910111213141516171819202122package com.mashibing.controller;import com.mashibing.bean.Emp;import com.mashibing.dao.EmpDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestController &#123; @Autowired EmpDao empDao; @RequestMapping(&quot;/test&quot;) public String test()&#123; System.out.println(&quot;test&quot;); Emp empByEmpno = empDao.findEmpByEmpno(7369); System.out.println(empByEmpno); return &quot;success&quot;; &#125;&#125; ☀2.mybatis逆向工程 引入pom依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt; 编写配置文件： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;context id=&quot;simple&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;!--指向数据库连接--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://192.168.85.111:3306/demo?serverTimezone=UTC&quot; userId=&quot;root&quot; password=&quot;123456&quot; /&gt; &lt;!--生成对应的实体类 targetPackage：指定生成java文件的目录 targetProject：放在那个工程的哪个目录下 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.mashibing.bean&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!--SQL映射文件生成器 targetPackage：指定生成java文件的目录 targetProject：放在那个工程的哪个目录下 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.mashibing.dao&quot; targetProject=&quot;src/main/resources&quot;/&gt; &lt;!--dao接口生成器--&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.mashibing.dao&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;!--指定要逆向生成的数据表 tableName:表名 domainObjectName:对象名 --&gt; &lt;table tableName=&quot;emp&quot; domainObjectName=&quot;Emp&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; enableSelectByExample=&quot;false&quot;/&gt; &lt;table tableName=&quot;dept&quot; domainObjectName=&quot;Dept&quot; enableCountByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot; enableSelectByExample=&quot;false&quot;/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 编写测试类 1234567891011121314151617181920212223242526272829package com.mashibing;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class Test &#123; public static void main(String[] args) throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;mbg.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; ☀3.分页插件 PageHelper（自学，项目中会使用）","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://aner1001.gitee.io/tags/Mybatis/"}]},{"title":"Mybatis学习笔记2-映射文件","slug":"技术知识/Java/框架/Mybatis/Mybatis学习笔记2-映射文件","date":"2021-03-01T02:52:06.000Z","updated":"2021-03-01T02:52:06.000Z","comments":true,"path":"posts/2021/03/01/10b37d7d655c/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/03/01/10b37d7d655c/","excerpt":"cache – 该命名空间的缓存配置。 cache-ref – 引用其它命名空间的缓存配置。 resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。 parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。 sql – 可被其它语句引用的可重用语句块。 insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句。","text":"cache – 该命名空间的缓存配置。 cache-ref – 引用其它命名空间的缓存配置。 resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。 parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。 sql – 可被其它语句引用的可重用语句块。 insert – 映射插入语句。 update – 映射更新语句。 delete – 映射删除语句。 select – 映射查询语句。 ​ 在之前我们学习了mybatis的全局配置文件，下面我们开始学习mybatis的映射文件，在映射文件中，可以编写以下的顶级元素标签： 123456789cache – 该命名空间的缓存配置。cache-ref – 引用其它命名空间的缓存配置。resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。sql – 可被其它语句引用的可重用语句块。insert – 映射插入语句。update – 映射更新语句。delete – 映射删除语句。select – 映射查询语句。 ​ 在每个顶级元素标签中可以添加很多个属性，下面我们开始详细了解下具体的配置。 ☀1.insert、update、delete元素 属性 描述 id 在命名空间中唯一的标识符，可以被用来引用这条语句。 parameterType 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 parameterMap 用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。 flushCache 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 timeout 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 statementType 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 useGeneratedKeys （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 keyProperty （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。 keyColumn （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 databaseId 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 1234567891011&lt;!--如果数据库支持自增可以使用这样的方式--&gt; &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into user(user_name) values(#&#123;userName&#125;) &lt;/insert&gt; &lt;!--如果数据库不支持自增的话，那么可以使用如下的方式进行赋值查询--&gt; &lt;insert id=&quot;insertUser2&quot; &gt; &lt;selectKey order=&quot;BEFORE&quot; keyProperty=&quot;id&quot; resultType=&quot;integer&quot;&gt; select max(id)+1 from user &lt;/selectKey&gt; insert into user(id,user_name) values(#&#123;id&#125;,#&#123;userName&#125;) &lt;/insert&gt; ☀2.select元素 ☀1.select的参数传递 123456789101112131415161718192021222324&lt;!-- 当查询语句中包含多个参数的是，如果使用#&#123;属性名称&#125;就无法获取具体的值了，那么应该如何使用呢？ 下面就是mybatis的参数传递方式 1、如果是单个参数， 基本类型：使用#&#123;随便写&#125; 引用类型：使用#&#123;类的属性名称&#125; 2、多个参数： 当查询的时候传入多个参数的时候，就无法简单的通过#&#123;参数名&#125;来获取值了， 只能通过arg0,arg1...或者param1,param2等方式来获取值 原因就在于，mybatis在传入多个参数的时候，会将这些参数封装到一个map中，此时map中的key就是 arg0,arg1,param1,param2这些值，但是很明显，这样的传值方式不是很友好，没有办法根据参数的名称来 获取具体的值，因此可以使用如下的方式来指定参数的key是什么 Emp selectEmpByNoAndName(@Param(&quot;empno&quot;) Integer empno, @Param(&quot;ename&quot;) String ename); 也就是通过@Param来指定存入map中的key值是什么 3、使用map来传递参数： 依然是直接使用#&#123;key&#125;来获取具体的属性值 --&gt; &lt;select id=&quot;selectEmpByNoAndName&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where empno=#&#123;empno&#125; and ename=#&#123;ename&#125; &lt;/select&gt; &lt;select id=&quot;selectEmpByNoAndName2&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where empno=#&#123;empno&#125; and ename=#&#123;ename&#125; &lt;/select&gt; ☀2.参数的取值方式 ​ 在xml文件中编写sql语句的时候有两种取值的方式，分别是#{}和${}，下面来看一下他们之间的区别： 1234567891011121314&lt;!-- 当使用#&#123;&#125;来获取值的时候会发现打印的sql语句如下： select * from emp where empno=? and ename=? 当使用$&#123;&#125;来获取值的时候会发现打印的sql语句如下： select * from emp where empno=7369 and ename=&#x27;SMITH&#x27; 通过刚刚的案例大家已经发现了存在的问题了， 使用#&#123;&#125;方式进行取值：采用的是参数预编译的方式，参数的位置使用？进行替代，不会出现sql注入的问题 使用$&#123;&#125;方式进行取值：采用的是直接跟sql语句进行拼接的方式 此处大家需要注意，如果我们的sql语句中的某些值不支持参数预编译，那么就必须要使用$&#123;&#125;的方式来取值了 --&gt; &lt;select id=&quot;selectEmpByNoAndName&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from #&#123;t&#125; where empno=$&#123;empno&#125; and ename=$&#123;ename&#125; &lt;/select&gt; ☀3.处理集合返回结果 EmpDao.xml 123456789101112131415161718&lt;!--当返回值的结果是集合的时候，返回值的类型依然写的是集合中具体的类型--&gt; &lt;select id=&quot;selectAllEmp&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;/select&gt;&lt;!--在查询的时候可以设置返回值的类型为map，当mybatis查询完成之后会把列的名称作为key 列的值作为value，转换到map中 --&gt; &lt;select id=&quot;selectEmpByEmpReturnMap&quot; resultType=&quot;map&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt; &lt;!--注意，当返回的结果是一个集合对象的是，返回值的类型一定要写集合具体value的类型 同时在dao的方法上要添加@MapKey的注解，来设置key是什么结果 @MapKey(&quot;empno&quot;) Map&lt;Integer,Emp&gt; getAllEmpReturnMap();--&gt; &lt;select id=&quot;getAllEmpReturnMap&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;/select&gt; UserDao.java 1234567891011121314151617181920212223242526272829package com.mashibing.dao;import com.mashibing.bean.Emp;import org.apache.ibatis.annotations.MapKey;import org.apache.ibatis.annotations.Param;import java.util.List;import java.util.Map;public interface EmpDao &#123; public Emp findEmpByEmpno(Integer empno); public int updateEmp(Emp emp); public int deleteEmp(Integer empno); public int insertEmp(Emp emp); Emp selectEmpByNoAndName(@Param(&quot;empno&quot;) Integer empno, @Param(&quot;ename&quot;) String ename,@Param(&quot;t&quot;) String tablename); Emp selectEmpByNoAndName2(Map&lt;String,Object&gt; map); List&lt;Emp&gt; selectAllEmp(); Map&lt;String,Object&gt; selectEmpByEmpReturnMap(Integer empno); @MapKey(&quot;empno&quot;) Map&lt;Integer,Emp&gt; getAllEmpReturnMap();&#125; ☀4.自定义结果集—resultMap Dog.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.mashibing.bean;public class Dog &#123; private Integer id; private String name; private Integer age; private String gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return &quot;Dog&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; dog.sql 12345678910111213141516171819202122232425262728293031323334/*Navicat MySQL Data TransferSource Server : node01Source Server Version : 50729Source Host : 192.168.85.111:3306Source Database : demoTarget Server Type : MYSQLTarget Server Version : 50729File Encoding : 65001Date: 2020-03-24 23:54:22*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `dog`-- ----------------------------DROP TABLE IF EXISTS `dog`;CREATE TABLE `dog` ( `id` int(11) NOT NULL AUTO_INCREMENT, `dname` varchar(255) DEFAULT NULL, `dage` int(11) DEFAULT NULL, `dgender` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of dog-- ----------------------------INSERT INTO dog VALUES (&#x27;1&#x27;, &#x27;大黄&#x27;, &#x27;1&#x27;, &#x27;雄&#x27;);INSERT INTO dog VALUES (&#x27;2&#x27;, &#x27;二黄&#x27;, &#x27;2&#x27;, &#x27;雌&#x27;);INSERT INTO dog VALUES (&#x27;3&#x27;, &#x27;三黄&#x27;, &#x27;3&#x27;, &#x27;雄&#x27;); DogDao.java 12345678package com.mashibing.dao;import com.mashibing.bean.Dog;public interface DogDao &#123; public Dog selectDogById(Integer id);&#125; DogDao.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.dao.DogDao&quot;&gt; &lt;!-- 在使用mybatis进行查询的时候，mybatis默认会帮我们进行结果的封装，但是要求列名跟属性名称一一对应上 在实际的使用过程中，我们会发现有时候数据库中的列名跟我们类中的属性名并不是一一对应的，此时就需要起别名 起别名有两种实现方式： 1、在编写sql语句的时候添加别名 2、自定义封装结果集 --&gt; &lt;!--根据查询的数据进行结果的封装要使用resultMap属性，表示使用自定义规则--&gt; &lt;select id=&quot;selectDogById&quot; resultMap=&quot;myDog&quot;&gt; select * from dog where id = #&#123;id&#125; &lt;/select&gt; &lt;!--自定义结果集，将每一个列的数据跟javaBean的对象属性对应起来 type:表示为哪一个javaBean对象进行对应 id:唯一标识，方便其他属性标签进行引用 --&gt; &lt;resultMap id=&quot;myDog&quot; type=&quot;com.mashibing.bean.Dog&quot;&gt; &lt;!-- 指定主键列的对应规则： column：表示表中的主键列 property:指定javaBean的属性 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;&gt;&lt;/id&gt; &lt;!--设置其他列的对应关系--&gt; &lt;result column=&quot;dname&quot; property=&quot;name&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dage&quot; property=&quot;age&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dgender&quot; property=&quot;gender&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--可以在sql语句中写别名--&gt; &lt;!-- &lt;select id=&quot;selectDogById&quot; resultType=&quot;com.mashibing.bean.Dog&quot;&gt; select id id,dname name,dage age,dgender gender from dog where id = #&#123;id&#125; &lt;/select&gt;--&gt; &lt;!--这种方式是查询不到任何结果的，因为属性名跟列名并不是一一对应的--&gt; &lt;!-- &lt;select id=&quot;selectDogById&quot; resultType=&quot;com.mashibing.bean.Dog&quot;&gt; select * from dog where id = #&#123;id&#125; &lt;/select&gt;--&gt;&lt;/mapper&gt; ☀5.联合查询 emp.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package com.mashibing.bean;import java.util.Date;public class Emp &#123; private Integer empno; private String ename; private String job; private Integer mgr; private Date hiredate; private Double sal; private Double common; private Dept dept; public Emp() &#123; &#125; public Emp(Integer empno, String ename) &#123; this.empno = empno; this.ename = ename; &#125; public Emp(Integer empno, String ename, String job, Integer mgr, Date hiredate, Double sal, Double common, Dept dept) &#123; this.empno = empno; this.ename = ename; this.job = job; this.mgr = mgr; this.hiredate = hiredate; this.sal = sal; this.common = common; this.dept = dept; &#125; public Integer getEmpno() &#123; return empno; &#125; public void setEmpno(Integer empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public Integer getMgr() &#123; return mgr; &#125; public void setMgr(Integer mgr) &#123; this.mgr = mgr; &#125; public Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(Date hiredate) &#123; this.hiredate = hiredate; &#125; public Double getSal() &#123; return sal; &#125; public void setSal(Double sal) &#123; this.sal = sal; &#125; public Double getCommon() &#123; return common; &#125; public void setCommon(Double common) &#123; this.common = common; &#125; public Dept getDept() &#123; return dept; &#125; public void setDept(Dept dept) &#123; this.dept = dept; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;empno=&quot; + empno + &quot;, ename=&#x27;&quot; + ename + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, mgr=&quot; + mgr + &quot;, hiredate=&quot; + hiredate + &quot;, sal=&quot; + sal + &quot;, common=&quot; + common + &quot;, dept=&quot; + dept + &#x27;&#125;&#x27;; &#125;&#125; Dept.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.mashibing.bean;public class Dept &#123; private Integer deptno; private String dname; private String loc; public Dept() &#123; &#125; public Dept(Integer deptno, String dname, String loc) &#123; this.deptno = deptno; this.dname = dname; this.loc = loc; &#125; public Integer getDeptno() &#123; return deptno; &#125; public void setDeptno(Integer deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getLoc() &#123; return loc; &#125; public void setLoc(String loc) &#123; this.loc = loc; &#125; @Override public String toString() &#123; return &quot;Dept&#123;&quot; + &quot;deptno=&quot; + deptno + &quot;, dname=&#x27;&quot; + dname + &#x27;\\&#x27;&#x27; + &quot;, loc=&#x27;&quot; + loc + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; EmpDao.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace:编写接口的全类名，就是告诉要实现该配置文件是哪个接口的具体实现--&gt;&lt;mapper namespace=&quot;com.mashibing.dao.EmpDao&quot;&gt; &lt;!--再做查询的时候，有时候需要关联其他对象，因此需要使用关联查询 可以通过下面自定义结果集的方式实现 --&gt; &lt;select id=&quot;selectEmpAndDept&quot; resultMap=&quot;empDept&quot;&gt; select * from emp left join dept on emp.deptno = dept.deptno where empno = #&#123;empno&#125;; &lt;/select&gt; &lt;resultMap id=&quot;empDept&quot; type=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;result column=&quot;deptno&quot; property=&quot;dept.deptno&quot;&gt;&lt;/result&gt; &lt;result column=&quot;dname&quot; property=&quot;dept.dname&quot;&gt;&lt;/result&gt; &lt;result column=&quot;loc&quot; property=&quot;dept.loc&quot;&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--在mybatis中还提供了一种简单的形式，使用association标签可以搞定 --&gt; &lt;resultMap id=&quot;empDept&quot; type=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; javaType=&quot;com.mashibing.bean.Dept&quot;&gt; &lt;id column=&quot;deptno&quot; property=&quot;deptno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;dname&quot; property=&quot;dname&quot;&gt;&lt;/result&gt; &lt;result column=&quot;loc&quot; property=&quot;loc&quot;&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; Test 123456789101112131415@Testpublic void test08() &#123; // 获取数据库的会话 SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; EmpDao mapper = sqlSession.getMapper(EmpDao.class); Emp emp = mapper.selectEmpAndDept(7369); System.out.println(emp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125;&#125; ☀6.获取集合元素 Dept.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.mashibing.bean;import java.util.List;public class Dept &#123; private Integer deptno; private String dname; private String loc; private List&lt;Emp&gt; emps; public Dept() &#123; &#125; public Dept(Integer deptno, String dname, String loc) &#123; this.deptno = deptno; this.dname = dname; this.loc = loc; &#125; public Integer getDeptno() &#123; return deptno; &#125; public void setDeptno(Integer deptno) &#123; this.deptno = deptno; &#125; public String getDname() &#123; return dname; &#125; public void setDname(String dname) &#123; this.dname = dname; &#125; public String getLoc() &#123; return loc; &#125; public void setLoc(String loc) &#123; this.loc = loc; &#125; public List&lt;Emp&gt; getEmps() &#123; return emps; &#125; public void setEmps(List&lt;Emp&gt; emps) &#123; this.emps = emps; &#125; @Override public String toString() &#123; return &quot;Dept&#123;&quot; + &quot;deptno=&quot; + deptno + &quot;, dname=&#x27;&quot; + dname + &#x27;\\&#x27;&#x27; + &quot;, loc=&#x27;&quot; + loc + &#x27;\\&#x27;&#x27; + &quot;, emps=&quot; + emps + &#x27;&#125;&#x27;; &#125;&#125; DeptDao.java 123456789101112package com.mashibing.dao;import com.mashibing.bean.Dept;import com.mashibing.bean.Emp;import java.util.List;public interface DeptDao &#123; public Dept getDeptAndEmps(Integer deptno);&#125; DeptDao.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.dao.DeptDao&quot;&gt; &lt;!--定义查询集合元素--&gt; &lt;select id=&quot;getDeptAndEmps&quot; resultMap=&quot;deptEmp&quot;&gt; select * from dept left join emp on dept.deptno = emp.deptno where dept.deptno=#&#123;deptno&#125; &lt;/select&gt; &lt;resultMap id=&quot;deptEmp&quot; type=&quot;com.mashibing.bean.Dept&quot;&gt; &lt;id property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/id&gt; &lt;result property=&quot;dname&quot; column=&quot;dname&quot;&gt;&lt;/result&gt; &lt;result property=&quot;loc&quot; column=&quot;loc&quot;&gt;&lt;/result&gt; &lt;!--封装集合类的元素 property：指定集合的属性 ofType:指定集合中的元素类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id property=&quot;empno&quot; column=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; Test 123456789101112131415@Testpublic void test09() &#123; // 获取数据库的会话 SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; DeptDao mapper = sqlSession.getMapper(DeptDao.class); Dept deptAndEmps = mapper.getDeptAndEmps(10); System.out.println(deptAndEmps); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125;&#125; ☀7.分步查询 ​ 在上述逻辑的查询中，是由我们自己来完成sql语句的关联查询的，那么，我们能让mybatis帮我们实现自动的关联查询吗? 关联查询的分步 DeptDao.java 1234567891011121314package com.mashibing.dao;import com.mashibing.bean.Dept;import com.mashibing.bean.Emp;import java.util.List;public interface DeptDao &#123; public Dept getDeptAndEmps(Integer deptno); public Dept getDeptAndEmpsBySimple(Integer deptno);&#125; EmpDao.java 123456789101112131415package com.mashibing.dao;import com.mashibing.bean.Emp;import org.apache.ibatis.annotations.MapKey;import org.apache.ibatis.annotations.Param;import java.util.List;import java.util.Map;public interface EmpDao &#123; Emp selectEmpAndDept(Integer empno); Emp selectEmpAndDeptBySimple(Integer empno);&#125; DeptDao.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.dao.DeptDao&quot;&gt; &lt;select id=&quot;getDeptAndEmpsBySimple&quot; resultType=&quot;com.mashibing.bean.Dept&quot;&gt; select * from dept where deptno = #&#123;deptno&#125; &lt;/select&gt;&lt;/mapper&gt; EmpDao.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.dao.EmpDao&quot;&gt; &lt;select id=&quot;selectEmpAndDeptBySimple&quot; resultMap=&quot;simpleEmpAndDept&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt; &lt;resultMap id=&quot;simpleEmpAndDept&quot; type=&quot;com.mashibing.bean.Emp&quot;&gt; &lt;id column=&quot;empno&quot; property=&quot;empno&quot;&gt;&lt;/id&gt; &lt;result column=&quot;ename&quot; property=&quot;ename&quot;&gt;&lt;/result&gt; &lt;result column=&quot;job&quot; property=&quot;job&quot;&gt;&lt;/result&gt; &lt;result column=&quot;mgr&quot; property=&quot;mgr&quot;&gt;&lt;/result&gt; &lt;result column=&quot;hiredate&quot; property=&quot;hiredate&quot;&gt;&lt;/result&gt; &lt;result column=&quot;sal&quot; property=&quot;sal&quot;&gt;&lt;/result&gt; &lt;result column=&quot;comm&quot; property=&quot;common&quot;&gt;&lt;/result&gt; &lt;association property=&quot;dept&quot; select=&quot;com.mashibing.dao.DeptDao.getDeptAndEmpsBySimple&quot; column=&quot;deptno&quot;&gt; &lt;/association&gt; &lt;/resultMap&gt;&lt;/mapper&gt; Test 12345678910111213141516@Test public void test08() &#123; // 获取数据库的会话 SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; EmpDao mapper = sqlSession.getMapper(EmpDao.class);// Emp emp = mapper.selectEmpAndDept(7369); Emp emp = mapper.selectEmpAndDeptBySimple(7369); System.out.println(emp); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125; 集合的分步查询 EmpDao.java 1234567891011121314package com.mashibing.dao;import com.mashibing.bean.Emp;import org.apache.ibatis.annotations.MapKey;import org.apache.ibatis.annotations.Param;import java.util.List;import java.util.Map;public interface EmpDao &#123; Emp selectEmpAndDeptBySimple(Integer empno); Emp selectEmpByStep(Integer empno);&#125; DeptDao.java 12345678910111213141516package com.mashibing.dao;import com.mashibing.bean.Dept;import com.mashibing.bean.Emp;import java.util.List;public interface DeptDao &#123; public Dept getDeptAndEmps(Integer deptno); public Dept getDeptAndEmpsBySimple(Integer deptno); public Dept getDeptAndEmpsByStep(Integer deptno);&#125; EmpDao.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.dao.EmpDao&quot;&gt; &lt;select id=&quot;selectEmpByStep&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where deptno = #&#123;deptno&#125; &lt;/select&gt;&lt;/mapper&gt; DeptDao.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.mashibing.dao.DeptDao&quot;&gt; &lt;select id=&quot;getDeptAndEmpsByStep&quot; resultMap=&quot;deptEmpByStep&quot;&gt; select * from dept where deptno = #&#123;deptno&#125; &lt;/select&gt; &lt;resultMap id=&quot;deptEmpByStep&quot; type=&quot;com.mashibing.bean.Dept&quot;&gt; &lt;id property=&quot;deptno&quot; column=&quot;deptno&quot;&gt;&lt;/id&gt; &lt;result property=&quot;dname&quot; column=&quot;dname&quot;&gt;&lt;/result&gt; &lt;result property=&quot;loc&quot; column=&quot;loc&quot;&gt;&lt;/result&gt; &lt;!--封装集合类的元素 property：指定集合的属性 ofType:指定集合中的元素类型 --&gt; &lt;collection property=&quot;emps&quot; ofType=&quot;com.mashibing.bean.Emp&quot; select=&quot;com.mashibing.dao.EmpDao.selectEmpByStep&quot; column=&quot;deptno&quot;&gt; &lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; Test 12345678910111213141516 @Test public void test09() &#123; // 获取数据库的会话 SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; DeptDao mapper = sqlSession.getMapper(DeptDao.class);// Dept deptAndEmps = mapper.getDeptAndEmps(10); Dept deptAndEmpsByStep = mapper.getDeptAndEmpsByStep(10); System.out.println(deptAndEmpsByStep); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125; ☀8.延迟查询 ​ 当我们在进行表关联的时候，有可能在查询结果的时候不需要关联对象的属性值，那么此时可以通过延迟加载来实现功能。在全局配置文件中添加如下属性 mybatis-config.xml 1234&lt;settings&gt; &lt;!--开启延时加载--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 如果设置了全局加载，但是希望在某一个sql语句查询的时候不适用延时策略，可以添加如下属性： 1&lt;association property=&quot;dept&quot; select=&quot;com.mashibing.dao.DeptDao.getDeptAndEmpsBySimple&quot; column=&quot;deptno&quot; fetchType=&quot;eager&quot;/&gt; ☀3.动态sql ​ 动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。 ​ 使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。 ​ 如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。 if choose (when, otherwise) trim (where, set) foreach ☀1.if EmpDao.xml 123456789101112&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where &lt;if test=&quot;empno!=null&quot;&gt; empno &gt; #&#123;empno&#125; and &lt;/if&gt; &lt;if test=&quot;ename!=null&quot;&gt; ename like #&#123;ename&#125; and &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt; sal &gt; #&#123;sal&#125; &lt;/if&gt; &lt;/select&gt; EmpDao.java 1public List&lt;Emp&gt; getEmpByCondition(Emp emp); Test.java 1234567891011121314151617181920@Test public void test10() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; EmpDao mapper = sqlSession.getMapper(EmpDao.class); Emp emp = new Emp(); emp.setEmpno(6500); emp.setEname(&quot;%E%&quot;); emp.setSal(500.0); List&lt;Emp&gt; empByCondition = mapper.getEmpByCondition(emp); for (Emp emp1 : empByCondition) &#123; System.out.println(emp1); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125; ​ 看起来测试是比较正常的，但是大家需要注意的是如果我们传入的参数值有缺失会怎么呢？这个时候拼接的sql语句就会变得有问题，例如不传参数或者丢失最后一个参数，那么语句中就会多一个where或者and的关键字，因此在mybatis中也给出了具体的解决方案： ​ where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除。 1234567891011121314&lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;where&gt; &lt;if test=&quot;empno!=null&quot;&gt; empno &gt; #&#123;empno&#125; &lt;/if&gt; &lt;if test=&quot;ename!=null&quot;&gt; and ename like #&#123;ename&#125; &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt; and sal &gt; #&#123;sal&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; ​ 现在看起来没有什么问题了，但是我们的条件添加到了拼接sql语句的前后，那么我们该如何处理呢？ 123456789101112131415161718192021&lt;!-- trim截取字符串： prefix：前缀，为sql整体添加一个前缀 prefixOverrides:去除整体字符串前面多余的字符 suffixOverrides:去除后面多余的字符串 --&gt; &lt;select id=&quot;getEmpByCondition&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;trim prefix=&quot;where&quot; prefixOverrides=&quot;and&quot; suffixOverrides=&quot;and&quot;&gt; &lt;if test=&quot;empno!=null&quot;&gt; empno &gt; #&#123;empno&#125; and &lt;/if&gt; &lt;if test=&quot;ename!=null&quot;&gt; ename like #&#123;ename&#125; and &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt; sal &gt; #&#123;sal&#125; and &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; ☀2.foreach ​ 动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。 1234567891011121314&lt;!--foreach是对集合进行遍历 collection=&quot;deptnos&quot; 指定要遍历的集合 close=&quot;&quot; 表示以什么结束 index=&quot;&quot; 给定一个索引值 item=&quot;&quot; 遍历的每一个元素的值 open=&quot;&quot; 表示以什么开始 separator=&quot;&quot; 表示多个元素的分隔符 --&gt; &lt;select id=&quot;getEmpByDeptnos&quot; resultType=&quot;Emp&quot;&gt; select * from emp where deptno in &lt;foreach collection=&quot;deptnos&quot; close=&quot;)&quot; index=&quot;idx&quot; item=&quot;deptno&quot; open=&quot;(&quot; separator=&quot;,&quot;&gt; #&#123;deptno&#125; &lt;/foreach&gt; &lt;/select&gt; ☀3.choose ​ 有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 12345678910111213141516171819&lt;select id=&quot;getEmpByConditionChoose&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;empno!=null&quot;&gt; empno &gt; #&#123;empno&#125; &lt;/when&gt; &lt;when test=&quot;ename!=null&quot;&gt; ename like #&#123;ename&#125; &lt;/when&gt; &lt;when test=&quot;sal!=null&quot;&gt; sal &gt; #&#123;sal&#125; &lt;/when&gt; &lt;otherwise&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; ☀4.set ​ 用于动态更新语句的类似解决方案叫做 set。set 元素可以用于动态包含需要更新的列，忽略其它不更新的列。 1234567891011121314151617&lt;update id=&quot;updateEmpByEmpno&quot;&gt; update emp &lt;set&gt; &lt;if test=&quot;empno!=null&quot;&gt; empno=#&#123;empno&#125;, &lt;/if&gt; &lt;if test=&quot;ename!=null&quot;&gt; ename = #&#123;ename&#125;, &lt;/if&gt; &lt;if test=&quot;sal!=null&quot;&gt; sal = #&#123;sal&#125; &lt;/if&gt; &lt;/set&gt; &lt;where&gt; empno = #&#123;empno&#125; &lt;/where&gt;&lt;/update&gt; ☀4.缓存 ​ MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。 ​ 默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行： 1&lt;cache/&gt; 当添加上该标签之后，会有如下效果： 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 在进行配置的时候还会分为一级缓存和二级缓存： 一级缓存：线程级别的缓存，是本地缓存，sqlSession级别的缓存 二级缓存：全局范围的缓存，不止局限于当前会话 ☀1.一级缓存的使用 ​ 一级缓存是sqlsession级别的缓存，默认是存在的。在下面的案例中，大家发现我发送了两个相同的请求，但是sql语句仅仅执行了一次，那么就意味着第一次查询的时候已经将结果进行了缓存。 12345678910111213141516171819202122@Test public void test01() &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); try &#123; EmpDao mapper = sqlSession.getMapper(EmpDao.class); List&lt;Emp&gt; list = mapper.selectAllEmp(); for (Emp emp : list) &#123; System.out.println(emp); &#125; System.out.println(&quot;--------------------------------&quot;); List&lt;Emp&gt; list2 = mapper.selectAllEmp(); for (Emp emp : list2) &#123; System.out.println(emp); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; &#125; ​ 在大部分的情况下一级缓存是可以的，但是有几种特殊的情况会造成一级缓存失效： 1、一级缓存是sqlSession级别的缓存，如果在应用程序中只有开启了多个sqlsession，那么会造成缓存失效 123456789101112131415161718@Test public void test02()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); List&lt;Emp&gt; list = mapper.selectAllEmp(); for (Emp emp : list) &#123; System.out.println(emp); &#125; System.out.println(&quot;================================&quot;); SqlSession sqlSession2 = sqlSessionFactory.openSession(); EmpDao mapper2 = sqlSession2.getMapper(EmpDao.class); List&lt;Emp&gt; list2 = mapper2.selectAllEmp(); for (Emp emp : list2) &#123; System.out.println(emp); &#125; sqlSession.close(); sqlSession2.close(); &#125; 2、在编写查询的sql语句的时候，一定要注意传递的参数，如果参数不一致，那么也不会缓存结果 3、如果在发送过程中发生了数据的修改，那么结果就不会缓存 123456789101112131415@Test public void test03()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); Emp empByEmpno = mapper.findEmpByEmpno(1111); System.out.println(empByEmpno); System.out.println(&quot;================================&quot;); empByEmpno.setEname(&quot;zhangsan&quot;); int i = mapper.updateEmp(empByEmpno); System.out.println(i); System.out.println(&quot;================================&quot;); Emp empByEmpno1 = mapper.findEmpByEmpno(1111); System.out.println(empByEmpno1); sqlSession.close(); &#125; 4、在两次查询期间，手动去清空缓存，也会让缓存失效 1234567891011121314@Test public void test03()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); Emp empByEmpno = mapper.findEmpByEmpno(1111); System.out.println(empByEmpno); System.out.println(&quot;================================&quot;); System.out.println(&quot;手动清空缓存&quot;); sqlSession.clearCache(); System.out.println(&quot;================================&quot;); Emp empByEmpno1 = mapper.findEmpByEmpno(1111); System.out.println(empByEmpno1); sqlSession.close(); &#125; ☀2.二级缓存 ​ 二级缓存是全局作用域缓存，默认是不开启的，需要手动进行配置。 ​ Mybatis提供二级缓存的接口以及实现，缓存实现的时候要求实体类实现Serializable接口，二级缓存在sqlSession关闭或提交之后才会生效。 ☀1.缓存的使用 ​ 步骤： ​ 1、全局配置文件中添加如下配置： 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; ​ 2、需要在使用二级缓存的映射文件出使用标签标注 ​ 3、实体类必须要实现Serializable接口 1234567891011121314@Testpublic void test04()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); EmpDao mapper2 = sqlSession2.getMapper(EmpDao.class); Emp empByEmpno = mapper.findEmpByEmpno(1111); System.out.println(empByEmpno); sqlSession.close(); Emp empByEmpno1 = mapper2.findEmpByEmpno(1111); System.out.println(empByEmpno1); sqlSession2.close();&#125; ☀2.缓存的属性 ​ eviction:表示缓存回收策略，默认是LRU ​ LRU：最近最少使用的，移除最长时间不被使用的对象 ​ FIFO：先进先出，按照对象进入缓存的顺序来移除 ​ SOFT：软引用，移除基于垃圾回收器状态和软引用规则的对象 ​ WEAK：弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象 ​ flushInternal:刷新间隔，单位毫秒 ​ 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新 ​ size：引用数目，正整数 ​ 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 ​ readonly：只读，true/false ​ true：只读缓存，会给所有调用这返回缓存对象的相同实例，因此这些对象不能被修改。 ​ false：读写缓存，会返回缓存对象的拷贝（序列化实现），这种方式比较安全，默认值 12345678910111213141516171819202122232425262728293031323334353637383940//可以看到会去二级缓存中查找数据，而且二级缓存跟一级缓存中不会同时存在数据，因为二级缓存中的数据是在sqlsession 关闭之后才生效的@Test public void test05()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); Emp empByEmpno = mapper.findEmpByEmpno(1111); System.out.println(empByEmpno); sqlSession.close(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); EmpDao mapper2 = sqlSession2.getMapper(EmpDao.class); Emp empByEmpno2 = mapper2.findEmpByEmpno(1111); System.out.println(empByEmpno2); Emp empByEmpno3 = mapper2.findEmpByEmpno(1111); System.out.println(empByEmpno3); sqlSession2.close(); &#125;// 缓存查询的顺序是先查询二级缓存再查询一级缓存 @Test public void test05()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); Emp empByEmpno = mapper.findEmpByEmpno(1111); System.out.println(empByEmpno); sqlSession.close(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); EmpDao mapper2 = sqlSession2.getMapper(EmpDao.class); Emp empByEmpno2 = mapper2.findEmpByEmpno(1111); System.out.println(empByEmpno2); Emp empByEmpno3 = mapper2.findEmpByEmpno(1111); System.out.println(empByEmpno3); Emp empByEmpno4 = mapper2.findEmpByEmpno(7369); System.out.println(empByEmpno4); Emp empByEmpno5 = mapper2.findEmpByEmpno(7369); System.out.println(empByEmpno5); sqlSession2.close(); &#125; 3、二级缓存的作用范围： ​ 如果设置了全局的二级缓存配置，那么在使用的时候需要注意，在每一个单独的select语句中，可以设置将查询缓存关闭，以完成特殊的设置 ​ 1、在setting中设置，是配置二级缓存开启，一级缓存默认一直开启 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; ​ 2、select标签的useCache属性： ​ 在每一个select的查询中可以设置当前查询是否要使用二级缓存，只对二级缓存有效 ​ 3、sql标签的flushCache属性 ​ 增删改操作默认值为true，sql执行之后会清空一级缓存和二级缓存，而查询操作默认是false ​ 4、sqlSession.clearCache() ​ 只是用来清楚一级缓存 ☀3.整合第三方缓存 ​ 在某些情况下我们也可以自定义实现缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。 ​ 1、导入对应的maven依赖 12345678910111213141516171819202122232425&lt;!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --&gt; &lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; ​ 2、导入ehcache配置文件 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt; &lt;!-- 磁盘保存路径 --&gt; &lt;diskStore path=&quot;D:\\ehcache&quot; /&gt; &lt;defaultCache maxElementsInMemory=&quot;1&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt;&lt;/ehcache&gt;&lt;!--属性说明：l diskStore：指定数据在磁盘中的存储位置。l defaultCache：当借助CacheManager.add(&quot;demoCache&quot;)创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略以下属性是必须的：l maxElementsInMemory - 在内存中缓存的element的最大数目l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上以下属性是可选的：l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） --&gt; ​ 3、在mapper文件中添加自定义缓存 1&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;&gt;&lt;/cache&gt;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://aner1001.gitee.io/tags/Mybatis/"}]},{"title":"Mybatis学习笔记1-介绍和基本使用","slug":"技术知识/Java/框架/Mybatis/Mybatis学习笔记1-介绍和基本使用","date":"2021-02-28T13:34:10.000Z","updated":"2021-02-28T13:34:10.000Z","comments":true,"path":"posts/2021/02/28/07b533182cc8/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/28/07b533182cc8/","excerpt":"MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。","text":"MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 ☀0.数据库操作框架的历程 ☀(1)JDBC ​ JDBC(Java Data Base Connection,java数据库连接)是一种用于执行SQL语句的Java API,可以为多种关系数据库提供统一访问,它由一组用Java语言编写的类和接口组成.JDBC提供了一种基准,据此可以构建更高级的工具和接口,使数据库开发人员能够编写数据库应用程序 优点：运行期：快捷、高效 缺点：编辑期：代码量大、繁琐异常处理、不支持数据库跨平台 ☀(2)DBUtils ​ DBUtils是Java编程中的数据库操作实用工具，小巧简单实用。 ​ DBUtils封装了对JDBC的操作，简化了JDBC操作，可以少写代码。 ​ DBUtils三个核心功能介绍 ​ 1、QueryRunner中提供对sql语句操作的API ​ 2、ResultSetHandler接口，用于定义select操作后，怎样封装结果集 ​ 3、DBUtils类，它就是一个工具类，定义了关闭资源与事务处理的方法 ☀(3)Hibernate ​ Hibernate 是由 Gavin King 于 2001 年创建的开放源代码的对象关系框架。它强大且高效的构建具有关系对象持久性和查询服务的 Java 应用程序。 ​ Hibernate 将 Java 类映射到数据库表中，从 Java 数据类型中映射到 SQL 数据类型中，并把开发人员从 95% 的公共数据持续性编程工作中解放出来。 ​ Hibernate 是传统 Java 对象和数据库服务器之间的桥梁，用来处理基于 O/R 映射机制和模式的那些对象。 Hibernate 优势 Hibernate 使用 XML 文件来处理映射 Java 类别到数据库表格中，并且不用编写任何代码。 为在数据库中直接储存和检索 Java 对象提供简单的 APIs。 如果在数据库中或任何其它表格中出现变化，那么仅需要改变 XML 文件属性。 抽象不熟悉的 SQL 类型，并为我们提供工作中所熟悉的 Java 对象。 Hibernate 不需要应用程序服务器来操作。 操控你数据库中对象复杂的关联。 最小化与访问数据库的智能提取策略。 提供简单的数据询问。 Hibernate劣势 hibernate的完全封装导致无法使用数据的一些功能。 Hibernate的缓存问题。 Hibernate对于代码的耦合度太高。 Hibernate寻找bug困难。 Hibernate批量数据操作需要大量的内存空间而且执行过程中需要的对象太多 ☀(4)JDBCTemplate JdbcTemplate针对数据查询提供了多个重载的模板方法,你可以根据需要选用不同的模板方法.如果你的查询很简单，仅仅是传入相应SQL或者相关参数，然后取得一个单一的结果，那么你可以选择如下一组便利的模板方法。 优点：运行期：高效、内嵌Spring框架中、支持基于AOP的声明式事务 ​缺点：必须于Spring框架结合在一起使用、不支持数据库跨平台、默认没有缓存 ☀1.什么是Mybatis？ MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 优点： 1、与JDBC相比，减少了50%的代码量 2、 最简单的持久化框架，简单易学 3、SQL代码从程序代码中彻底分离出来，可以重用 4、提供XML标签，支持编写动态SQL 5、提供映射标签，支持对象与数据库的ORM字段关系映射 缺点： 1、SQL语句编写工作量大，熟练度要高 2、数据库移植性比较差，如果需要切换数据库的话，SQL语句会有很大的差异 ☀2.第一个Mybatis项目 1、创建普通的maven项目 2、导入相关的依赖 pom.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;mybatis_helloworld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、创建对应的数据表，数据表我们使用之前的demo数据库，脚本文件在群里，大家自行去下载安装 4、创建与表对应的实体类对象 emp.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.mashibing.bean;import java.util.Date;public class Emp &#123; private Integer empno; private String ename; private String job; private Integer mgr; private Date hiredate; private Double sal; private Double common; private Integer deptno; public Emp() &#123; &#125; public Emp(Integer empno, String ename, String job, Integer mgr, Date hiredate, Double sal, Double common, Integer deptno) &#123; this.empno = empno; this.ename = ename; this.job = job; this.mgr = mgr; this.hiredate = hiredate; this.sal = sal; this.common = common; this.deptno = deptno; &#125; public Integer getEmpno() &#123; return empno; &#125; public void setEmpno(Integer empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public String getJob() &#123; return job; &#125; public void setJob(String job) &#123; this.job = job; &#125; public Integer getMgr() &#123; return mgr; &#125; public void setMgr(Integer mgr) &#123; this.mgr = mgr; &#125; public Date getHiredate() &#123; return hiredate; &#125; public void setHiredate(Date hiredate) &#123; this.hiredate = hiredate; &#125; public Double getSal() &#123; return sal; &#125; public void setSal(Double sal) &#123; this.sal = sal; &#125; public Double getCommon() &#123; return common; &#125; public void setCommon(Double common) &#123; this.common = common; &#125; public Integer getDeptno() &#123; return deptno; &#125; public void setDeptno(Integer deptno) &#123; this.deptno = deptno; &#125; @Override public String toString() &#123; return &quot;Emp&#123;&quot; + &quot;empno=&quot; + empno + &quot;, ename=&#x27;&quot; + ename + &#x27;\\&#x27;&#x27; + &quot;, job=&#x27;&quot; + job + &#x27;\\&#x27;&#x27; + &quot;, mgr=&quot; + mgr + &quot;, hiredate=&quot; + hiredate + &quot;, sal=&quot; + sal + &quot;, common=&quot; + common + &quot;, deptno=&quot; + deptno + &#x27;&#125;&#x27;; &#125;&#125; ​ 5、创建对应的dao类 EmpDao.java 123456789package com.mashibing.dao;import com.mashibing.bean.Emp;public interface EmpDao &#123; public Emp findEmpByEmpno(Integer empno);&#125; ​ 6、编写配置文件 log4j.properties mybatis-config.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!--配置数据库连接--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo?serverTimezone=UTC&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入每一个接口对应点xml文件--&gt; &lt;mappers&gt; &lt;mapper resource=&quot;EmpDao.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; EmpDao.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace:编写接口的全类名，就是告诉要实现该配置文件是哪个接口的具体实现--&gt;&lt;mapper namespace=&quot;com.mashibing.dao.EmpDao&quot;&gt; &lt;!-- select:表示这个操作是一个查询操作 id表示的是要匹配的方法的名称 resultType:表示返回值的类型，查询操作必须要包含返回值的类型 #&#123;属性名&#125;：表示要传递的参数的名称 --&gt; &lt;select id=&quot;findEmpByEmpno&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt;&lt;/mapper&gt; ​ 7、编写测试类 MyTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.mashibing.test;import com.mashibing.bean.Emp;import com.mashibing.dao.EmpDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;public class MyTest &#123; @Test public void test01() &#123; // 根据全局配置文件创建出SqlSessionFactory // SqlSessionFactory:负责创建SqlSession对象的工厂 // SqlSession:表示跟数据库建议的一次会话 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); // 获取数据库的会话 SqlSession sqlSession = sqlSessionFactory.openSession(); Emp empByEmpno = null; try &#123; // 获取要调用的接口类 EmpDao mapper = sqlSession.getMapper(EmpDao.class); // 调用方法开始执行 empByEmpno = mapper.findEmpByEmpno(7369); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; System.out.println(empByEmpno); &#125;&#125; ☀3.增删改查的基本操作 EmpDao.java 123456789101112131415package com.mashibing.dao;import com.mashibing.bean.Emp;public interface EmpDao &#123; public Emp findEmpByEmpno(Integer empno); public int updateEmp(Emp emp); public int deleteEmp(Integer empno); public int insertEmp(Emp emp);&#125; EmpDao.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!--namespace:编写接口的全类名，就是告诉要实现该配置文件是哪个接口的具体实现--&gt;&lt;mapper namespace=&quot;com.mashibing.dao.EmpDao&quot;&gt; &lt;!-- select:表示这个操作是一个查询操作 id表示的是要匹配的方法的名称 resultType:表示返回值的类型，查询操作必须要包含返回值的类型 #&#123;属性名&#125;：表示要传递的参数的名称 --&gt; &lt;select id=&quot;findEmpByEmpno&quot; resultType=&quot;com.mashibing.bean.Emp&quot;&gt; select * from emp where empno = #&#123;empno&#125; &lt;/select&gt; &lt;!--增删改查操作不需要返回值，增删改返回的是影响的行数，mybatis会自动做判断--&gt; &lt;insert id=&quot;insertEmp&quot;&gt; insert into emp(empno,ename) values(#&#123;empno&#125;,#&#123;ename&#125;) &lt;/insert&gt; &lt;update id=&quot;updateEmp&quot;&gt; update emp set ename=#&#123;ename&#125; where empno = #&#123;empno&#125; &lt;/update&gt; &lt;delete id=&quot;deleteEmp&quot;&gt; delete from emp where empno = #&#123;empno&#125; &lt;/delete&gt;&lt;/mapper&gt; MyTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.mashibing.test;import com.mashibing.bean.Emp;import com.mashibing.dao.EmpDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;public class MyTest &#123; SqlSessionFactory sqlSessionFactory = null; @Before public void init()&#123; // 根据全局配置文件创建出SqlSessionFactory // SqlSessionFactory:负责创建SqlSession对象的工厂 // SqlSession:表示跟数据库建议的一次会话 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory= new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void test01() &#123; // 获取数据库的会话 SqlSession sqlSession = sqlSessionFactory.openSession(); Emp empByEmpno = null; try &#123; // 获取要调用的接口类 EmpDao mapper = sqlSession.getMapper(EmpDao.class); // 调用方法开始执行 empByEmpno = mapper.findEmpByEmpno(7369); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; System.out.println(empByEmpno); &#125; @Test public void test02()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); int zhangsan = mapper.insertEmp(new Emp(1111, &quot;zhangsan&quot;)); System.out.println(zhangsan); sqlSession.commit(); sqlSession.close(); &#125; @Test public void test03()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); int zhangsan = mapper.updateEmp(new Emp(1111, &quot;lisi&quot;)); System.out.println(zhangsan); sqlSession.commit(); sqlSession.close(); &#125; @Test public void test04()&#123; SqlSession sqlSession = sqlSessionFactory.openSession(); EmpDao mapper = sqlSession.getMapper(EmpDao.class); int zhangsan = mapper.deleteEmp(1111); System.out.println(zhangsan); sqlSession.commit(); sqlSession.close(); &#125;&#125; ☀4.配置文件详解 ​ 在mybatis的项目中，我们发现了有一个mybatis-config.xml的配置文件，这个配置文件是mybatis的全局配置文件，用来进行相关的全局配置，在任何操作下都生效的配置。下面我们要针对其中的属性做详细的解释，方便大家在后续使用的时候更加熟练。 mybatis-config.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--引入外部配置文件，类似于Spring中的property-placeholder resource:从类路径引入 url:从磁盘路径或者网络路径引入 --&gt; &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt; &lt;!--用来控制mybatis运行时的行为，是mybatis中的重要配置--&gt; &lt;settings&gt; &lt;!--设置列名映射的时候是否是驼峰标识--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!--typeAliases表示为我们引用的实体类起别名，默认情况下我们需要写类的完全限定名 如果在此处做了配置，那么可以直接写类的名称,在type中配置上类的完全限定名，在使用的时候可以忽略大小写 还可以通过alias属性来表示类的别名 --&gt; &lt;typeAliases&gt;&lt;!-- &lt;typeAlias type=&quot;com.mashibing.bean.Emp&quot; alias=&quot;Emp&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--如果需要引用多个类，那么给每一个类起别名肯定会很麻烦，因此可以指定对应的包名，那么默认用的是类名--&gt; &lt;package name=&quot;com.mashibing.bean&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- 在实际的开发过程中，我们可能分为开发环境，生产环境，测试环境等等，每个环境的配置可以是不一样的 environment就用来表示不同环境的细节配置，每一个环境中都需要一个事务管理器以及数据源的配置 我们在后续的项目开发中几乎都是使用spring中配置的数据源和事务管理器来配置，此处不需要研究 --&gt; &lt;!--default:用来选择需要的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;!--id:表示不同环境的名称--&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!--配置数据库连接--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--使用$&#123;&#125;来引入外部变量--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driverClassname&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 在不同的数据库中，可能sql语句的写法是不一样的，为了增强移植性，可以提供不同数据库的操作实现 在编写不同的sql语句的时候，可以指定databaseId属性来标识当前sql语句可以运行在哪个数据库中 --&gt; &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt; &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt; &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt; &lt;property name=&quot;Oracle&quot; value=&quot;orcl&quot;/&gt; &lt;/databaseIdProvider&gt; &lt;!--将sql的映射文件适用mappers进行映射--&gt; &lt;mappers&gt; &lt;!-- 指定具体的不同的配置文件 class:直接引入接口的全类名，可以将xml文件放在dao的同级目录下，并且设置相同的文件名称，同时可以使用注解的方式来进行相关的配置 url:可以从磁盘或者网络路径查找sql映射文件 resource:在类路径下寻找sql映射文件 --&gt;&lt;!-- &lt;mapper resource=&quot;EmpDao.xml&quot;/&gt; &lt;mapper resource=&quot;UserDao.xml&quot;/&gt; &lt;mapper class=&quot;com.mashibing.dao.EmpDaoAnnotation&quot;&gt;&lt;/mapper&gt;--&gt; &lt;!-- 当包含多个配置文件或者配置类的时候，可以使用批量注册的功能，也就是引入对应的包，而不是具体的配置文件或者类 但是需要注意的是， 1、如果使用的配置文件的形式，必须要将配置文件跟dao类放在一起，这样才能找到对应的配置文件. 如果是maven的项目的话，还需要添加以下配置，原因是maven在编译的文件的时候只会编译java文件 &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 2、将配置文件在resources资源路径下创建跟dao相同的包名 --&gt; &lt;package name=&quot;com.mashibing.dao&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; EmpDaoAnnotation.java 1234567891011121314151617181920212223package com.mashibing.dao;import com.mashibing.bean.Emp;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;public interface EmpDaoAnnotation &#123; @Select(&quot;select * from emp where empno = #&#123;empno&#125;&quot;) public Emp findEmpByEmpno(Integer empno); @Update(&quot;update emp set ename=#&#123;ename&#125; where empno = #&#123;empno&#125;&quot;) public int updateEmp(Emp emp); @Delete(&quot;delete from emp where empno = #&#123;empno&#125;&quot;) public int deleteEmp(Integer empno); @Insert(&quot;insert into emp(empno,ename) values(#&#123;empno&#125;,#&#123;ename&#125;)&quot;) public int insertEmp(Emp emp);&#125;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://aner1001.gitee.io/tags/Mybatis/"}]},{"title":"SpringMVC学习笔记3-返回处理","slug":"技术知识/Java/框架/SpringMVC/SpringMVC学习笔记3-返回处理","date":"2021-02-27T11:28:56.000Z","updated":"2021-02-27T11:28:56.000Z","comments":true,"path":"posts/2021/02/27/4e303419b6e9/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/27/4e303419b6e9/","excerpt":"ajax中，我们返回的数据经常需要使用json，那么如何来保证返回的数据的是json格式呢？","text":"ajax中，我们返回的数据经常需要使用json，那么如何来保证返回的数据的是json格式呢？ ☀1.@ResponseBody的返回JSON数据 ​ 到目前为止我们编写的所有Controller的方法的返回值都是String类型，但是大家应该都知道，我们有时候数据传递特别是在ajax中，我们返回的数据经常需要使用json，那么如何来保证返回的数据的是json格式呢？使用@ResponseBody注解 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;springmv_ajax&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; springmvc.xml 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; JsonController.java 123456789101112131415161718192021222324package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.ArrayList;import java.util.Date;import java.util.List;@Controllerpublic class JsonController &#123; @ResponseBody @RequestMapping(&quot;/json&quot;) public List&lt;User&gt; json()&#123; List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(new User(1,&quot;zhangsan&quot;,12,&quot;男&quot;,new Date(),&quot;1234@qq.com&quot;)); list.add(new User(2,&quot;zhangsan2&quot;,12,&quot;男&quot;,new Date(),&quot;1234@qq.com&quot;)); list.add(new User(3,&quot;zhangsan3&quot;,12,&quot;男&quot;,new Date(),&quot;1234@qq.com&quot;)); return list; &#125;&#125; User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package com.mashibing.bean;import com.fasterxml.jackson.annotation.JsonFormat;import com.fasterxml.jackson.annotation.JsonIgnore;import java.util.Date;public class User &#123; private Integer id; private String name; private Integer age; private String gender; @JsonFormat( pattern = &quot;yyyy-MM-dd&quot;) private Date birth; @JsonIgnore private String email; public User() &#123; &#125; public User(Integer id, String name, Integer age, String gender, Date birth, String email) &#123; this.id = id; this.name = name; this.age = age; this.gender = gender; this.birth = birth; this.email = email; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 同时@ResponseBody可以直接将返回的字符串数据作为响应内容 1234567891011121314151617package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.http.HttpEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class OtherController &#123; @ResponseBody @RequestMapping(&quot;/testResponseBody&quot;) public String testResponseBody()&#123; return &quot;&lt;h1&gt;success&lt;/h1&gt;&quot;; &#125;&#125; 2.发送ajax请求获取json数据 ajax.jsp 12345678910111213141516171819202122232425262728293031323334&lt;%@ page import=&quot;java.util.Date&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;% pageContext.setAttribute(&quot;ctp&quot;,request.getContextPath());%&gt;&lt;body&gt;&lt;%=new Date()%&gt;&lt;a href=&quot;$&#123;ctp&#125;/json&quot;&gt;获取用户信息&lt;/a&gt;&lt;div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;a:first&quot;).click(function () &#123; $.ajax(&#123; url:&quot;$&#123;ctp&#125;/json&quot;, type:&quot;GET&quot;, success:function (data) &#123; console.log(data) $.each(data,function() &#123; var user = this.id+&quot;--&quot;+this.name+&quot;--&quot;+this.age+&quot;--&quot;+this.gender+&quot;--&quot;+this.birth+&quot;--&quot;+this.email; $(&quot;div&quot;).append(user+&#x27;&lt;br/&gt;&#x27;); &#125;) &#125; &#125;); return false; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ☀2.使用@RequestBody获取请求体信息 testOther.jsp 123456789101112131415161718192021222324&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/13 Time: 15:04 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;% pageContext.setAttribute(&quot;ctp&quot;,request.getContextPath());%&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;ctp&#125;/testRequestBody&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;br&gt; &lt;input name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; OtherController.java 123456789101112131415package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class OtherController &#123; @RequestMapping(&quot;/testRequestBody&quot;) public String testRequestBody(@RequestBody String body)&#123; System.out.println(&quot;请求体：&quot;+body); return &quot;success&quot;; &#125;&#125; 同时@RequestBody能够接受json格式的请求数据： testOther.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/13 Time: 15:04 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;&lt;html&gt;&lt;% pageContext.setAttribute(&quot;ctp&quot;,request.getContextPath());%&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;$&#123;ctp&#125;/testRequestBody&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input name=&quot;username&quot; value=&quot;zhangsan&quot;&gt;&lt;br&gt; &lt;input name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;br&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; &gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;br&gt;&lt;/form&gt;&lt;hr/&gt;&lt;a href=&quot;$&#123;ctp&#125;/testRequestJson&quot;&gt;发送json数据&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt; $(&quot;a:first&quot;).click(function () &#123; var user = &#123;id:&quot;1&quot;,name:&quot;zhangsan&quot;,age:&quot;12&quot;,gender:&quot;男&quot;,birth:&quot;2020-3-13&quot;,email:&quot;123@qq.com&quot;&#125;; var userJson = JSON.stringify(user); $.ajax(&#123; url:&quot;$&#123;ctp&#125;/testRequestJson&quot;, type:&quot;POST&quot;, data:userJson, contentType:&quot;application/json&quot;, success:function (data) &#123; alert(data); &#125; &#125;); return false; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; OtherController.java 12345678910111213141516171819202122package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class OtherController &#123; @RequestMapping(&quot;/testRequestBody&quot;) public String testRequestBody(@RequestBody String body)&#123; System.out.println(&quot;请求体：&quot;+body); return &quot;success&quot;; &#125; @RequestMapping(&quot;/testRequestJson&quot;) public String testRequestBody(@RequestBody User user)&#123; System.out.println(&quot;对象：&quot;+user); return &quot;success&quot;; &#125;&#125; 在接受请求的时候还可以使用HttpEntity对象，用来接受参数，可以获取请求头信息。 12345678910111213141516171819package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.http.HttpEntity;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class OtherController &#123; @RequestMapping(&quot;/testHttpEntity&quot;) public String testRequestBody(HttpEntity&lt;String&gt; httpEntity)&#123; System.out.println(httpEntity); return &quot;success&quot;; &#125;&#125; ☀3.使用RespsonseEntity可以用来定制响应内容 12345678910111213141516171819202122232425package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.util.MultiValueMap;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class OtherController &#123; @RequestMapping(&quot;/testResponseEntity&quot;) public ResponseEntity&lt;String&gt; testResponseEntity()&#123; String body = &quot;&lt;h1&gt;hello&lt;/h1&gt;&quot;; MultiValueMap&lt;String,String&gt; header = new HttpHeaders(); header.add(&quot;Set-Cookie&quot;,&quot;name=zhangsan&quot;); return new ResponseEntity&lt;String&gt;(body,header, HttpStatus.OK); &#125;&#125; ☀4.文件下载 1234567891011121314151617181920212223242526272829303132333435363738package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.util.MultiValueMap;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.ServletContext;import javax.servlet.http.HttpServletRequest;import java.io.FileInputStream;import java.io.FileNotFoundException;@Controllerpublic class OtherController &#123; @RequestMapping(&quot;/download&quot;) public ResponseEntity&lt;byte[]&gt; download(HttpServletRequest request) throws Exception &#123; //获取要下载文件的路径及输入流对象 ServletContext servletContext = request.getServletContext(); String realPath = servletContext.getRealPath(&quot;/script/jquery-1.9.1.min.js&quot;); FileInputStream fileInputStream = new FileInputStream(realPath); byte[] bytes = new byte[fileInputStream.available()]; fileInputStream.read(bytes); fileInputStream.close(); //将要下载文件内容返回 HttpHeaders httpHeaders = new HttpHeaders(); httpHeaders.set(&quot;Content-Disposition&quot;,&quot;attachment;filename=jquery-1.9.1.min.js&quot;); return new ResponseEntity&lt;byte[]&gt;(bytes,httpHeaders,HttpStatus.OK); &#125;&#125; ☀5.文件上传 ​ Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResovler ​ Spring MVC 上下文中默认没有装配 MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用 Spring 的文件上传功能，需现在上下文中配置 MultipartResolver。 pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;springmvc_upload&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-io/commons-io --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; web.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; springmvc.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;1024000&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; index.jsp 123456789101112131415161718192021&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/13 Time: 17:00 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;testUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件: &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br&gt;&lt;br&gt; 描述: &lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; UploadHandler.java 123456789101112131415161718192021222324package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.io.InputStream;@Controllerpublic class UploadHandler &#123; @RequestMapping(value = &quot;/testUpload&quot;, method = RequestMethod.POST) public String testUpload(@RequestParam(value = &quot;desc&quot;, required = false) String desc, @RequestParam(&quot;file&quot;) MultipartFile multipartFile) throws IOException &#123; System.out.println(&quot;desc : &quot; + desc); System.out.println(&quot;OriginalFilename : &quot; + multipartFile.getOriginalFilename()); multipartFile.transferTo(new File(&quot;D:\\\\file\\\\&quot;+multipartFile.getOriginalFilename())); return &quot;success&quot;; //增加成功页面: /views/success.jsp &#125;&#125; success.jsp 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/13 Time: 17:03 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;success&lt;/body&gt;&lt;/html&gt; 如果是多文件上传，那么又改如何处理呢？ index.jsp 1234567891011121314151617181920212223&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/13 Time: 17:00 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;testUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 文件: &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br&gt;&lt;br&gt; 文件: &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br&gt;&lt;br&gt; 文件: &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;&lt;br&gt;&lt;br&gt; 描述: &lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; UploadHandler.java 12345678910111213141516171819202122232425262728package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.io.InputStream;@Controllerpublic class UploadHandler &#123; @RequestMapping(value = &quot;/testUpload&quot;, method = RequestMethod.POST) public String testUpload(@RequestParam(value = &quot;desc&quot;, required = false) String desc, @RequestParam(&quot;file&quot;) MultipartFile[] multipartFile) throws IOException &#123; System.out.println(&quot;desc : &quot; + desc); for (MultipartFile file : multipartFile) &#123; if (!file.isEmpty()) &#123; System.out.println(&quot;OriginalFilename : &quot; + file.getOriginalFilename()); file.transferTo(new File(&quot;D:\\\\file\\\\&quot; + file.getOriginalFilename())); &#125; &#125; return &quot;success&quot;; //增加成功页面: /views/success.jsp &#125;&#125; ☀7.Springmvc拦截器 ​ SpringMVC提供了拦截器机制，允许运行目标方法之前进行一些拦截工作或者目标方法运行之后进行一下其他相关的处理。自定义的拦截器必须实现HandlerInterceptor接口。 ​ preHandle()：这个方法在业务处理器处理请求之前被调用，在该方法中对用户请求 request 进行处理。如果程序员决定该拦截器对请求进行拦截处理后还要调用其他的拦截器，或者是业务处理器去进行处理，则返回true；如果程序员决定不需要再调用其他的组件去处理请求，则返回false ​ postHandle()：这个方法在业务处理器处理完请求后，但是DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求request进行处理。 ​ afterCompletion()：这个方法在DispatcherServlet完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。 ☀1.自定义第一个拦截器 MyFirstInterceptor.java 123456789101112131415161718192021222324package com.mashibing.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MyFirstInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(this.getClass().getName()+&quot;-------&gt;preHandle&quot;); return true; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(this.getClass().getName()+&quot;-------&gt;postHandle&quot;); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(this.getClass().getName()+&quot;-------&gt;afterCompletion&quot;); &#125;&#125; TestInterceptorController.java 1234567891011121314package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class TestInterceptorController &#123; @RequestMapping(&quot;test01&quot;) public String test01()&#123; System.out.println(&quot;test01&quot;); return &quot;success&quot;; &#125;&#125; springmvc.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:interceptors&gt; &lt;bean class=&quot;com.mashibing.interceptor.MyFirstInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; success.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(&quot;success.jsp&quot;);%&gt;success&lt;/body&gt;&lt;/html&gt; ​ 通过运行结果能够发现拦截器的执行顺序如下： ​ 可以看到先执行拦截器的preHandle方法----》执行目标方法----》执行拦截器的postHandle方法----》执行页面跳转----》执行拦截器的afterCompletion方法 ​ 在配置拦截器的时候有两个需要注意的点： ​ 1、如果prehandle方法返回值 为false，那么意味着不放行，那么就会造成后续的所有操作都中断 ​ 2、如果执行到方法中出现异常，那么后续流程不会处理但是afterCompletion方法会执行 ☀2.定义多个拦截器 ​ 再添加另外一个拦截器 MySecondInterceptor.java 123456789101112131415161718192021222324package com.mashibing.interceptor;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class MySecondInterceptor implements HandlerInterceptor &#123; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(this.getClass().getName()+&quot;-------&gt;preHandle&quot;); return true; &#125; public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(this.getClass().getName()+&quot;-------&gt;postHandle&quot;); &#125; public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(this.getClass().getName()+&quot;-------&gt;afterCompletion&quot;); &#125;&#125; 看到如下执行顺序： 调整两个拦截器的配置顺序： 大家可以看到对应的效果，谁先执行取决于配置的顺序。 ​ 拦截器的preHandle是按照顺序执行的 ​ 拦截器的postHandle是按照逆序执行的 ​ 拦截器的afterCompletion是按照逆序执行的 ​ 如果执行的时候核心的业务代码出问题了，那么已经通过的拦截器的afterCompletion会接着执行。 ☀8.拦截器跟过滤器的区别 ​ 1、过滤器是基于函数回调的，而拦截器是基于java反射的 ​ 2、过滤器依赖于servlet容器，而拦截器不依赖与Servlet容器 ​ 3、过滤器几乎对所有的请求都起作用，而拦截器只能对action请求起作用 ​ 4、拦截器可以访问action的上下文，而过滤器不可以 ​ 5、在controller的生命周期中，拦截器可以多次调用，而过滤器只能在web容器初始化的时候初始化一次，后续匹配的所有请求都会经过过滤器来进行过滤 ☀9.SpringMVC的国际化操作 ​ 在日常工作中，如果你的网站需要给不同语言地区的人进行查看，此时就需要使用国际化的基本操作，springmvc的国际化操作比较容易。 index.jsp 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/13 Time: 17:00 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;i18n&quot;&gt;国际化页面登录&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; login.jsp 123456789101112131415&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;fmt:message key=&quot;welcomeinfo&quot;/&gt;&lt;/h1&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot; &gt; &lt;fmt:message key=&quot;username&quot;/&gt;: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;fmt:message key=&quot;password&quot;/&gt;: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;&lt;fmt:message key=&quot;loginBtn&quot;/&gt;&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; I18nController.java 12345678910111213package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class I18nController &#123; @RequestMapping(&quot;i18n&quot;) public String i18n()&#123; return &quot;login&quot;; &#125;&#125; login_en_US.properties 1234welcomeinfo=welcome to mashibing.comusername=USERNAMEpassword=PASSWORDloginBtn=LOGIN login_zh_CN.properties 1234welcomeinfo=欢迎进入马士兵教育username=用户名password=密码loginBtn=登录 springmvc.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;login&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 其实SpringMVC中国际化的处理非常简单，就是按照浏览器所带来的语言信息决定的。 1Locale locale = request.getLocale();//获取浏览器的区域信息 在DispatcherServlet中会包含一个组件，用来专门获取区域信息 通过图片能够发现，默认调用的是org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver类 在程序中可以获取Locale的相关信息： 1234567891011121314151617181920212223package com.mashibing.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Locale;@Controllerpublic class I18nController &#123; @Autowired private MessageSource messageSource; @RequestMapping(&quot;i18n&quot;) public String i18n(Locale locale)&#123; System.out.println(locale); String username = messageSource.getMessage(&quot;username&quot;, null, locale); System.out.println(username); return &quot;login&quot;; &#125;&#125; ☀10.通过超链接来切换国际化 login.jsp 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot;%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;fmt:message key=&quot;welcomeinfo&quot;/&gt;&lt;/h1&gt;&lt;form action=&quot;login&quot; method=&quot;post&quot; &gt; &lt;fmt:message key=&quot;username&quot;/&gt;: &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;fmt:message key=&quot;password&quot;/&gt;: &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;&lt;fmt:message key=&quot;loginBtn&quot;/&gt;&quot;/&gt; &lt;a href=&quot;i18n?locale=zh_CN&quot;&gt;中文&lt;/a&gt;&lt;a href=&quot;i18n?locale=en_US&quot;&gt;英文&lt;/a&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; MyLocaleResolver.java 1234567891011121314151617181920212223242526272829303132333435363738package com.mashibing;import org.springframework.web.servlet.LocaleResolver;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Locale;public class MyLocaleResolver implements LocaleResolver &#123; /** * 解析并返回locale * @param request * @return */ @Override public Locale resolveLocale(HttpServletRequest request) &#123; Locale locale = null; String localeStr = request.getParameter(&quot;locale&quot;); if(localeStr!=null &amp;&amp; ! &quot;&quot;.equals(localeStr))&#123; locale = new Locale(localeStr.split(&quot;_&quot;)[0],localeStr.split(&quot;_&quot;)[1]); &#125;else&#123; locale = request.getLocale(); &#125; return locale; &#125; /** * 不支持设置locale的信息 * @param request * @param response * @param locale */ @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123; throw new UnsupportedOperationException( &quot;Cannot change HTTP accept header - use a different locale resolution strategy&quot;); &#125;&#125; springmvc.xml 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;login&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!--配置区域信息解析器--&gt; &lt;bean id=&quot;localeResolver&quot; class=&quot;com.mashibing.MyLocaleResolver&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 除了可以自定义区域信息解析器之外，我们还可以使用SpringMVC中自带的SessionLocaleResolver: I18nController.java 12345678910111213141516171819202122232425262728293031package com.mashibing.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import javax.servlet.http.HttpSession;import java.util.Locale;@Controllerpublic class I18nController &#123; @Autowired private MessageSource messageSource; @RequestMapping(&quot;i18n&quot;) public String i18n(@RequestParam(value = &quot;locale&quot;,defaultValue = &quot;zh_CN&quot;) String localeStr,Locale locale, HttpSession session)&#123; Locale l = null; if(localeStr!=null &amp;&amp; ! &quot;&quot;.equals(localeStr))&#123; l = new Locale(localeStr.split(&quot;_&quot;)[0],localeStr.split(&quot;_&quot;)[1]); &#125;else&#123; l = locale; &#125; session.setAttribute(SessionLocaleResolver.class.getName() + &quot;.LOCALE&quot;,l); return &quot;login&quot;; &#125;&#125; springmvc.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;login&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!--配置区域信息解析器--&gt;&lt;!-- &lt;bean id=&quot;localeResolver&quot; class=&quot;com.mashibing.MyLocaleResolver&quot;&gt;&lt;/bean&gt;--&gt; &lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 使用LocaleChangeInterceptor来实现国际化： springmvc.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;--&gt;&lt;!-- &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;property name=&quot;maxUploadSize&quot; value=&quot;1024000&quot;&gt;&lt;/property&gt;--&gt;&lt;!-- &lt;/bean&gt;--&gt;&lt;!-- &lt;mvc:interceptors&gt;--&gt;&lt;!-- &lt;bean class=&quot;com.mashibing.interceptor.MySecondInterceptor&quot;&gt;&lt;/bean&gt;--&gt;&lt;!-- &lt;bean class=&quot;com.mashibing.interceptor.MyFirstInterceptor&quot;&gt;&lt;/bean&gt;--&gt;&lt;!-- &lt;/mvc:interceptors&gt;--&gt;&lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&gt; &lt;property name=&quot;basename&quot; value=&quot;login&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--配置区域信息解析器--&gt;&lt;!-- &lt;bean id=&quot;localeResolver&quot; class=&quot;com.mashibing.MyLocaleResolver&quot;&gt;&lt;/bean&gt;--&gt;&lt;bean id=&quot;localeResolver&quot; class=&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;&gt;&lt;/bean&gt; &lt;mvc:interceptors&gt; &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; I18nController.java 12345678910111213141516171819202122232425262728293031package com.mashibing.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.MessageSource;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.servlet.i18n.SessionLocaleResolver;import javax.servlet.http.HttpSession;import java.util.Locale;@Controllerpublic class I18nController &#123; @Autowired private MessageSource messageSource; @RequestMapping(&quot;i18n&quot;) public String i18n(@RequestParam(value = &quot;locale&quot;,defaultValue = &quot;zh_CN&quot;) String localeStr,Locale locale, HttpSession session)&#123;// Locale l = null;// if(localeStr!=null &amp;&amp; ! &quot;&quot;.equals(localeStr))&#123;// l = new Locale(localeStr.split(&quot;_&quot;)[0],localeStr.split(&quot;_&quot;)[1]);// &#125;else&#123;// l = locale;// &#125;// session.setAttribute(SessionLocaleResolver.class.getName() + &quot;.LOCALE&quot;,l); return &quot;login&quot;; &#125;&#125; ☀11.SpringMVC异常处理机制 ​ 在SpringMVC中拥有一套非常强大的异常处理机制，SpringMVC通过HandlerExceptionResolver处理程序的异常，包括请求映射，数据绑定以及目标方法的执行时发生的异常。 在容器启动好，进入DispatcherServlet之后，会对HandlerExceptionResolver进行初始化操作： 会默认的从DispatcherServlet.properties中找到对应的异常处理类： 12345678#默认的处理类org.springframework.web.servlet.HandlerExceptionResolver=#处理@ExceptionHandlerorg.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\\#处理@ResponseStatus，给自定义异常使用org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\\#判断是否是SpringMVC自带异常org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver 自己定义异常处理方式： index.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;a href=&quot;exception1&quot;&gt;自己处理异常&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; ExceptionController.java 123456789101112131415161718192021222324252627package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.jws.WebParam;@Controllerpublic class ExceptionController &#123; @RequestMapping(&quot;exception1&quot;) public String exception()&#123; System.out.println(&quot;exception.......&quot;); System.out.println(10/0); return &quot;success&quot;; &#125; @ExceptionHandler(value = &#123;ArithmeticException.class&#125;) public ModelAndView handlerException(Exception exception)&#123; ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;error&quot;); mv.addObject(&quot;ex&quot;,exception); return mv; &#125;&#125; error.jsp 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;我的出错页面：错误信息：$&#123;ex&#125;&lt;/body&gt;&lt;/html&gt; ​ 在一个类中可能会包含多个异常的处理方法，在不同的方法上可以使用不同范围的异常，在查找的时候会优先调用范围小的异常处理； 12345678910111213141516171819202122232425262728293031323334353637package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.jws.WebParam;@Controllerpublic class ExceptionController &#123; @RequestMapping(&quot;exception1&quot;) public String exception()&#123; System.out.println(&quot;exception.......&quot;); System.out.println(10/0); return &quot;success&quot;; &#125; @ExceptionHandler(value = &#123;ArithmeticException.class&#125;) public ModelAndView handlerException1(Exception exception)&#123; System.out.println(&quot;handlerException1........&quot;); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;error&quot;); mv.addObject(&quot;ex&quot;,exception); return mv; &#125; @ExceptionHandler(value = &#123;Exception.class&#125;) public ModelAndView handlerException2(Exception exception)&#123; System.out.println(&quot;handlerException2........&quot;); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;error&quot;); mv.addObject(&quot;ex&quot;,exception); return mv; &#125;&#125; ​ 在不同的类中可能会包含不同的异常处理，因此我们需要定义一个全局的异常控制器,使用@ControllerAdvice注解标注，如果本类跟全局都有相关异常的处理，那么会优先使用本类的。 1234567891011121314151617package com.mashibing.controller;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;@ControllerAdvicepublic class MyGlobalExceptionHandler &#123; @ExceptionHandler(value = &#123;ArithmeticException.class&#125;) public ModelAndView handlerException1(Exception exception)&#123; System.out.println(&quot;handlerException1........&quot;); ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;error&quot;); mv.addObject(&quot;ex&quot;,exception); return mv; &#125;&#125; @ResponseStatus的使用： ​ @ResponseStatus可以标注到方法上，但是标注在方法之后可能导致该方法无法被访问，因此更多的是在自定义类上 123456789101112131415161718192021package com.mashibing.controller;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.servlet.ModelAndView;import javax.jws.WebParam;@Controllerpublic class ExceptionController &#123; @ResponseStatus(reason = &quot;不知道什么原因，反正错误&quot;,value = HttpStatus.NOT_ACCEPTABLE) @RequestMapping(&quot;exception1&quot;) public String exception()&#123; System.out.println(&quot;exception.......&quot;); return &quot;success&quot;; &#125;&#125; ​ @ResponseStatus作用在类上 UserNameException.java 12345678package com.mashibing.controller;import org.springframework.http.HttpStatus;import org.springframework.web.bind.annotation.ResponseStatus;@ResponseStatus(reason = &quot;名字不是admin&quot;,value = HttpStatus.NOT_ACCEPTABLE)public class UserNameException extends RuntimeException &#123;&#125; ExceptionController.java 12345678910111213141516171819202122232425262728package com.mashibing.controller;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.servlet.ModelAndView;import javax.jws.WebParam;@Controllerpublic class ExceptionController &#123; @RequestMapping(&quot;exception1&quot;) public String exception()&#123; System.out.println(&quot;exception.......&quot;); return &quot;success&quot;; &#125; @RequestMapping(&quot;exception2&quot;) public String exception2(String username)&#123; System.out.println(&quot;exception2222.......&quot;); if (&quot;admin&quot;.equals(username))&#123; return &quot;success&quot;; &#125;else&#123; throw new UserNameException(); &#125; &#125;&#125; springmvc自定义的异常： index.jsp 123456789101112131415161718&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/13 Time: 17:00 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;a href=&quot;exception1&quot;&gt;自己处理异常&lt;/a&gt;&lt;a href=&quot;exception2?username=zhangsan&quot;&gt;自定义异常处理&lt;/a&gt;&lt;a href=&quot;exception3&quot;&gt;Springmvc自己异常处理&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; ExceptionController.java 123456789101112131415161718192021222324252627282930313233343536package com.mashibing.controller;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseStatus;import org.springframework.web.servlet.ModelAndView;import javax.jws.WebParam;@Controllerpublic class ExceptionController &#123; @RequestMapping(&quot;exception1&quot;) public String exception()&#123; System.out.println(&quot;exception.......&quot;); return &quot;success&quot;; &#125; @RequestMapping(&quot;exception2&quot;) public String exception2(String username)&#123; System.out.println(&quot;exception2222.......&quot;); if (&quot;admin&quot;.equals(username))&#123; return &quot;success&quot;; &#125;else&#123; throw new UserNameException(); &#125; &#125; @RequestMapping(value = &quot;exception3&quot;,method = RequestMethod.POST) public String exception3(String username)&#123; System.out.println(&quot;exception3.......&quot;); return &quot;success&quot;; &#125;&#125;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://aner1001.gitee.io/tags/SpringMVC/"}]},{"title":"SpringMVC学习笔记2-的请求处理","slug":"技术知识/Java/框架/SpringMVC/SpringMVC学习笔记2-请求处理","date":"2021-02-27T01:44:14.000Z","updated":"2021-02-27T01:44:14.000Z","comments":true,"path":"posts/2021/02/27/4ff31b54efbd/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/27/4ff31b54efbd/","excerpt":"在我们编写的SpringMVC的应用程序中，在具体请求的方法中并不包含request参数，那么我们应该如何获取请求中的参数呢？","text":"在我们编写的SpringMVC的应用程序中，在具体请求的方法中并不包含request参数，那么我们应该如何获取请求中的参数呢？ ☀（1）SpringMVC的请求处理 ☀1.SpringMVC对请求参数的处理 ​ 在之前的servlet中我们可以通过request.getParameter()来获取请求中的参数，但是在我们编写的SpringMVC的应用程序中，在具体请求的方法中并不包含request参数，那么我们应该如何获取请求中的参数呢？ ​ 需要使用以下几个注解： ​ @RequestParam：获取请求的参数 ​ @RequestHeader：获取请求头信息 ​ @CookieValue：获取cookie中的值 @RequestParam的基本使用 123456789101112131415161718192021222324252627282930313233package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class RequestController &#123; /** * 如何获取SpringMVC中请求中的信息 * 默认情况下，可以直接在方法的参数中填写跟请求一样的名称，此时会默认接受参数 * 如果有值，直接赋值，如果没有，那么直接给空值 * * @RequestParam:获取请求中的参数值,使用此注解之后，参数的名称不需要跟请求的名称一致，但是必须要写 * public String request(@RequestParam(&quot;user&quot;) String username)&#123; * * 此注解还包含三个参数： * value:表示要获取的参数值 * required：表示此参数是否必须，默认是true，如果不写参数那么会报错，如果值为false，那么不写参数不会有任何错误 * defaultValue:如果在使用的时候没有传递参数，那么定义默认值即可 * * * @param username * @return */ @RequestMapping(&quot;/request&quot;) public String request(@RequestParam(value = &quot;user&quot;,required = false,defaultValue = &quot;hehe&quot;) String username)&#123; System.out.println(username); return &quot;success&quot;; &#125;&#125; @RequestHeader的基本使用： 12345678910111213141516171819202122232425262728293031package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import sun.management.resources.agent;@Controllerpublic class RequestController &#123; /** * 如果需要获取请求头信息该如何处理呢？ * 可以使用@RequestHeader注解， * public String header(@RequestHeader(&quot;User-Agent&quot;) String agent)&#123; * 相当于 request.getHeader(&quot;User-Agent&quot;) * * 如果要获取请求头中没有的信息，那么此时会报错，同样，此注解中也包含三个参数,跟@RequestParam一样 * value * required * defalutValue * @param agent * @return */ @RequestMapping(&quot;/header&quot;) public String header(@RequestHeader(&quot;User-Agent&quot;) String agent)&#123; System.out.println(agent); return &quot;success&quot;; &#125;&#125; @CookieValue的基本使用 12345678910111213141516171819202122232425262728293031323334package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import sun.management.resources.agent;@Controllerpublic class RequestController &#123; /** * 如果需要获取cookie信息该如何处理呢？ * 可以使用@CookieValue注解， * public String cookie(@CookieValue(&quot;JSESSIONID&quot;) String id)&#123; * 相当于 * Cookie[] cookies = request.getCookies(); * for(Cookie cookie : cookies)&#123; * cookie.getValue(); * &#125; * 如果要获取cookie中没有的信息，那么此时会报错，同样，此注解中也包含三个参数,跟@RequestParam一样 * value * required * defalutValue * @param id * @return */ @RequestMapping(&quot;/cookie&quot;) public String cookie(@CookieValue(&quot;JSESSIONID&quot;) String id)&#123; System.out.println(id); return &quot;success&quot;; &#125;&#125; ​ 如果请求中传递的是某一个对象的各个属性值，此时如何在控制器的方法中获取对象的各个属性值呢？ ​ 在SpringMVC的控制中，能直接完成对象的属性赋值操作，不需要人为干预。 User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.mashibing.bean;import java.util.Date;public class User &#123; private Integer id; private String name; private Integer age; private Date date; private Address address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, date=&quot; + date + &quot;, address=&quot; + address + &#x27;&#125;&#x27;; &#125;&#125; Address.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.mashibing.bean;public class Address &#123; private String province; private String city; private String town; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getTown() &#123; return town; &#125; public void setTown(String town) &#123; this.town = town; &#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;province=&#x27;&quot; + province + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &quot;, town=&#x27;&quot; + town + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; login.jsp 1234567891011121314151617181920212223242526&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/7 Time: 0:11 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;addUser&quot; method=&quot;post&quot;&gt; 编号:&lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br&gt; &lt;%-- 2020/01/02--%&gt; 日期:&lt;input type=&quot;text&quot; name=&quot;date&quot;/&gt;&lt;br&gt; 省份:&lt;input type=&quot;text&quot; name=&quot;address.province&quot;/&gt;&lt;br&gt; 城市:&lt;input type=&quot;text&quot; name=&quot;address.city&quot;/&gt;&lt;br&gt; 区域:&lt;input type=&quot;text&quot; name=&quot;address.town&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; UserController.java 123456789101112131415package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125;&#125; ☀2.乱码问题的解决 ​ 我们在表单或者发送请求的时候，经常会遇到中文乱码的问题，那么如何解决乱码问题呢？ ​ GET请求：在server.xml文件中，添加URIEncoding=“UTF-8” ​ POST请求：编写过滤器进行实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件： 此配置文件的属性可以不添加，但是需要在WEB-INF的目录下创建 前端控制器名称-servlet.xml文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--匹配servlet的请求， /：标识匹配所有请求，但是不会jsp页面 /*：拦截所有请求，拦截jsp页面 但是需要注意的是，当配置成index.html的时候，会发现请求不到 原因在于，tomcat下也有一个web.xml文件，所有的项目下web.xml文件都需要继承此web.xml 在服务器的web.xml文件中有一个DefaultServlet用来处理静态资源，但是url-pattern是/ 而我们在自己的配置文件中如果添加了url-pattern=/会覆盖父类中的url-pattern，此时在请求的时候 DispatcherServlet会去controller中做匹配，找不到则直接报404 而在服务器的web.xml文件中包含了一个JspServlet的处理，所以不过拦截jsp请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--解决post请求乱码--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--解决响应乱码--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 注意：如果配置了多个过滤器，那么字符编码过滤器一定要在最前面，否则失效。 ☀3.SpringMVC对原生API的支持 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletInputStream;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.BufferedReader;import java.io.PrintWriter;@Controllerpublic class UserController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125; /** * SpringMVC也可以在参数上使用原生的Servlet API * * HttpSession * HttpServletRequest * HttpServletResponse * * java.security.Principal 安全协议相关 * Locale：国际化相关的区域信息对象 * InputStream: * ServletInputStream inputStream = request.getInputStream(); * OutputStream: * ServletOutputStream outputStream = response.getOutputStream(); * Reader: * BufferedReader reader = request.getReader(); * Writer: * PrintWriter writer = response.getWriter(); * @param session * @param request * @param response * @return */ @RequestMapping(&quot;api&quot;) public String api(HttpSession session, HttpServletRequest request, HttpServletResponse response)&#123; request.setAttribute(&quot;requestParam&quot;,&quot;request&quot;); session.setAttribute(&quot;sessionParam&quot;,&quot;session&quot;); return &quot;success&quot;; &#125;&#125; ☀4.使用Model，Map，ModelMap传输数据到页面 ​ 在刚开始的helloworld项目中，我们传递了参数回到我们页面，但是后续的操作都只是接受用户的请求，那么在SpringMVC中除了可以使用原生servlet的对象传递数据之外，还有什么其他的方式呢？ ​ 可以在方法的参数上传入Model，ModelMap,Map类型，此时都能够将数据传送回页面 OutputController.java 123456789101112131415161718192021222324252627282930package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;@Controllerpublic class OutputController &#123; @RequestMapping(&quot;output1&quot;) public String output1(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,Springmvc&quot;); return &quot;output&quot;; &#125; @RequestMapping(&quot;output2&quot;) public String output2(ModelMap model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,Springmvc&quot;); return &quot;output&quot;; &#125; @RequestMapping(&quot;output3&quot;) public String output1(Map map)&#123; map.put(&quot;msg&quot;,&quot;hello,Springmvc&quot;); return &quot;output&quot;; &#125;&#125; 当使用此方式进行设置之后，会发现所有的参数值都设置到了request作用域中，那么这三个对象是什么关系呢？ ☀5.使用ModelAndView对象传输数据到页面 1234567891011121314151617package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class OutputController &#123; @RequestMapping(&quot;mv&quot;) public ModelAndView mv()&#123; ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;output&quot;); mv.addObject(&quot;msg&quot;,&quot;hello.modelAndView&quot;); return mv; &#125;&#125; ​ 发现当使用modelAndView对象的时候，返回值的类型也是此对象，可以将要跳转的页面设置成view的名称，来完成跳转的功能，同时数据也是放到request作用中。 ☀6.使用@SessionAttributes,使session传输数据到页面 @SessionAttribute：此注解可以表示，当向request作用域设置数据的时候同时也要向session中保存一份,此注解有两个参数，一个value（表示将哪些值设置到session中），另外一个type（表示按照类型来设置数据，一般不用，因为有可能会将很多数据都设置到session中，导致session异常）。 1234567891011@Controller@SessionAttributes(value = &quot;msg&quot;)public class OutputController &#123; @RequestMapping(&quot;output1&quot;) public String output1(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,Springmvc&quot;); System.out.println(model.getClass()); return &quot;output&quot;; &#125;&#125; ☀7.使用@ModelAttribute来获取请求中的数据 ​ @ModelAttribute注解用于将方法的参数或者方法的返回值绑定到指定的模型属性上，并返回给web视图。首先来介绍一个业务场景，来帮助大家做理解，在实际工作中，有些时候我们在修改数据的时候可能只需要修改其中几个字段，而不是全部的属性字段都获取，那么当提交属性的时候，从form表单中获取的数据就有可能只包含了部分属性，此时再向数据库更新的时候，肯定会丢失属性，因为对象的封装是springmvc自动帮我们new的，所以此时需要先将从数据库获取的对象保存下来，当提交的时候不是new新的对象，而是在原来的对象上进行属性覆盖，此时就需要使用@ModelAttribute注解。 User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.mashibing.bean;public class User &#123; private Integer id; private String name; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; UserController.java 123456789101112131415161718192021222324252627282930313233343536373839package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; Object o1 = null; Object o2 = null; Object o3 = null; @RequestMapping(&quot;update&quot;) public String update(@ModelAttribute(&quot;user&quot;) User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;; &#125; @ModelAttribute public void MyModelAttribute(Model model)&#123; o1 = model; User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(12); user.setPassword(&quot;123&quot;); model.addAttribute(&quot;user&quot;,user); System.out.println(&quot;modelAttribute:&quot;+user); o3 = user; &#125;&#125; index.jsp 1234567891011121314151617181920212223&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/11 Time: 13:45 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;update&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;id&quot;&gt; 姓名：张三&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 其实在使用的时候可以简化写法，也就是说，在方法的参数上不加@ModelAttribute也不会有问题 12345678910@RequestMapping(&quot;update&quot;)public String update(User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;;&#125; 如果添加的@ModelAttribute（“”）属性的值不对，那么也是获取不到值的。同时可以添加@SessionAttributes属性，但是注意，如果没有设置值的话，会报错 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;@Controller@SessionAttributes(&quot;u&quot;)public class UserController &#123; Object o1 = null; Object o2 = null; Object o3 = null; @RequestMapping(&quot;update&quot;) public String update(@ModelAttribute(&quot;u&quot;) User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;; &#125; @ModelAttribute public void MyModelAttribute(Model model)&#123; o1 = model; User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(12); user.setPassword(&quot;123&quot;); model.addAttribute(&quot;user&quot;,user); System.out.println(&quot;modelAttribute:&quot;+user); o3 = user; &#125;&#125; 注意：ModelAttribute除了可以使用设置值到model中之外，还可以利用返回值。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;@Controllerpublic class UserController &#123; Object o1 = null; Object o2 = null; Object o3 = null; @RequestMapping(&quot;update&quot;) public String update(@ModelAttribute(&quot;u&quot;) User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;; &#125; @ModelAttribute(&quot;u&quot;) public User MyModelAttribute(Model model)&#123; o1 = model; User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(12); user.setPassword(&quot;123&quot;);// model.addAttribute(&quot;user&quot;,user); System.out.println(&quot;modelAttribute:&quot;+user); o3 = user; return user; &#125;&#125; 总结：通过刚刚的给参数赋值，大家应该能够发现，当给方法中的参数设置值的时候，如果添加了@ModelAttribute注解，那么在查找值的时候，是遵循以下方式： 1、方法的参数使用参数的类型首字母小写，或者使用@ModelAttribute(“”)的值 2、先看之前是否在model中设置过该属性值，如果设置过就直接获取 3、看@SessionAttributes注解标注类中的方法是否给session中赋值，如果有的话，也是直接获取，没有报异常 ☀8.使用forward实现页面转发 ​ 在发送请求的时候，可以通过forward:来实现转发的功能： 12345678910111213141516171819202122232425262728package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ForWardController &#123; /** * 当使用转发的时候可以添加前缀forward:index.jsp,此时是不会经过视图解析器的，所以要添加完整的名称 * * forward:也可以由一个请求跳转到另外一个请求 * * @return */ @RequestMapping(&quot;/forward01&quot;) public String forward()&#123; System.out.println(&quot;1&quot;); return &quot;forward:/index.jsp&quot;; &#125; @RequestMapping(&quot;/forward02&quot;) public String forward2()&#123; System.out.println(&quot;2&quot;); return &quot;forward:/forward01&quot;; &#125;&#125; ☀9.使用redirect来实现重定向 12345678910111213141516171819202122232425262728package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RedirectController &#123; /** * redirect :重定向的路径 * 相当于 response.sendRedirect(&quot;index.jsp&quot;) * 跟视图解析器无关 * @return */ @RequestMapping(&quot;redirect&quot;) public String redirect()&#123; System.out.println(&quot;redirect&quot;); return &quot;redirect:/index.jsp&quot;; &#125; @RequestMapping(&quot;/redirect2&quot;) public String redirect2()&#123; System.out.println(&quot;redirect2&quot;); return &quot;redirect:/redirect&quot;; &#125;&#125; 在javaweb的时候大家应该都接触过重定向和转发的区别，下面再详细说一下： 转发： ​ 由服务器的页面进行跳转，不需要客户端重新发送请求： ​ 特点如下： ​ 1、地址栏的请求不会发生变化，显示的还是第一次请求的地址 ​ 2、请求的次数，有且仅有一次请求 ​ 3、请求域中的数据不会丢失 ​ 4、根目录：localhost:8080/项目地址/,包含了项目的访问地址 重定向： ​ 在浏览器端进行页面的跳转，需要发送两次请求（第一次是人为的，第二次是自动的） ​ 特点如下： ​ 1、地址栏的地址发生变化，显示最新发送请求的地址 ​ 2、请求次数：2次 ​ 3、请求域中的数据会丢失，因为是不同的请求 ​ 4、根目录：localhost:8080/ 不包含项目的名称 ​ 对比： 区别 转发forward() 重定向sendRedirect() 根目录 包含项目访问地址 没有项目访问地址 地址栏 不会发生变化 会发生变化 哪里跳转 服务器端进行的跳转 浏览器端进行的跳转 请求域中数据 不会丢失 会丢失 ☀10.静态资源的访问 ​ 当页面中包含静态资源的时候我们能够正确的获取到吗？ hello.jsp 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% pageContext.setAttribute(&quot;ctx&quot;,request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello springmvc&lt;img src=&quot;$&#123;ctx&#125;/images/timg.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt; ​ 此时大家发现我们请求的图片根本访问不到，根据查看发现路径是没有问题的，那么为什么会找不到静态资源呢？ ​ 大家发现此时是找不到对应的mapping映射的，此时是因为DispatcherServlet会拦截所有的请求，而此时我们没有对应图片的请求处理方法，所以此时报错了，想要解决的话非常简单，只需要添加一个配置即可 12345&lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理静态资源可以访问，但是动态请求无法访问--&gt;&lt;mvc:default-servlet-handler/&gt; ​ 但是加上此配置之后，大家又发现此时除了静态资源无法访问之外，我们正常的请求也无法获取了，因此还需要再添加另外的配置： 12&lt;!--保证静态资源和动态请求都能够访问--&gt;&lt;mvc:annotation-driven/&gt; ☀（2）自定义视图解析器 ​ 我们在之前的操作中已经用了SpringMVC中提供的视图解析器，那么如果我们需要实现自己的视图解析器该如何操作呢？ MyViewController.java 123456789101112131415package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class MyViewController &#123; @RequestMapping(&quot;/myview&quot;) public String myView(Model model)&#123; model.addAttribute(&quot;msb&quot;,&quot;马士兵&quot;); return &quot;msb:/index&quot;; &#125;&#125; MyViewResolver.java 12345678910111213141516171819202122232425262728293031package com.mashibing.view;import org.springframework.core.Ordered;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;public class MyViewResolver implements ViewResolver, Ordered &#123; private int order = 0; public View resolveViewName(String viewName, Locale locale) throws Exception &#123; //如果前缀是msb:开头的就进行解析 if (viewName.startsWith(&quot;msb:&quot;))&#123; System.out.println(&quot;msb:&quot;); return new MyView(); &#125;else&#123; //如果不是，则直接返回null return null; &#125; &#125; public int getOrder() &#123; return this.order; &#125; public void setOrder(Integer order) &#123; this.order = order; &#125;&#125; MyView.java 12345678910111213141516171819202122232425package com.mashibing.view;import org.springframework.core.Ordered;import org.springframework.web.servlet.View;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;public class MyView implements View &#123; public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println(&quot;保存的对象是：&quot;+model); response.setContentType(&quot;text/html&quot;); response.getWriter().write(&quot;欢迎加入马士兵教育&quot;); &#125; /** * 返回数据内容的类型 * @return */ public String getContentType() &#123; return &quot;text/html&quot;; &#125;&#125; springmvc.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ☀（3）自定义类型转换器 ​ 在日常的企业开发需求中，我们输入文本框的内容全部都是字符串类型，但是在后端处理的时候我们可以用其他基本类型来接受数据，也可以使用实体类来接受参数，这个是怎么完成的呢？就是通过SpringMVC提供的类型转换器，SpringMVC内部提供了非常丰富的类型转换器的支持，但是有些情况下有可能难以满足我们的需求，因此需要我们自己实现，如下： User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.mashibing.bean;public class User &#123; private Integer id; private String name; private Integer age; private String gender; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; MyConverter.java 123456789101112131415161718192021package com.mashibing.converter;import com.mashibing.bean.User;import org.springframework.core.convert.converter.Converter;import org.springframework.stereotype.Component;@Componentpublic class MyConverter implements Converter&lt;String, User&gt; &#123; public User convert(String source) &#123; User user = null; String[] split = source.split(&quot;-&quot;); if (source!=null &amp;&amp; split.length==4)&#123; user = new User(); user.setId(Integer.parseInt(split[0])); user.setName(split[1]); user.setAge(Integer.parseInt(split[2])); user.setGender(split[3]); &#125; return user; &#125;&#125; UserController.java 1234567891011121314151617package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; @RequestMapping(&quot;/user&quot;) public String add(User user, Model model)&#123; System.out.println(user); model.addAttribute(&quot;user&quot;,&quot;user&quot;); return &quot;success&quot;; &#125;&#125; success.jsp 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/12 Time: 21:36 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;requestScope.user&#125;&lt;/body&gt;&lt;/html&gt; springmvc.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myConverter&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ☀（4）自定义日期格式化转换器 ​ 有时候我们经常需要在页面添加日期等相关信息，此时需要制定日期格式化转换器，此操作非常简单：只需要在单独的属性上添加@DateTimeFormat注解即可，制定对应的格式 User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.mashibing.bean;import org.springframework.format.annotation.DateTimeFormat;import java.util.Date;public class User &#123; private Integer id; private String name; private Integer age; private String gender; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birth; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &#x27;&#125;&#x27;; &#125;&#125; index.jsp 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;form action=&quot;dateConvertion&quot; method=&quot;post&quot;&gt; 编号：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;gender&quot;&gt;&lt;br&gt; 日期：&lt;input type=&quot;text&quot; name=&quot;birth&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; DateConvertionController.java 123456789101112131415package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DateConvertionController &#123; @RequestMapping(&quot;dateConvertion&quot;) public String dateConvertion(User user)&#123; System.out.println(user); return &quot;hello&quot;; &#125;&#125; springmvc.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理 静态资源可以访问，但是动态请求无法访问 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--保证静态资源和动态请求都能够访问--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; ​ 此时运行发现是没有问题的，但是需要注意的是，如果同时配置了自定义类型转换器之后，那么日期格式转化是有问题的。 springmvc.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理 静态资源可以访问，但是动态请求无法访问 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--保证静态资源和动态请求都能够访问--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myConverter&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 原因就在于ConversionServiceFactoryBean对象中有且仅有一个属性converters，此时可以使用另外一个类来做替换FormattingConversionServiceFactoryBean springmvc.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理 静态资源可以访问，但是动态请求无法访问 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--保证静态资源和动态请求都能够访问--&gt;&lt;!-- &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myConverter&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ☀（5）数据校验 ​ 一般情况下我们会在前端页面实现数据的校验，但是大家需要注意的是前端校验会存在数据的不安全问题，因此一般情况下我们都会使用前端校验+后端校验的方式，这样的话既能够满足用户的体验度，同时也能保证数据的安全，下面来说一下在springmvc中如何进行后端数据校验。 ​ JSR303是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 。JSR 303 (Java Specification Requests意思是Java 规范提案)通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。 JSR303: Hibernate Validator 扩展注解: ​ spring中拥有自己的数据校验框架，同时支持JSR303标准的校验框架，可以在通过添加注解的方式进行数据校验。在spring中本身没有提供JSR303的实现，需要导入依赖的包。 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;springmvc_viewResolver&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; index.jsp 12345678910111213141516171819202122232425&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/12 Time: 15:23 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;form action=&quot;dataValidate&quot; method=&quot;post&quot;&gt; 编号：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;gender&quot;&gt;&lt;br&gt; 日期：&lt;input type=&quot;text&quot; name=&quot;birth&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; DataValidateController.java 123456789101112131415161718192021222324package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;@Controllerpublic class DataValidateController &#123; @RequestMapping(&quot;/dataValidate&quot;) public String validate(@Valid User user, BindingResult bindingResult) &#123; System.out.println(user); if (bindingResult.hasErrors()) &#123; System.out.println(&quot;验证失败&quot;); return &quot;redirect:/index.jsp&quot;; &#125; else &#123; System.out.println(&quot;验证成功&quot;); return &quot;hello&quot;; &#125; &#125;&#125; User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.mashibing.bean;import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.Length;import org.springframework.format.annotation.DateTimeFormat;import javax.validation.constraints.NotNull;import javax.validation.constraints.Past;import java.util.Date;public class User &#123; private Integer id; @NotNull @Length(min = 5,max = 10) private String name; private Integer age; private String gender; @Past @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birth; @Email private String email; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 此时大家发现在报错的地方无法出现错误提示，可以换另外一种方式： index.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;a href=&quot;add&quot;&gt;添加用户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; add.jsp 12345678910111213141516171819&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form:form action=&quot;dataValidate&quot; modelAttribute=&quot;user&quot; method=&quot;post&quot;&gt; id:&lt;form:input path=&quot;id&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;id&quot;&gt;&lt;/form:errors&gt; &lt;br/&gt; name:&lt;form:input path=&quot;name&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;name&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; age:&lt;form:input path=&quot;age&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;age&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; gender:&lt;form:input path=&quot;gender&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;gender&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; birth:&lt;form:input path=&quot;birth&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;birth&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; email:&lt;form:input path=&quot;email&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;email&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; DataValidateController.java 12345678910111213141516171819202122232425262728293031package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;@Controllerpublic class DataValidateController &#123; @RequestMapping(&quot;/dataValidate&quot;) public String validate(@Valid User user, BindingResult bindingResult, Model model) &#123; System.out.println(user); if (bindingResult.hasErrors()) &#123; System.out.println(&quot;验证失败&quot;); return &quot;add&quot;; &#125; else &#123; System.out.println(&quot;验证成功&quot;); return &quot;hello&quot;; &#125; &#125; @RequestMapping(&quot;add&quot;) public String add(Model model)&#123; model.addAttribute(&quot;user&quot;,new User(1,&quot;zhangsan&quot;,12,&quot;女&quot;,null,&quot;1234@qq.com&quot;)); return &quot;add&quot;; &#125;&#125; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 原生的表单如何获取错误信息： DataValidateController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;import java.util.HashMap;import java.util.List;import java.util.Map;@Controllerpublic class DataValidateController &#123; @RequestMapping(&quot;/dataValidate&quot;) public String validate(@Valid User user, BindingResult bindingResult, Model model) &#123; System.out.println(user); Map&lt;String,Object&gt; errorsMap = new HashMap&lt;String, Object&gt;(); if (bindingResult.hasErrors()) &#123; System.out.println(&quot;验证失败&quot;); List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors(); for (FieldError fieldError : fieldErrors) &#123; System.out.println(fieldError.getDefaultMessage()); System.out.println(fieldError.getField()); errorsMap.put(fieldError.getField(),fieldError.getDefaultMessage()); &#125; model.addAttribute(&quot;errorInfo&quot;,errorsMap); return &quot;add&quot;; &#125; else &#123; System.out.println(&quot;验证成功&quot;); return &quot;hello&quot;; &#125; &#125; @RequestMapping(&quot;add&quot;) public String add(Model model)&#123; model.addAttribute(&quot;user&quot;,new User(1,&quot;zhangsan&quot;,12,&quot;女&quot;,null,&quot;1234@qq.com&quot;)); return &quot;add&quot;; &#125;&#125; add.jsp 123456789101112131415161718&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form:form action=&quot;dataValidate&quot; modelAttribute=&quot;user&quot; method=&quot;post&quot;&gt; 编号:&lt;form:input path=&quot;id&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;id&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.id&#125; &lt;br/&gt; 姓名:&lt;form:input path=&quot;name&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;name&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.name&#125;&lt;br/&gt; 年龄:&lt;form:input path=&quot;age&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;age&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.age&#125;&lt;br/&gt; 性别:&lt;form:input path=&quot;gender&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;gender&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.gender&#125;&lt;br/&gt; 生日:&lt;form:input path=&quot;birth&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;birth&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfobirth&#125;&lt;br/&gt; 邮箱:&lt;form:input path=&quot;email&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;email&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.email&#125;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; ​","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://aner1001.gitee.io/tags/SpringMVC/"}]},{"title":"SpringMVC学习笔记-请求处理","slug":"技术知识/Java/框架/SpringMVC/SpringMVC学习笔记-请求处理","date":"2021-02-26T08:47:40.000Z","updated":"2021-02-26T08:47:40.000Z","comments":true,"path":"posts/2021/02/26/dcc24837b9b7/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/26/dcc24837b9b7/","excerpt":"","text":"☀（1）SpringMVC的请求处理 ☀1.SpringMVC对请求参数的处理 ​ 在之前的servlet中我们可以通过request.getParameter()来获取请求中的参数，但是在我们编写的SpringMVC的应用程序中，在具体请求的方法中并不包含request参数，那么我们应该如何获取请求中的参数呢？ ​ 需要使用以下几个注解： ​ @RequestParam：获取请求的参数 ​ @RequestHeader：获取请求头信息 ​ @CookieValue：获取cookie中的值 @RequestParam的基本使用 123456789101112131415161718192021222324252627282930313233package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class RequestController &#123; /** * 如何获取SpringMVC中请求中的信息 * 默认情况下，可以直接在方法的参数中填写跟请求一样的名称，此时会默认接受参数 * 如果有值，直接赋值，如果没有，那么直接给空值 * * @RequestParam:获取请求中的参数值,使用此注解之后，参数的名称不需要跟请求的名称一致，但是必须要写 * public String request(@RequestParam(&quot;user&quot;) String username)&#123; * * 此注解还包含三个参数： * value:表示要获取的参数值 * required：表示此参数是否必须，默认是true，如果不写参数那么会报错，如果值为false，那么不写参数不会有任何错误 * defaultValue:如果在使用的时候没有传递参数，那么定义默认值即可 * * * @param username * @return */ @RequestMapping(&quot;/request&quot;) public String request(@RequestParam(value = &quot;user&quot;,required = false,defaultValue = &quot;hehe&quot;) String username)&#123; System.out.println(username); return &quot;success&quot;; &#125;&#125; @RequestHeader的基本使用： 12345678910111213141516171819202122232425262728293031package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import sun.management.resources.agent;@Controllerpublic class RequestController &#123; /** * 如果需要获取请求头信息该如何处理呢？ * 可以使用@RequestHeader注解， * public String header(@RequestHeader(&quot;User-Agent&quot;) String agent)&#123; * 相当于 request.getHeader(&quot;User-Agent&quot;) * * 如果要获取请求头中没有的信息，那么此时会报错，同样，此注解中也包含三个参数,跟@RequestParam一样 * value * required * defalutValue * @param agent * @return */ @RequestMapping(&quot;/header&quot;) public String header(@RequestHeader(&quot;User-Agent&quot;) String agent)&#123; System.out.println(agent); return &quot;success&quot;; &#125;&#125; @CookieValue的基本使用 12345678910111213141516171819202122232425262728293031323334package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.CookieValue;import org.springframework.web.bind.annotation.RequestHeader;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import sun.management.resources.agent;@Controllerpublic class RequestController &#123; /** * 如果需要获取cookie信息该如何处理呢？ * 可以使用@CookieValue注解， * public String cookie(@CookieValue(&quot;JSESSIONID&quot;) String id)&#123; * 相当于 * Cookie[] cookies = request.getCookies(); * for(Cookie cookie : cookies)&#123; * cookie.getValue(); * &#125; * 如果要获取cookie中没有的信息，那么此时会报错，同样，此注解中也包含三个参数,跟@RequestParam一样 * value * required * defalutValue * @param id * @return */ @RequestMapping(&quot;/cookie&quot;) public String cookie(@CookieValue(&quot;JSESSIONID&quot;) String id)&#123; System.out.println(id); return &quot;success&quot;; &#125;&#125; ​ 如果请求中传递的是某一个对象的各个属性值，此时如何在控制器的方法中获取对象的各个属性值呢？ ​ 在SpringMVC的控制中，能直接完成对象的属性赋值操作，不需要人为干预。 User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.mashibing.bean;import java.util.Date;public class User &#123; private Integer id; private String name; private Integer age; private Date date; private Address address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public Date getDate() &#123; return date; &#125; public void setDate(Date date) &#123; this.date = date; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, date=&quot; + date + &quot;, address=&quot; + address + &#x27;&#125;&#x27;; &#125;&#125; Address.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.mashibing.bean;public class Address &#123; private String province; private String city; private String town; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getTown() &#123; return town; &#125; public void setTown(String town) &#123; this.town = town; &#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;province=&#x27;&quot; + province + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &quot;, town=&#x27;&quot; + town + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; login.jsp 12345678910111213141516171819202122232425&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/7 Time: 0:11 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;addUser&quot; method=&quot;post&quot;&gt; 编号:&lt;input type=&quot;text&quot; name=&quot;id&quot;/&gt;&lt;br&gt; 姓名:&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;&lt;br&gt; 年龄:&lt;input type=&quot;text&quot; name=&quot;age&quot;/&gt;&lt;br&gt; 日期:&lt;input type=&quot;text&quot; name=&quot;date&quot;/&gt;&lt;br&gt; 省份:&lt;input type=&quot;text&quot; name=&quot;address.province&quot;/&gt;&lt;br&gt; 城市:&lt;input type=&quot;text&quot; name=&quot;address.city&quot;/&gt;&lt;br&gt; 区域:&lt;input type=&quot;text&quot; name=&quot;address.town&quot;/&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;/&gt;&lt;br&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; UserController.java 123456789101112131415package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125;&#125; ☀2.乱码问题的解决 ​ 我们在表单或者发送请求的时候，经常会遇到中文乱码的问题，那么如何解决乱码问题呢？ ​ GET请求：在server.xml文件中，添加URIEncoding=“UTF-8” ​ POST请求：编写过滤器进行实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件： 此配置文件的属性可以不添加，但是需要在WEB-INF的目录下创建 前端控制器名称-servlet.xml文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--匹配servlet的请求， /：标识匹配所有请求，但是不会jsp页面 /*：拦截所有请求，拦截jsp页面 但是需要注意的是，当配置成index.html的时候，会发现请求不到 原因在于，tomcat下也有一个web.xml文件，所有的项目下web.xml文件都需要继承此web.xml 在服务器的web.xml文件中有一个DefaultServlet用来处理静态资源，但是url-pattern是/ 而我们在自己的配置文件中如果添加了url-pattern=/会覆盖父类中的url-pattern，此时在请求的时候 DispatcherServlet会去controller中做匹配，找不到则直接报404 而在服务器的web.xml文件中包含了一个JspServlet的处理，所以不过拦截jsp请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;!--解决post请求乱码--&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--解决响应乱码--&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 注意：如果配置了多个过滤器，那么字符编码过滤器一定要在最前面，否则失效。 ☀3.SpringMVC对原生API的支持 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.servlet.ServletInputStream;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.BufferedReader;import java.io.PrintWriter;@Controllerpublic class UserController &#123; @RequestMapping(&quot;/addUser&quot;) public String addUser(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125; /** * SpringMVC也可以在参数上使用原生的Servlet API * * HttpSession * HttpServletRequest * HttpServletResponse * * java.security.Principal 安全协议相关 * Locale：国际化相关的区域信息对象 * InputStream: * ServletInputStream inputStream = request.getInputStream(); * OutputStream: * ServletOutputStream outputStream = response.getOutputStream(); * Reader: * BufferedReader reader = request.getReader(); * Writer: * PrintWriter writer = response.getWriter(); * @param session * @param request * @param response * @return */ @RequestMapping(&quot;api&quot;) public String api(HttpSession session, HttpServletRequest request, HttpServletResponse response)&#123; request.setAttribute(&quot;requestParam&quot;,&quot;request&quot;); session.setAttribute(&quot;sessionParam&quot;,&quot;session&quot;); return &quot;success&quot;; &#125;&#125; ☀4、使用Model，Map，ModelMap传输数据到页面 ​ 在刚开始的helloworld项目中，我们传递了参数回到我们页面，但是后续的操作都只是接受用户的请求，那么在SpringMVC中除了可以使用原生servlet的对象传递数据之外，还有什么其他的方式呢？ ​ 可以在方法的参数上传入Model，ModelMap,Map类型，此时都能够将数据传送回页面 OutputController.java 123456789101112131415161718192021222324252627282930package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.RequestMapping;import java.util.Map;@Controllerpublic class OutputController &#123; @RequestMapping(&quot;output1&quot;) public String output1(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,Springmvc&quot;); return &quot;output&quot;; &#125; @RequestMapping(&quot;output2&quot;) public String output2(ModelMap model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,Springmvc&quot;); return &quot;output&quot;; &#125; @RequestMapping(&quot;output3&quot;) public String output1(Map map)&#123; map.put(&quot;msg&quot;,&quot;hello,Springmvc&quot;); return &quot;output&quot;; &#125;&#125; 当使用此方式进行设置之后，会发现所有的参数值都设置到了request作用域中，那么这三个对象是什么关系呢？ ☀5、使用ModelAndView对象传输数据到页面 1234567891011121314151617package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;@Controllerpublic class OutputController &#123; @RequestMapping(&quot;mv&quot;) public ModelAndView mv()&#123; ModelAndView mv = new ModelAndView(); mv.setViewName(&quot;output&quot;); mv.addObject(&quot;msg&quot;,&quot;hello.modelAndView&quot;); return mv; &#125;&#125; ​ 发现当使用modelAndView对象的时候，返回值的类型也是此对象，可以将要跳转的页面设置成view的名称，来完成跳转的功能，同时数据也是放到request作用中。 ☀6、使用session传输数据到页面 @SessionAttribute：此注解可以表示，当向request作用域设置数据的时候同时也要向session中保存一份,此注解有两个参数，一个value（表示将哪些值设置到session中），另外一个type（表示按照类型来设置数据，一般不用，因为有可能会将很多数据都设置到session中，导致session异常）。 1234567891011@Controller@SessionAttributes(value = &quot;msg&quot;)public class OutputController &#123; @RequestMapping(&quot;output1&quot;) public String output1(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,Springmvc&quot;); System.out.println(model.getClass()); return &quot;output&quot;; &#125;&#125; ☀7、使用@ModelAttribute来获取请求中的数据 ​ @ModelAttribute注解用于将方法的参数或者方法的返回值绑定到指定的模型属性上，并返回给web视图。首先来介绍一个业务场景，来帮助大家做理解，在实际工作中，有些时候我们在修改数据的时候可能只需要修改其中几个字段，而不是全部的属性字段都获取，那么当提交属性的时候，从form表单中获取的数据就有可能只包含了部分属性，此时再向数据库更新的时候，肯定会丢失属性，因为对象的封装是springmvc自动帮我们new的，所以此时需要先将从数据库获取的对象保存下来，当提交的时候不是new新的对象，而是在原来的对象上进行属性覆盖，此时就需要使用@ModelAttribute注解。 User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.mashibing.bean;public class User &#123; private Integer id; private String name; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; UserController.java 123456789101112131415161718192021222324252627282930313233343536373839package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; Object o1 = null; Object o2 = null; Object o3 = null; @RequestMapping(&quot;update&quot;) public String update(@ModelAttribute(&quot;user&quot;) User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;; &#125; @ModelAttribute public void MyModelAttribute(Model model)&#123; o1 = model; User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(12); user.setPassword(&quot;123&quot;); model.addAttribute(&quot;user&quot;,user); System.out.println(&quot;modelAttribute:&quot;+user); o3 = user; &#125;&#125; index.jsp 1234567891011121314151617181920212223&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/11 Time: 13:45 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;update&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; value=&quot;1&quot; name=&quot;id&quot;&gt; 姓名：张三&lt;br&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 其实在使用的时候可以简化写法，也就是说，在方法的参数上不加@ModelAttribute也不会有问题 12345678910@RequestMapping(&quot;update&quot;)public String update(User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;;&#125; 如果添加的@ModelAttribute（“”）属性的值不对，那么也是获取不到值的。同时可以添加@SessionAttributes属性，但是注意，如果没有设置值的话，会报错 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;@Controller@SessionAttributes(&quot;u&quot;)public class UserController &#123; Object o1 = null; Object o2 = null; Object o3 = null; @RequestMapping(&quot;update&quot;) public String update(@ModelAttribute(&quot;u&quot;) User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;; &#125; @ModelAttribute public void MyModelAttribute(Model model)&#123; o1 = model; User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(12); user.setPassword(&quot;123&quot;); model.addAttribute(&quot;user&quot;,user); System.out.println(&quot;modelAttribute:&quot;+user); o3 = user; &#125;&#125; 注意：ModelAttribute除了可以使用设置值到model中之外，还可以利用返回值。 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ModelAttribute;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.SessionAttributes;@Controllerpublic class UserController &#123; Object o1 = null; Object o2 = null; Object o3 = null; @RequestMapping(&quot;update&quot;) public String update(@ModelAttribute(&quot;u&quot;) User user,Model model)&#123; System.out.println(user); o2 = model; //可以看到所有的model都是同一个对象 System.out.println(o1==o2); //可以看到存储的user对象也是同一个 System.out.println(user == o3); return &quot;output&quot;; &#125; @ModelAttribute(&quot;u&quot;) public User MyModelAttribute(Model model)&#123; o1 = model; User user = new User(); user.setId(1); user.setName(&quot;张三&quot;); user.setAge(12); user.setPassword(&quot;123&quot;);// model.addAttribute(&quot;user&quot;,user); System.out.println(&quot;modelAttribute:&quot;+user); o3 = user; return user; &#125;&#125; 总结：通过刚刚的给参数赋值，大家应该能够发现，当给方法中的参数设置值的时候，如果添加了@ModelAttribute注解，那么在查找值的时候，是遵循以下方式： 1、方法的参数使用参数的类型首字母小写，或者使用@ModelAttribute(“”)的值 2、先看之前是否在model中设置过该属性值，如果设置过就直接获取 3、看@SessionAttributes注解标注类中的方法是否给session中赋值，如果有的话，也是直接获取，没有报异常 ☀8、使用forward实现页面转发 ​ 在发送请求的时候，可以通过forward:来实现转发的功能： 12345678910111213141516171819202122232425262728package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class ForWardController &#123; /** * 当使用转发的时候可以添加前缀forward:index.jsp,此时是不会经过视图解析器的，所以要添加完整的名称 * * forward:也可以由一个请求跳转到另外一个请求 * * @return */ @RequestMapping(&quot;/forward01&quot;) public String forward()&#123; System.out.println(&quot;1&quot;); return &quot;forward:/index.jsp&quot;; &#125; @RequestMapping(&quot;/forward02&quot;) public String forward2()&#123; System.out.println(&quot;2&quot;); return &quot;forward:/forward01&quot;; &#125;&#125; ☀9、使用redirect来实现重定向 12345678910111213141516171819202122232425262728package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class RedirectController &#123; /** * redirect :重定向的路径 * 相当于 response.sendRedirect(&quot;index.jsp&quot;) * 跟视图解析器无关 * @return */ @RequestMapping(&quot;redirect&quot;) public String redirect()&#123; System.out.println(&quot;redirect&quot;); return &quot;redirect:/index.jsp&quot;; &#125; @RequestMapping(&quot;/redirect2&quot;) public String redirect2()&#123; System.out.println(&quot;redirect2&quot;); return &quot;redirect:/redirect&quot;; &#125;&#125; 在javaweb的时候大家应该都接触过重定向和转发的区别，下面再详细说一下： 转发： ​ 由服务器的页面进行跳转，不需要客户端重新发送请求： ​ 特点如下： ​ 1、地址栏的请求不会发生变化，显示的还是第一次请求的地址 ​ 2、请求的次数，有且仅有一次请求 ​ 3、请求域中的数据不会丢失 ​ 4、根目录：localhost:8080/项目地址/,包含了项目的访问地址 重定向： ​ 在浏览器端进行页面的跳转，需要发送两次请求（第一次是人为的，第二次是自动的） ​ 特点如下： ​ 1、地址栏的地址发生变化，显示最新发送请求的地址 ​ 2、请求次数：2次 ​ 3、请求域中的数据会丢失，因为是不同的请求 ​ 4、根目录：localhost:8080/ 不包含项目的名称 ​ 对比： 区别 转发forward() 重定向sendRedirect() 根目录 包含项目访问地址 没有项目访问地址 地址栏 不会发生变化 会发生变化 哪里跳转 服务器端进行的跳转 浏览器端进行的跳转 请求域中数据 不会丢失 会丢失 ☀10、静态资源的访问 ​ 当页面中包含静态资源的时候我们能够正确的获取到吗？ hello.jsp 12345678910111213&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;% pageContext.setAttribute(&quot;ctx&quot;,request.getContextPath());%&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello springmvc&lt;img src=&quot;$&#123;ctx&#125;/images/timg.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt; ​ 此时大家发现我们请求的图片根本访问不到，根据查看发现路径是没有问题的，那么为什么会找不到静态资源呢？ ​ 大家发现此时是找不到对应的mapping映射的，此时是因为DispatcherServlet会拦截所有的请求，而此时我们没有对应图片的请求处理方法，所以此时报错了，想要解决的话非常简单，只需要添加一个配置即可 12345&lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理静态资源可以访问，但是动态请求无法访问--&gt;&lt;mvc:default-servlet-handler/&gt; ​ 但是加上此配置之后，大家又发现此时除了静态资源无法访问之外，我们正常的请求也无法获取了，因此还需要再添加另外的配置： 12&lt;!--保证静态资源和动态请求都能够访问--&gt;&lt;mvc:annotation-driven/&gt; ☀（2）自定义视图解析器 ​ 我们在之前的操作中已经用了SpringMVC中提供的视图解析器，那么如果我们需要实现自己的视图解析器该如何操作呢？ MyViewController.java 123456789101112131415package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class MyViewController &#123; @RequestMapping(&quot;/myview&quot;) public String myView(Model model)&#123; model.addAttribute(&quot;msb&quot;,&quot;马士兵&quot;); return &quot;msb:/index&quot;; &#125;&#125; MyViewResolver.java 12345678910111213141516171819202122232425262728293031package com.mashibing.view;import org.springframework.core.Ordered;import org.springframework.web.servlet.View;import org.springframework.web.servlet.ViewResolver;import java.util.Locale;public class MyViewResolver implements ViewResolver, Ordered &#123; private int order = 0; public View resolveViewName(String viewName, Locale locale) throws Exception &#123; //如果前缀是msb:开头的就进行解析 if (viewName.startsWith(&quot;msb:&quot;))&#123; System.out.println(&quot;msb:&quot;); return new MyView(); &#125;else&#123; //如果不是，则直接返回null return null; &#125; &#125; public int getOrder() &#123; return this.order; &#125; public void setOrder(Integer order) &#123; this.order = order; &#125;&#125; MyView.java 12345678910111213141516171819202122232425package com.mashibing.view;import org.springframework.core.Ordered;import org.springframework.web.servlet.View;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.util.Map;public class MyView implements View &#123; public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; System.out.println(&quot;保存的对象是：&quot;+model); response.setContentType(&quot;text/html&quot;); response.getWriter().write(&quot;欢迎加入马士兵教育&quot;); &#125; /** * 返回数据内容的类型 * @return */ public String getContentType() &#123; return &quot;text/html&quot;; &#125;&#125; springmvc.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ☀（3）自定义类型转换器 ​ 在日常的企业开发需求中，我们输入文本框的内容全部都是字符串类型，但是在后端处理的时候我们可以用其他基本类型来接受数据，也可以使用实体类来接受参数，这个是怎么完成的呢？就是通过SpringMVC提供的类型转换器，SpringMVC内部提供了非常丰富的类型转换器的支持，但是有些情况下有可能难以满足我们的需求，因此需要我们自己实现，如下： User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.mashibing.bean;public class User &#123; private Integer id; private String name; private Integer age; private String gender; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; MyConverter.java 123456789101112131415161718192021package com.mashibing.converter;import com.mashibing.bean.User;import org.springframework.core.convert.converter.Converter;import org.springframework.stereotype.Component;@Componentpublic class MyConverter implements Converter&lt;String, User&gt; &#123; public User convert(String source) &#123; User user = null; String[] split = source.split(&quot;-&quot;); if (source!=null &amp;&amp; split.length==4)&#123; user = new User(); user.setId(Integer.parseInt(split[0])); user.setName(split[1]); user.setAge(Integer.parseInt(split[2])); user.setGender(split[3]); &#125; return user; &#125;&#125; UserController.java 1234567891011121314151617package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class UserController &#123; @RequestMapping(&quot;/user&quot;) public String add(User user, Model model)&#123; System.out.println(user); model.addAttribute(&quot;user&quot;,&quot;user&quot;); return &quot;success&quot;; &#125;&#125; success.jsp 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/12 Time: 21:36 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;requestScope.user&#125;&lt;/body&gt;&lt;/html&gt; springmvc.xml 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myConverter&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ☀（4）自定义日期格式化转换器 ​ 有时候我们经常需要在页面添加日期等相关信息，此时需要制定日期格式化转换器，此操作非常简单：只需要在单独的属性上添加@DateTimeFormat注解即可，制定对应的格式 User.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.mashibing.bean;import org.springframework.format.annotation.DateTimeFormat;import java.util.Date;public class User &#123; private Integer id; private String name; private Integer age; private String gender; @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birth; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &#x27;&#125;&#x27;; &#125;&#125; index.jsp 1234567891011121314151617&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;form action=&quot;dateConvertion&quot; method=&quot;post&quot;&gt; 编号：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;gender&quot;&gt;&lt;br&gt; 日期：&lt;input type=&quot;text&quot; name=&quot;birth&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; DateConvertionController.java 123456789101112131415package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class DateConvertionController &#123; @RequestMapping(&quot;dateConvertion&quot;) public String dateConvertion(User user)&#123; System.out.println(user); return &quot;hello&quot;; &#125;&#125; springmvc.xml 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理 静态资源可以访问，但是动态请求无法访问 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--保证静态资源和动态请求都能够访问--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; ​ 此时运行发现是没有问题的，但是需要注意的是，如果同时配置了自定义类型转换器之后，那么日期格式转化是有问题的。 springmvc.xml 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理 静态资源可以访问，但是动态请求无法访问 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--保证静态资源和动态请求都能够访问--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myConverter&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 原因就在于ConversionServiceFactoryBean对象中有且仅有一个属性converters，此时可以使用另外一个类来做替换FormattingConversionServiceFactoryBean springmvc.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/page/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.mashibing.view.MyViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--此配置表示 我们自己配置的请求由controller来处理，但是不能请求的处理交由tomcat来处理 静态资源可以访问，但是动态请求无法访问 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--保证静态资源和动态请求都能够访问--&gt;&lt;!-- &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;--&gt; &lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;&gt;&lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt; &lt;property name=&quot;converters&quot;&gt; &lt;set&gt; &lt;ref bean=&quot;myConverter&quot;&gt;&lt;/ref&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ☀（5）数据校验 ​ 一般情况下我们会在前端页面实现数据的校验，但是大家需要注意的是前端校验会存在数据的不安全问题，因此一般情况下我们都会使用前端校验+后端校验的方式，这样的话既能够满足用户的体验度，同时也能保证数据的安全，下面来说一下在springmvc中如何进行后端数据校验。 ​ JSR303是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 中 。JSR 303 (Java Specification Requests意思是Java 规范提案)通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。 JSR303: Hibernate Validator 扩展注解: ​ spring中拥有自己的数据校验框架，同时支持JSR303标准的校验框架，可以在通过添加注解的方式进行数据校验。在spring中本身没有提供JSR303的实现，需要导入依赖的包。 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;springmvc_viewResolver&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; index.jsp 12345678910111213141516171819202122232425&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/12 Time: 15:23 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;form action=&quot;dataValidate&quot; method=&quot;post&quot;&gt; 编号：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;text&quot; name=&quot;gender&quot;&gt;&lt;br&gt; 日期：&lt;input type=&quot;text&quot; name=&quot;birth&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt; &lt;/body&gt;&lt;/html&gt; DataValidateController.java 123456789101112131415161718192021222324package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;@Controllerpublic class DataValidateController &#123; @RequestMapping(&quot;/dataValidate&quot;) public String validate(@Valid User user, BindingResult bindingResult) &#123; System.out.println(user); if (bindingResult.hasErrors()) &#123; System.out.println(&quot;验证失败&quot;); return &quot;redirect:/index.jsp&quot;; &#125; else &#123; System.out.println(&quot;验证成功&quot;); return &quot;hello&quot;; &#125; &#125;&#125; User.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.mashibing.bean;import org.hibernate.validator.constraints.Email;import org.hibernate.validator.constraints.Length;import org.springframework.format.annotation.DateTimeFormat;import javax.validation.constraints.NotNull;import javax.validation.constraints.Past;import java.util.Date;public class User &#123; private Integer id; @NotNull @Length(min = 5,max = 10) private String name; private Integer age; private String gender; @Past @DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;) private Date birth; @Email private String email; public User() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Date getBirth() &#123; return birth; &#125; public void setBirth(Date birth) &#123; this.birth = birth; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, birth=&quot; + birth + &quot;, email=&#x27;&quot; + email + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 此时大家发现在报错的地方无法出现错误提示，可以换另外一种方式： index.jsp 1234567891011&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;a href=&quot;add&quot;&gt;添加用户&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; add.jsp 12345678910111213141516171819&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form:form action=&quot;dataValidate&quot; modelAttribute=&quot;user&quot; method=&quot;post&quot;&gt; id:&lt;form:input path=&quot;id&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;id&quot;&gt;&lt;/form:errors&gt; &lt;br/&gt; name:&lt;form:input path=&quot;name&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;name&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; age:&lt;form:input path=&quot;age&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;age&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; gender:&lt;form:input path=&quot;gender&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;gender&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; birth:&lt;form:input path=&quot;birth&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;birth&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; email:&lt;form:input path=&quot;email&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;email&quot;&gt;&lt;/form:errors&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; DataValidateController.java 12345678910111213141516171819202122232425262728293031package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;@Controllerpublic class DataValidateController &#123; @RequestMapping(&quot;/dataValidate&quot;) public String validate(@Valid User user, BindingResult bindingResult, Model model) &#123; System.out.println(user); if (bindingResult.hasErrors()) &#123; System.out.println(&quot;验证失败&quot;); return &quot;add&quot;; &#125; else &#123; System.out.println(&quot;验证成功&quot;); return &quot;hello&quot;; &#125; &#125; @RequestMapping(&quot;add&quot;) public String add(Model model)&#123; model.addAttribute(&quot;user&quot;,new User(1,&quot;zhangsan&quot;,12,&quot;女&quot;,null,&quot;1234@qq.com&quot;)); return &quot;add&quot;; &#125;&#125; web.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encoding&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 原生的表单如何获取错误信息： DataValidateController.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.mashibing.controller;import com.mashibing.bean.User;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;import org.springframework.web.bind.annotation.RequestMapping;import javax.validation.Valid;import java.util.HashMap;import java.util.List;import java.util.Map;@Controllerpublic class DataValidateController &#123; @RequestMapping(&quot;/dataValidate&quot;) public String validate(@Valid User user, BindingResult bindingResult, Model model) &#123; System.out.println(user); Map&lt;String,Object&gt; errorsMap = new HashMap&lt;String, Object&gt;(); if (bindingResult.hasErrors()) &#123; System.out.println(&quot;验证失败&quot;); List&lt;FieldError&gt; fieldErrors = bindingResult.getFieldErrors(); for (FieldError fieldError : fieldErrors) &#123; System.out.println(fieldError.getDefaultMessage()); System.out.println(fieldError.getField()); errorsMap.put(fieldError.getField(),fieldError.getDefaultMessage()); &#125; model.addAttribute(&quot;errorInfo&quot;,errorsMap); return &quot;add&quot;; &#125; else &#123; System.out.println(&quot;验证成功&quot;); return &quot;hello&quot;; &#125; &#125; @RequestMapping(&quot;add&quot;) public String add(Model model)&#123; model.addAttribute(&quot;user&quot;,new User(1,&quot;zhangsan&quot;,12,&quot;女&quot;,null,&quot;1234@qq.com&quot;)); return &quot;add&quot;; &#125;&#125; add.jsp 123456789101112131415161718&lt;%@ taglib prefix=&quot;form&quot; uri=&quot;http://www.springframework.org/tags/form&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form:form action=&quot;dataValidate&quot; modelAttribute=&quot;user&quot; method=&quot;post&quot;&gt; 编号:&lt;form:input path=&quot;id&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;id&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.id&#125; &lt;br/&gt; 姓名:&lt;form:input path=&quot;name&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;name&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.name&#125;&lt;br/&gt; 年龄:&lt;form:input path=&quot;age&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;age&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.age&#125;&lt;br/&gt; 性别:&lt;form:input path=&quot;gender&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;gender&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.gender&#125;&lt;br/&gt; 生日:&lt;form:input path=&quot;birth&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;birth&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfobirth&#125;&lt;br/&gt; 邮箱:&lt;form:input path=&quot;email&quot;&gt;&lt;/form:input&gt;&lt;form:errors path=&quot;email&quot;&gt;&lt;/form:errors&gt;---&gt;$&#123;errorInfo.email&#125;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form:form&gt;&lt;/body&gt;&lt;/html&gt; ​","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://aner1001.gitee.io/tags/SpringMVC/"}]},{"title":"SpringMVC学习笔记1-介绍和使用","slug":"技术知识/Java/框架/SpringMVC/SpringMVC学习笔记1-介绍和使用","date":"2021-02-25T13:48:32.000Z","updated":"2021-02-25T13:48:32.000Z","comments":true,"path":"posts/2021/02/25/e67109eb06c2/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/25/e67109eb06c2/","excerpt":"MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。就是将业务逻辑、数据、显示分离的方法来组织代码。MVC主要作用是降低了视图与业务逻辑间的双向偶合。MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。","text":"MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。就是将业务逻辑、数据、显示分离的方法来组织代码。MVC主要作用是降低了视图与业务逻辑间的双向偶合。MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 ☀1.什么是MVC？ ​ MVC是模型(Model)、视图(View)、控制器(Controller)的简写，是一种软件设计规范。就是将业务逻辑、数据、显示分离的方法来组织代码。MVC主要作用是降低了视图与业务逻辑间的双向偶合。MVC不是一种设计模式，MVC是一种架构模式。当然不同的MVC存在差异。 ​ **Model（模型）：**数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据Dao） 和 服务层（行为Service）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 ​ **View（视图）：**负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。 ​ **Controller（控制器）：**接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作。 ​ 其实在最早期的时候还有model1和model2的设计模型 最典型的MVC就是JSP + servlet + javabean的模式。 代码展示： HelloServlet.java 1234567891011121314151617181920212223package com.mashibing.controller;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;public class HelloServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String method = request.getParameter(&quot;method&quot;); if (method.equals(&quot;add&quot;))&#123; request.getSession().setAttribute(&quot;msg&quot;,&quot;add&quot;); &#125;else if(method.equals(&quot;sub&quot;))&#123; request.getSession().setAttribute(&quot;msg&quot;,&quot;sub&quot;); &#125; request.getRequestDispatcher(&quot;index.jsp&quot;).forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; web.xml 💃牢记：项目中的web.xml继承于Tomcat中的web.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.mashibing.controller.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; index.jsp 12345678910&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;msg&#125; &lt;/body&gt;&lt;/html&gt; 输入网址：http://localhost:8080/servlet_demo_war_exploded/user?method=add ☀2.SpringMVC ☀1.SpringMVC的介绍 12Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, “Spring Web MVC,” comes from the name of its source module (spring-webmvc), but it is more commonly known as “Spring MVC”.Spring Web MVC是构建在Servlet API上的原始Web框架，从一开始就包含在Spring Framework中。 正式名称 “Spring Web MVC,” 来自其源模块(spring-webmvc)的名称，但它通常被称为“Spring MVC”。 ​ 简而言之，springMVC是Spring框架的一部分，是基于java实现的一个轻量级web框架。 ​ 学习SpringMVC框架最核心的就是DispatcherServlet的设计，掌握好DispatcherServlet是掌握SpringMVC的核心关键。 ☀2.SpringMVC的优点 ​ 1.清晰的角色划分：控制器(controller)、验证器(validator)、命令对象(command obect)、表单对象(form object)、模型对象(model object)、Servlet分发器(DispatcherServlet)、处理器映射(handler mapping)、试图解析器(view resoler)等等。每一个角色都可以由一个专门的对象来实现。 ​ 2.强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器validator)的引用。 ​ 3.可适配、非侵入：可以根据不同的应用场景，选择何事的控制器子类(simple型、command型、from型、wizard型、multi-action型或者自定义)，而不是一个单一控制器(比如Action/ActionForm)继承。 ​ 4.可重用的业务代码：可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类。 ​ 5.可定制的绑定(binding)和验证(validation)：比如将类型不匹配作为应用级的验证错误，这可以保证错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象，需要手动解析它并转换到业务对象。 ​ 6.可定制的handler mapping和view resolution：Spring提供从最简单的URL映射，到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活。 ​ 7.灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成。 ​ 8.可定制的本地化和主题(theme)解析：支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity(不需要额外的中间层)等等。 ​ 9.简单而强大的JSP标签库(Spring Tag Library)：支持包括诸如数据绑定和主题(theme)之类的许多功能。他提供在标记方面的最大灵活性。 ​ 10.JSP表单标签库：在Spring2.0中引入的表单标签库，使用在JSP编写表单更加容易。 ​ 11.Spring Bean的生命周期：可以被限制在当前的HTTp Request或者HTTp Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。 ☀3.SpringMVC的实现原理 ​ springmvc的mvc模式： SpringMVC的具体执行流程： ​ 当发起请求时被前置的控制器拦截到请求，根据请求参数生成代理请求，找到请求对应的实际控制器，控制器处理请求，创建数据模型，访问数据库，将模型响应给中心控制器，控制器使用模型与视图渲染视图结果，将结果返回给中心控制器，再将结果返回给请求者。 12345678910111、DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。2、HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。3、返回处理器执行链，根据url查找控制器，并且将解析后的信息传递给DispatcherServlet4、HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。5、执行handler找到具体的处理器6、Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。7、HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。8、DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。9、视图解析器将解析的逻辑视图名传给DispatcherServlet。10、DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染11、将响应数据返回给客户端 ☀3.基于XML的Hello_SpringMVC 1、添加pom依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、编写web.xml文件 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--关联springmvc的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--匹配servlet的请求，/标识匹配所有请求--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!--/*和/都是拦截所有请求，/会拦截的请求不包含*.jsp,而/*的范围更大，还会拦截*.jsp这些请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3、编写springmvc需要的spring配置文件，applicationContext.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--处理映射器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt; &lt;!--处理器适配器--&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;&gt;&lt;/bean&gt; &lt;!--视图解析器--&gt; &lt;bean id=&quot;internalResourceViewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!--配置前缀--&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt; &lt;!--配置后缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;/hello&quot; class=&quot;com.mashibing.controller.HelloController&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 4、HelloController.java 1234567891011121314151617181920package com.mashibing.controller;import org.springframework.web.servlet.ModelAndView;import org.springframework.web.servlet.mvc.Controller;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloController implements Controller &#123; public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception &#123; //创建模型和视图对象 ModelAndView mv = new ModelAndView(); //将需要的值传递到model中 mv.addObject(&quot;msg&quot;,&quot;helloSpringMVC&quot;); //设置要跳转的视图， mv.setViewName(&quot;hello&quot;); return mv; &#125;&#125; 5、创建hello.jsp页面 1234567891011121314151617&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/5 Time: 20:25 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 6、配置tomcat，发送请求 http://localhost:8080/hello ☀4.基于注解的Hello_SpringMVC 1、添加pom依赖 1234567891011121314151617181920&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、编写web.xml文件 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--匹配servlet的请求， /：标识匹配所有请求，但是不会jsp页面 /*：拦截所有请求，拦截jsp页面 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3、编写applicationContext.xml文件 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!--自动扫描包，由IOC容器进行控制管理--&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; id=&quot;internalResourceViewResolver&quot;&gt; &lt;!-- 前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;!-- 后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 4、编写HelloController.java 12345678910111213141516171819package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController&#123; /* * @RequestMapping就是用来标识此方法用来处理什么请求，其中的/可以取消 * 取消后默认也是从当前项目的根目录开始查找，一般在编写的时候看个人习惯 * 同时，@RequestMapping也可以用来加在类上， * */ @RequestMapping(&quot;/hello&quot;) public String hello(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); return &quot;hello&quot;; &#125;&#125; 5、编写hello.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;msg&#125;&lt;/body&gt;&lt;/html&gt; 6、输入请求http://localhost:8080/hello ☀5.注意细节 ☀1.springmvc_helloworld运行流程： ​ 通过上述的代码，我们能够总结出具体的运行流程： ​ 1、客户端发送请求http://localhost:8080/hello ​ 2、由tomcat接受到对应的请求 ​ 3、SpringMVC的前端控制器DispatcherServlet接收到所有的请求 ​ 4、查看请求地址和@RequestMapping注解的哪个匹配，来找到具体的类的处理方法 ​ 5、前端控制器找到目标处理类和方法之后，执行目标方法 ​ 6、方法执行完成之后会有一个返回值，SpringMVC会将这个返回值用视图解析器进行解析拼接成完整的页面地址 ​ 7、DispatcherServlet拿到页面地址之后，转发到具体的页面 ☀2.springmvc的配置文件 web.xml 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件 此配置文件的属性可以不添加，但是需要在WEB-INF的目录下创建 前端控制器名称-servlet.xml文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ☀3.DispatcherServlet的url-pattern web.xml 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件 此配置文件的属性可以不添加，但是需要在WEB-INF的目录下创建 前端控制器名称-servlet.xml文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--匹配servlet的请求， /：标识匹配所有请求，但是不会jsp页面 /*：拦截所有请求，拦截jsp页面 但是需要注意的是，当配置成index.html的时候，会发现请求不到 原因在于，tomcat下也有一个web.xml文件，所有的项目下web.xml文件都需要继承此web.xml 在服务器的web.xml文件中有一个DefaultServlet用来处理静态资源，但是url-pattern是/ 而我们在自己的配置文件中如果添加了url-pattern=/会覆盖父类中的url-pattern，此时在请求的时候 DispatcherServlet会去controller中做匹配，找不到则直接报404 而在服务器的web.xml文件中包含了一个JspServlet的处理，所以不过拦截jsp请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; ☀4.@RequestMapping ​ @RequestMapping用来匹配客户端发送的请求，可以在方法上使用，也可以在类上使用。 ​ 方法：表示用来匹配要处理的请求 ​ 类上：表示为当前类的所有方法的请求地址添加一个前置路径，访问的时候必须要添加此路径 123456789101112131415161718192021package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;@Controller@RequestMapping(&quot;/mashibing&quot;)public class HelloController&#123; /* * @RequestMapping就是用来标识此方法用来处理什么请求，其中的/可以取消 * 取消后默认也是从当前项目的根目录开始查找，一般在编写的时候看个人习惯 * 同时，@RequestMapping也可以用来加在类上， * */ @RequestMapping(&quot;/hello&quot;) public String hello(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); return &quot;hello&quot;; &#125;&#125; ​ 注意：在整个项目的不同方法上不能包含相同的@RequestMapping值 ​ 除此以外，@RequestMapping注解还可以添加很多额外的属性值，用来精确匹配请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping(&quot;/mashibing&quot;)public class HelloController&#123; /* * @RequestMapping就是用来标识此方法用来处理什么请求，其中的/可以取消 * 取消后默认也是从当前项目的根目录开始查找，一般在编写的时候看个人习惯 * 同时，@RequestMapping也可以用来加在类上， * */ @RequestMapping(&quot;/hello&quot;) public String hello(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); return &quot;hello&quot;; &#125; /** * Request的其他属性值 * value:要匹配的请求 * method:限制发送请求的方式： POST GET * params:表示请求要接受的参数,如果定义了这个属性，那么发送的时候必须要添加参数 * params有几种匹配规则 * 1、直接写参数的名称，param1,param2 * params = &#123;&quot;username&quot;&#125; * 2、表示请求不能包含的参数，！param1 * params = &#123;&quot;!username&quot;&#125; * 3、表示请求中需要要包含的参数但是可以限制值 param1=values param1!=value * params = &#123;&quot;username=123&quot;,&quot;age&quot;&#125; * params = &#123;&quot;username!=123&quot;,&quot;age&quot;&#125; * headers:填写请求头信息 * chrome：User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36 * firefox:User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0 * * consumers:只接受内容类型是哪种的请求，相当于指定Content-Type * produces:返回的内容类型 Content-Type：text/html;charset=utf-8 * * @return */ @RequestMapping(value = &quot;/hello2&quot;,method = RequestMethod.POST) public String hello2()&#123; return &quot;hello&quot;; &#125; @RequestMapping(value = &quot;/hello3&quot;,params = &#123;&quot;username!=123&quot;,&quot;age&quot;&#125;) public String hello3(String username)&#123; System.out.println(username); return &quot;hello&quot;; &#125; @RequestMapping(value = &quot;/hello4&quot;,headers = &#123;&quot;User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&quot;&#125;) public String hello4()&#123; return &quot;hello&quot;; &#125;&#125; ​ @RequestMapping还包含了很多复杂的匹配功能，提供了通配符的支持： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping(&quot;/mashibing&quot;)public class HelloController&#123; /* * @RequestMapping就是用来标识此方法用来处理什么请求，其中的/可以取消 * 取消后默认也是从当前项目的根目录开始查找，一般在编写的时候看个人习惯 * 同时，@RequestMapping也可以用来加在类上， * */ @RequestMapping(&quot;/hello&quot;) public String hello(Model model)&#123; model.addAttribute(&quot;msg&quot;,&quot;hello,SpringMVC&quot;); return &quot;hello&quot;; &#125; /** * Request的其他属性值 * value:要匹配的请求 * method:限制发送请求的方式： POST GET * params:表示请求要接受的参数,如果定义了这个属性，那么发送的时候必须要添加参数 * params有几种匹配规则 * 1、直接写参数的名称，param1,param2 * params = &#123;&quot;username&quot;&#125; * 2、表示请求不能包含的参数，！param1 * params = &#123;&quot;!username&quot;&#125; * 3、表示请求中需要要包含的参数但是可以限制值 param1=values param1!=value * params = &#123;&quot;username=123&quot;,&quot;age&quot;&#125; * params = &#123;&quot;username!=123&quot;,&quot;age&quot;&#125; * headers:填写请求头信息 * chrome：User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.79 Safari/537.36 * firefox:User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0 * * consumers:只接受内容类型是哪种的请求，相当于指定Content-Type * produces:返回的内容类型 Content-Type：text/html;charset=utf-8 * * @return */ @RequestMapping(value = &quot;/hello2&quot;,method = RequestMethod.POST) public String hello2()&#123; return &quot;hello&quot;; &#125; @RequestMapping(value = &quot;/hello3&quot;,params = &#123;&quot;username!=123&quot;,&quot;age&quot;&#125;) public String hello3(String username)&#123; System.out.println(username); return &quot;hello&quot;; &#125; @RequestMapping(value = &quot;/hello4&quot;,headers = &#123;&quot;User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0&quot;&#125;) public String hello4()&#123; return &quot;hello&quot;; &#125; /** * @Request包含三种模糊匹配的方式，分别是： * ？：能替代任意一个字符 * *: 能替代任意多个字符和一层路径 * **：能代替多层路径 * @return */ @RequestMapping(value = &quot;/**/h*llo?&quot;) public String hello5()&#123; System.out.println(&quot;hello5&quot;); return &quot;hello&quot;; &#125;&#125; ☀6.@PathVariable ​ 如果需要在请求路径中的参数像作为参数应该怎么使用呢？可以使用@PathVariable注解，此注解就是提供了对占位符URL的支持，就是将URL中占位符参数绑定到控制器处理方法的参数中。 123456789101112131415161718package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping(&quot;/mashibing&quot;)public class HelloController&#123; @RequestMapping(value = &quot;/pathVariable/&#123;name&#125;&quot;) public String pathVariable(@PathVariable(&quot;name&quot;) String name)&#123; System.out.println(name); return &quot;hello&quot;; &#125;&#125; ☀7.REST ​ REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。 ​ 在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。 ​ REST,翻译过来叫做表现层状态转化，是目前最流行的一个互联网软件架构，它架构清晰，符合标准，易于理解，扩展方便。 ​ 表现层（Representation）：把资源具体呈现出来的形式，因此叫做表现层。 ​ 资源（Resource）：网络上的一个具体信息，文本，图片，音频，视频都可以称之为资源，如果想要访问到互联网上的某一个资源，那么就必须要使用一个URL来唯一性的获取改资源，也可以这么说，URL是每一个资源的唯一标识符。 ​ 状态转化（State Transfer）：当客户端发出一个请求的时候，就代表客户端跟服务端的一次交互过程，HTTP是一种无状态协议，即所有的状态都保存在服务器端，因此，客户端如果想要操作服务器，必须通过某些手段，让服务器的状态发生转化，而这种转化是建立在表现层的，这就是名字的由来（非人话） ​ 人话：我们在获取资源的时候就是进行增删改查的操作，如果是原来的架构风格，需要发送四个请求，分别是： ​ 查询：localhost:8080/query?id=1 ​ 增加：localhost:8080/insert ​ 删除：localhost:8080/delete?id=1 ​ 更新：localhost:8080/update?id=1 ​ 按照此方式发送请求的时候比较麻烦，需要定义多种请求，而在HTTP协议中，有不同的发送请求的方式，分别是GET、POST、PUT、DELETE等，我们如果能让不同的请求方式表示不同的请求类型就可以简化我们的查询 ​ GET：获取资源 /book/1 ​ POST：新建资源 /book ​ PUT：更新资源 /book/1 ​ DELETE：删除资源 /book/1 ​ 一切看起来都非常美好，但是大家需要注意了，我们在发送请求的时候只能发送post或者get，没有办法发送put和delete请求，那么应该如何处理呢？下面开始进入代码环节： RestController.java 1234567891011121314151617181920212223242526272829303132333435package com.mashibing.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Controllerpublic class RestController &#123; @RequestMapping(value = &quot;/user&quot;,method = RequestMethod.POST) public String add()&#123; System.out.println(&quot;添加&quot;); return &quot;success&quot;; &#125; @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;,method = RequestMethod.DELETE) public String delete(@PathVariable(&quot;id&quot;) Integer id)&#123; System.out.println(&quot;删除：&quot;+id); return &quot;success&quot;; &#125; @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;,method = RequestMethod.PUT) public String update(@PathVariable(&quot;id&quot;) Integer id)&#123; System.out.println(&quot;更新：&quot;+id); return &quot;success&quot;; &#125; @RequestMapping(value = &quot;/user/&#123;id&#125;&quot;,method = RequestMethod.GET) public String query(@PathVariable(&quot;id&quot;) Integer id)&#123; System.out.println(&quot;查询：&quot;+id); return &quot;success&quot;; &#125;&#125; web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;!--配置DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 关联springmvc的配置文件： 此配置文件的属性可以不添加，但是需要在WEB-INF的目录下创建 前端控制器名称-servlet.xml文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--匹配servlet的请求， /：标识匹配所有请求，但是不会jsp页面 /*：拦截所有请求，拦截jsp页面 但是需要注意的是，当配置成index.html的时候，会发现请求不到 原因在于，tomcat下也有一个web.xml文件，所有的项目下web.xml文件都需要继承此web.xml 在服务器的web.xml文件中有一个DefaultServlet用来处理静态资源，但是url-pattern是/ 而我们在自己的配置文件中如果添加了url-pattern=/会覆盖父类中的url-pattern，此时在请求的时候 DispatcherServlet会去controller中做匹配，找不到则直接报404 而在服务器的web.xml文件中包含了一个JspServlet的处理，所以不过拦截jsp请求 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;hiddenFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;hiddenFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; rest.jsp 123456789101112131415161718192021222324252627&lt;%-- Created by IntelliJ IDEA. User: root Date: 2020/3/6 Time: 23:01 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;/user&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;增加&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/user/1&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;_method&quot; value=&quot;delete&quot; type=&quot;hidden&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;删除&quot;&gt; &lt;/form&gt; &lt;form action=&quot;/user/1&quot; method=&quot;post&quot;&gt; &lt;input name=&quot;_method&quot; value=&quot;put&quot; type=&quot;hidden&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;修改&quot;&gt; &lt;/form&gt; &lt;a href=&quot;/user/1&quot;&gt;查询&lt;/a&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; success.jsp 123456789&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; isErrorPage=&quot;true&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;666&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://aner1001.gitee.io/tags/SpringMVC/"}]},{"title":"Spring学习笔记-AOP基本介绍","slug":"技术知识/Java/框架/Spring/Spring学习笔记-AOP基本介绍","date":"2021-02-25T09:22:19.000Z","updated":"2021-02-25T09:22:19.000Z","comments":true,"path":"posts/2021/02/25/d257d0f10a3c/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/25/d257d0f10a3c/","excerpt":"AOP：Aspect Oriented Programming 面向切面编程 OOP：Object Oriented Programming 面向对象编程","text":"AOP：Aspect Oriented Programming 面向切面编程 OOP：Object Oriented Programming 面向对象编程 面向切面编程：基于OOP基础之上新的编程思想，OOP面向的主要对象是类，而AOP面向的主要对象是切面，在处理日志、安全管理、事务管理等方面有非常重要的作用。AOP是Spring中重要的核心点，虽然IOC容器没有依赖AOP，但是AOP提供了非常强大的功能，用来对IOC做补充。通俗点说的话就是在程序运行期间，将某段代码动态切入到指定方法的指定位置进行运行的这种编程方式。 ☀1.AOP的概念 ☀为什么要引入AOP? Calculator.java 123456789101112package com.mashibing.inter;public interface Calculator &#123; public int add(int i,int j); public int sub(int i,int j); public int mult(int i,int j); public int div(int i,int j);&#125; MyCalculator.java 1234567891011121314151617181920212223package com.mashibing.inter;public class MyCalculator implements Calculator &#123; public int add(int i, int j) &#123; int result = i + j; return result; &#125; public int sub(int i, int j) &#123; int result = i - j; return result; &#125; public int mult(int i, int j) &#123; int result = i * j; return result; &#125; public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; MyTest.java 123456public class MyTest &#123; public static void main(String[] args) throws SQLException &#123; MyCalculator myCalculator = new MyCalculator(); System.out.println(myCalculator.add(1, 2)); &#125;&#125; ​ 此代码非常简单，就是基础的javase的代码实现，此时如果需要添加日志功能应该怎么做呢，只能在每个方法中添加日志输出，同时如果需要修改的话会变得非常麻烦。 MyCalculator.java 12345678910111213141516171819202122232425262728293031package com.mashibing.inter;public class MyCalculator implements Calculator &#123; public int add(int i, int j) &#123; System.out.println(&quot;add 方法开始执行，参数为：&quot;+i+&quot;,&quot;+j); int result = i + j; System.out.println(&quot;add 方法开始完成结果为：&quot;+result); return result; &#125; public int sub(int i, int j) &#123; System.out.println(&quot;sub 方法开始执行，参数为：&quot;+i+&quot;,&quot;+j); int result = i - j; System.out.println(&quot;add 方法开始完成结果为：&quot;+result); return result; &#125; public int mult(int i, int j) &#123; System.out.println(&quot;mult 方法开始执行，参数为：&quot;+i+&quot;,&quot;+j); int result = i * j; System.out.println(&quot;add 方法开始完成结果为：&quot;+result); return result; &#125; public int div(int i, int j) &#123; System.out.println(&quot;div 方法开始执行，参数为：&quot;+i+&quot;,&quot;+j); int result = i / j; System.out.println(&quot;add 方法开始完成结果为：&quot;+result); return result; &#125;&#125; ​ 可以考虑将日志的处理抽象出来，变成工具类来进行实现： LogUtil.java 1234567891011121314package com.mashibing.util;import java.util.Arrays;public class LogUtil &#123; public static void start(Object ... objects)&#123; System.out.println(&quot;XXX方法开始执行，使用的参数是：&quot;+ Arrays.asList(objects)); &#125; public static void stop(Object ... objects)&#123; System.out.println(&quot;XXX方法执行结束，结果是：&quot;+ Arrays.asList(objects)); &#125;&#125; MyCalculator.java 123456789101112131415161718192021222324252627282930313233package com.mashibing.inter;import com.mashibing.util.LogUtil;public class MyCalculator implements Calculator &#123; public int add(int i, int j) &#123; LogUtil.start(i,j); int result = i + j; LogUtil.stop(result); return result; &#125; public int sub(int i, int j) &#123; LogUtil.start(i,j); int result = i - j; LogUtil.stop(result); return result; &#125; public int mult(int i, int j) &#123; LogUtil.start(i,j); int result = i * j; LogUtil.stop(result); return result; &#125; public int div(int i, int j) &#123; LogUtil.start(i,j); int result = i / j; LogUtil.stop(result); return result; &#125;&#125; ​ 按照上述方式抽象之后，代码确实简单很多，但是大家应该已经发现在输出的信息中并不包含具体的方法名称，我们更多的是想要在程序运行过程中动态的获取方法的名称及参数、结果等相关信息，此时可以通过使用动态代理的方式来进行实现。 CalculatorProxy.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.mashibing.proxy;import com.mashibing.inter.Calculator;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/** * 帮助Calculator生成代理对象的类 */public class CalculatorProxy &#123; /** * * 为传入的参数对象创建一个动态代理对象 * @param calculator 被代理对象 * @return */ public static Calculator getProxy(final Calculator calculator)&#123; //被代理对象的类加载器 ClassLoader loader = calculator.getClass().getClassLoader(); //被代理对象的接口 Class&lt;?&gt;[] interfaces = calculator.getClass().getInterfaces(); //方法执行器，执行被代理对象的目标方法 InvocationHandler h = new InvocationHandler() &#123; /** * 执行目标方法 * @param proxy 代理对象，给jdk使用，任何时候都不要操作此对象 * @param method 当前将要执行的目标对象的方法 * @param args 这个方法调用时外界传入的参数值 * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //利用反射执行目标方法,目标方法执行后的返回值// System.out.println(&quot;这是动态代理执行的方法&quot;); Object result = null; try &#123; System.out.println(method.getName()+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(args)); result = method.invoke(calculator, args); System.out.println(method.getName()+&quot;方法执行完成，结果是：&quot;+ result); &#125; catch (Exception e) &#123; System.out.println(method.getName()+&quot;方法出现异常：&quot;+ e.getMessage()); &#125; finally &#123; System.out.println(method.getName()+&quot;方法执行结束了......&quot;); &#125; //将结果返回回去 return result; &#125; &#125;; Object proxy = Proxy.newProxyInstance(loader, interfaces, h); return (Calculator) proxy; &#125;&#125; ​ 我们可以看到这种方式更加灵活，而且不需要在业务方法中添加额外的代码，这才是常用的方式。如果想追求完美的同学，还可以使用上述的日志工具类来完善。 LogUtil.java 1234567891011121314151617181920212223242526package com.mashibing.util;import java.lang.reflect.Method;import java.util.Arrays;public class LogUtil &#123; public static void start(Method method, Object ... objects)&#123;// System.out.println(&quot;XXX方法开始执行，使用的参数是：&quot;+ Arrays.asList(objects)); System.out.println(method.getName()+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(objects)); &#125; public static void stop(Method method,Object ... objects)&#123;// System.out.println(&quot;XXX方法执行结束，结果是：&quot;+ Arrays.asList(objects)); System.out.println(method.getName()+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(objects)); &#125; public static void logException(Method method,Exception e)&#123; System.out.println(method.getName()+&quot;方法出现异常：&quot;+ e.getMessage()); &#125; public static void end(Method method)&#123; System.out.println(method.getName()+&quot;方法执行结束了......&quot;); &#125;&#125; CalculatorProxy.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.mashibing.proxy;import com.mashibing.inter.Calculator;import com.mashibing.util.LogUtil;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.util.Arrays;/** * 帮助Calculator生成代理对象的类 */public class CalculatorProxy &#123; /** * * 为传入的参数对象创建一个动态代理对象 * @param calculator 被代理对象 * @return */ public static Calculator getProxy(final Calculator calculator)&#123; //被代理对象的类加载器 ClassLoader loader = calculator.getClass().getClassLoader(); //被代理对象的接口 Class&lt;?&gt;[] interfaces = calculator.getClass().getInterfaces(); //方法执行器，执行被代理对象的目标方法 InvocationHandler h = new InvocationHandler() &#123; /** * 执行目标方法 * @param proxy 代理对象，给jdk使用，任何时候都不要操作此对象 * @param method 当前将要执行的目标对象的方法 * @param args 这个方法调用时外界传入的参数值 * @return * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //利用反射执行目标方法,目标方法执行后的返回值// System.out.println(&quot;这是动态代理执行的方法&quot;); Object result = null; try &#123; LogUtil.start(method,args); result = method.invoke(calculator, args); LogUtil.stop(method,args); &#125; catch (Exception e) &#123; LogUtil.logException(method,e); &#125; finally &#123; LogUtil.end(method); &#125; //将结果返回回去 return result; &#125; &#125;; Object proxy = Proxy.newProxyInstance(loader, interfaces, h); return (Calculator) proxy; &#125;&#125; ​ 很多同学看到上述代码之后可能感觉已经非常完美了，但是要说明的是，这种动态代理的实现方式调用的是jdk的基本实现，如果需要代理的目标对象没有实现任何接口，那么是无法为他创建代理对象的，这也是致命的缺陷。而在Spring中我们可以不编写上述如此复杂的代码，只需要利用AOP，就能够轻轻松松实现上述功能，当然，Spring AOP的底层实现也依赖的是动态代理。 ☀AOP的核心概念及术语 切面（Aspect）: 指关注点模块化，这个关注点可能会横切多个对象。事务管理是企业级Java应用中有关横切关注点的例子。 在Spring AOP中，切面可以使用通用类基于模式的方式（schema-based approach）或者在普通类中以@Aspect注解（@AspectJ 注解方式）来实现。 连接点（Join point）: 在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。 通知（Advice）: 在切面的某个特定的连接点上执行的动作。通知有多种类型，包括“around”, “before” and “after”等等。通知的类型将在后面的章节进行讨论。 许多AOP框架，包括Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。 切点（Pointcut）: 匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如，当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP的核心：Spring默认使用AspectJ切点语义。 引入（Introduction）: 声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean实现 IsModified接口， 以便简化缓存机制（在AspectJ社区，引入也被称为内部类型声明（inter））。 目标对象（Target object）: 被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。 AOP代理（AOP proxy）:AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。 织入（Weaving）: 把切面连接到其它的应用程序类型或者对象上，并创建一个被被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ编译器）、类加载时或运行时中完成。 Spring和其他纯Java AOP框架一样，是在运行时完成织入的。 ☀AOP的通知类型 前置通知（Before advice）: 在连接点之前运行但无法阻止执行流程进入连接点的通知（除非它引发异常）。 后置返回通知（After returning advice）:在连接点正常完成后执行的通知（例如，当方法没有抛出任何异常并正常返回时）。 后置异常通知（After throwing advice）: 在方法抛出异常退出时执行的通知。 后置通知（总会执行）（After (finally) advice）: 当连接点退出的时候执行的通知（无论是正常返回还是异常退出）。 环绕通知（Around Advice）:环绕连接点的通知，例如方法调用。这是最强大的一种通知类型，。环绕通知可以在方法调用前后完成自定义的行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束。 ☀AOP的应用场景 日志管理 权限认证 安全检查 事务控制 ☀2.Spring AOP的简单配置 ​ 在上述代码中我们是通过动态代理的方式实现日志功能的，但是比较麻烦，现在我们将要使用spring aop的功能实现此需求，其实通俗点说的话，就是把LogUtil的工具类换成另外一种实现方式。 ☀1、添加pom依赖 123456789101112131415161718192021222324&lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/aopalliance/aopalliance --&gt;&lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aspects --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; ☀2、编写配置 将目标类和切面类加入到IOC容器中，在对应的类上添加组件注解 给LogUtil添加@Component注解 给MyCalculator添加@Service注解 添加自动扫描的配置 12&lt;!--别忘了添加context命名空间--&gt;&lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; 设置程序中的切面类 在LogUtil.java中添加@Aspect注解 设置切面类中的方法是什么时候在哪里执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.mashibing.util;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.lang.reflect.Method;import java.util.Arrays;@Component@Aspectpublic class LogUtil &#123; /* 设置下面方法在什么时候运行 @Before:在目标方法之前运行：前置通知 @After:在目标方法之后运行：后置通知 @AfterReturning:在目标方法正常返回之后：返回通知 @AfterThrowing:在目标方法抛出异常后开始运行：异常通知 @Around:环绕：环绕通知 当编写完注解之后还需要设置在哪些方法上执行，使用表达式 execution(访问修饰符 返回值类型 方法全称) */ @Before(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void start()&#123;// System.out.println(&quot;XXX方法开始执行，使用的参数是：&quot;+ Arrays.asList(objects));// System.out.println(method.getName()+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(objects)); System.out.println(&quot;方法开始执行，参数是：&quot;); &#125; @AfterReturning(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void stop()&#123;// System.out.println(&quot;XXX方法执行结束，结果是：&quot;+ Arrays.asList(objects));// System.out.println(method.getName()+&quot;方法执行结束，结果是：&quot;+ Arrays.asList(objects)); System.out.println(&quot;方法执行完成，结果是：&quot;); &#125; @AfterThrowing(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void logException()&#123;// System.out.println(method.getName()+&quot;方法出现异常：&quot;+ e.getMessage()); System.out.println(&quot;方法出现异常：&quot;); &#125; @After(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void end()&#123;// System.out.println(method.getName()+&quot;方法执行结束了......&quot;); System.out.println(&quot;方法执行结束了......&quot;); &#125;&#125; 开启基于注解的aop的功能 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; ☀3、测试 MyTest.java 12345678910 import com.mashibing.inter.Calculator; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyTest &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;aop.xml&quot;); Calculator bean = context.getBean(Calculator.class); bean.add(1,1); &#125;&#125; ​ spring AOP的动态代理方式是jdk自带的方式，容器中保存的组件是代理对象com.sun.proxy.$Proxy对象 ☀4、通过cglib来创建代理对象 MyCalculator.java 1234567891011121314151617181920212223242526package com.mashibing.inter;import org.springframework.stereotype.Service;@Servicepublic class MyCalculator &#123; public int add(int i, int j) &#123; int result = i + j; return result; &#125; public int sub(int i, int j) &#123; int result = i - j; return result; &#125; public int mult(int i, int j) &#123; int result = i * j; return result; &#125; public int div(int i, int j) &#123; int result = i / j; return result; &#125;&#125; MyTest.java 123456789public class MyTest &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;aop.xml&quot;); MyCalculator bean = context.getBean(MyCalculator.class); bean.add(1,1); System.out.println(bean); System.out.println(bean.getClass()); &#125;&#125; ​ 可以通过cglib的方式来创建代理对象，此时不需要实现任何接口，代理对象是 class com.mashibing.inter.MyCalculator$$EnhancerBySpringCGLIB$$1f93b605类型 ​ 综上所述：在spring容器中，如果有接口，那么会使用jdk自带的动态代理，如果没有接口，那么会使用cglib的动态代理。动态代理的实现原理，后续会详细讲。 ☀注意点： ☀1、切入点表达式 ​ 在使用表达式的时候，除了之前的写法之外，还可以使用通配符的方式： ​ *： ​ 1、匹配一个或者多个字符 ​ execution( public int com.mashibing.inter.My*alculator.*(int,int)) ​ 2、匹配任意一个参数， ​ execution( public int com.mashibing.inter.MyCalculator.*(int,*)) ​ 3、只能匹配一层路径，如果项目路径下有多层目录，那么*只能匹配一层路径 ​ 4、权限位置不能使用*，如果想表示全部权限，那么不写即可 ​ execution( * com.mashibing.inter.MyCalculator.*(int,*)) ​ …： ​ 1、匹配多个参数，任意类型参数 ​ execution( * com.mashibing.inter.MyCalculator.*(…)) ​ 2、匹配任意多层路径 ​ execution( * com.mashibing…MyCalculator.*(…)) ​ 在写表达式的时候，可以有N多种写法，但是有一种最偷懒和最精确的方式： ​ 最偷懒的方式：execution(* *(…)) 或者 execution(* *.*(…)) ​ 最精确的方式：execution( public int com.mashibing.inter.MyCalculator.add(int,int)) ​ 除此之外，在表达式中还支持 &amp;&amp;、||、！的方式 ​ &amp;&amp;：两个表达式同时 ​ execution( public int com.mashibing.inter.MyCalculator.*(…)) &amp;&amp; execution(* *.*(int,int) ) ​ ||：任意满足一个表达式即可 ​ execution( public int com.mashibing.inter.MyCalculator.*(…)) &amp;&amp; execution(* *.*(int,int) ) ​ ！：只要不是这个位置都可以进行切入 ​ &amp;&amp;：两个表达式同时 ​ execution( public int com.mashibing.inter.MyCalculator.*(…)) ☀2、通知方法的执行顺序 ​ 在之前的代码中大家一直对通知的执行顺序有疑问，其实执行的结果并没有错，大家需要注意： ​ 1、正常执行：@Before—&gt;@After—&gt;@AfterReturning ​ 2、异常执行：@Before—&gt;@After—&gt;@AfterThrowing ☀3、获取方法的详细信息 ​ 在上面的案例中，我们并没有获取Method的详细信息，例如方法名、参数列表等信息，想要获取的话其实非常简单，只需要添加JoinPoint参数即可。 LogUtil.java 1234567891011121314151617181920212223242526272829303132333435363738package com.mashibing.util;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspectpublic class LogUtil &#123; @Before(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void start(JoinPoint joinPoint)&#123; Object[] args = joinPoint.getArgs(); String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(args)); &#125; @AfterReturning(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void stop(JoinPoint joinPoint)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法执行完成，结果是：&quot;); &#125; @AfterThrowing(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void logException(JoinPoint joinPoint)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法出现异常：&quot;); &#125; @After(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public static void end(JoinPoint joinPoint)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法执行结束了......&quot;); &#125;&#125; ​ 刚刚只是获取了方法的信息，但是如果需要获取结果，还需要添加另外一个方法参数，并且告诉spring使用哪个参数来进行结果接收 LogUtil.java 123456@AfterReturning(value = &quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;,returning = &quot;result&quot;)public static void stop(JoinPoint joinPoint,Object result)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法执行完成，结果是：&quot;+result);&#125; ​ 也可以通过相同的方式来获取异常的信息 LogUtil.java 12345@AfterThrowing(value = &quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;,throwing = &quot;exception&quot;)public static void logException(JoinPoint joinPoint,Exception exception)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法出现异常：&quot;+exception);&#125; ☀4、spring对通过方法的要求 ​ spring对于通知方法的要求并不是很高，你可以任意改变方法的返回值和方法的访问修饰符，但是唯一不能修改的就是方法的参数，会出现参数绑定的错误，原因在于通知方法是spring利用反射调用的，每次方法调用得确定这个方法的参数的值。 LogUtil.java 1234567 @After(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) private int end(JoinPoint joinPoint,String aa)&#123;// System.out.println(method.getName()+&quot;方法执行结束了......&quot;); String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法执行结束了......&quot;); return 0; &#125; ☀5、表达式的抽取 如果在实际使用过程中，多个方法的表达式是一致的话，那么可以考虑将切入点表达式抽取出来： ​ a、随便生命一个没有实现的返回void的空方法 ​ b、给方法上标注@Potintcut注解 123456789101112131415161718192021222324252627282930313233343536373839404142package com.mashibing.util;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspectpublic class LogUtil &#123; @Pointcut(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public void myPoint()&#123;&#125; @Before(&quot;myPoint()&quot;) public static void start(JoinPoint joinPoint)&#123; Object[] args = joinPoint.getArgs(); String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(args)); &#125; @AfterReturning(value = &quot;myPoint()&quot;,returning = &quot;result&quot;) public static void stop(JoinPoint joinPoint,Object result)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法执行完成，结果是：&quot;+result); &#125; @AfterThrowing(value = &quot;myPoint()&quot;,throwing = &quot;exception&quot;) public static void logException(JoinPoint joinPoint,Exception exception)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法出现异常：&quot;+exception.getMessage()); &#125; @After(&quot;myPoint()&quot;) private int end(JoinPoint joinPoint)&#123; String name = joinPoint.getSignature().getName(); System.out.println(name+&quot;方法执行结束了......&quot;); return 0; &#125;&#125; ☀6、环绕通知的使用 LogUtil.java 1234567891011121314151617181920212223242526272829303132333435363738package com.mashibing.util;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspectpublic class LogUtil &#123; @Pointcut(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public void myPoint()&#123;&#125; /** * 环绕通知是spring中功能最强大的通知 * @param proceedingJoinPoint * @return */ @Around(&quot;myPoint()&quot;) public Object myAround(ProceedingJoinPoint proceedingJoinPoint)&#123; Object[] args = proceedingJoinPoint.getArgs(); String name = proceedingJoinPoint.getSignature().getName(); Object proceed = null; try &#123; System.out.println(&quot;环绕前置通知:&quot;+name+&quot;方法开始，参数是&quot;+Arrays.asList(args)); //利用反射调用目标方法，就是method.invoke() proceed = proceedingJoinPoint.proceed(args); System.out.println(&quot;环绕返回通知:&quot;+name+&quot;方法返回，返回值是&quot;+proceed); &#125; catch (Throwable e) &#123; System.out.println(&quot;环绕异常通知&quot;+name+&quot;方法出现异常，异常信息是：&quot;+e); &#125;finally &#123; System.out.println(&quot;环绕后置通知&quot;+name+&quot;方法结束&quot;); &#125; return proceed; &#125;&#125; ​ 总结：环绕通知的执行顺序是优于普通通知的，具体的执行顺序如下： 环绕前置–&gt;普通前置–&gt;目标方法执行–&gt;环绕正常结束/出现异常–&gt;环绕后置–&gt;普通后置–&gt;普通返回或者异常。 但是需要注意的是，如果出现了异常，那么环绕通知会处理或者捕获异常，普通异常通知是接收不到的，因此最好的方式是在环绕异常通知中向外抛出异常。 ☀7、多切面运行的顺序 ​ 如果有多个切面要进行执行，那么顺序是什么样的呢？ LogUtil.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.mashibing.util;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspectpublic class LogUtil &#123; @Pointcut(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public void myPoint()&#123;&#125; @Before(&quot;myPoint()&quot;) public static void start(JoinPoint joinPoint)&#123;// System.out.println(&quot;XXX方法开始执行，使用的参数是：&quot;+ Arrays.asList(objects));// System.out.println(method.getName()+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(objects)); Object[] args = joinPoint.getArgs(); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(args)); &#125; @AfterReturning(value = &quot;myPoint()&quot;,returning = &quot;result&quot;) public static void stop(JoinPoint joinPoint,Object result)&#123;// System.out.println(&quot;XXX方法执行结束，结果是：&quot;+ Arrays.asList(objects));// System.out.println(method.getName()+&quot;方法执行结束，结果是：&quot;+ Arrays.asList(objects)); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法执行完成，结果是：&quot;+result); &#125; @AfterThrowing(value = &quot;myPoint()&quot;,throwing = &quot;exception&quot;) public static void logException(JoinPoint joinPoint,Exception exception)&#123;// System.out.println(method.getName()+&quot;方法出现异常：&quot;+ e.getMessage()); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法出现异常：&quot;+exception.getMessage()); &#125; @After(&quot;myPoint()&quot;) private int end(JoinPoint joinPoint)&#123;// System.out.println(method.getName()+&quot;方法执行结束了......&quot;); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法执行结束了......&quot;); return 0; &#125; /** * 环绕通知是spring中功能最强大的通知 * @param proceedingJoinPoint * @return */ //@Around(&quot;myPoint()&quot;) public Object myAround(ProceedingJoinPoint proceedingJoinPoint)&#123; Object[] args = proceedingJoinPoint.getArgs(); String name = proceedingJoinPoint.getSignature().getName(); Object proceed = null; try &#123; System.out.println(&quot;环绕前置通知:&quot;+name+&quot;方法开始，参数是&quot;+Arrays.asList(args)); //利用反射调用目标方法，就是method.invoke() proceed = proceedingJoinPoint.proceed(args); System.out.println(&quot;环绕返回通知:&quot;+name+&quot;方法返回，返回值是&quot;+proceed); &#125; catch (Throwable e) &#123; System.out.println(&quot;环绕异常通知&quot;+name+&quot;方法出现异常，异常信息是：&quot;+e); &#125;finally &#123; System.out.println(&quot;环绕后置通知&quot;+name+&quot;方法结束&quot;); &#125; return proceed; &#125;&#125; SecurityAspect.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.mashibing.util;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspectpublic class SecurityAspect &#123; @Before(&quot;com.mashibing.util.LogUtil.myPoint()&quot;) public static void start(JoinPoint joinPoint)&#123; Object[] args = joinPoint.getArgs(); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(args)); &#125; @AfterReturning(value = &quot;com.mashibing.util.LogUtil.myPoint()&quot;,returning = &quot;result&quot;) public static void stop(JoinPoint joinPoint,Object result)&#123; String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法执行完成，结果是：&quot;+result); &#125; @AfterThrowing(value = &quot;com.mashibing.util.LogUtil.myPoint()&quot;,throwing = &quot;exception&quot;) public static void logException(JoinPoint joinPoint,Exception exception)&#123; String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法出现异常：&quot;+exception.getMessage()); &#125; @After(&quot;com.mashibing.util.LogUtil.myPoint()&quot;) private int end(JoinPoint joinPoint)&#123; String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法执行结束了......&quot;); return 0; &#125; /** * 环绕通知是spring中功能最强大的通知 * @param proceedingJoinPoint * @return */ //@Around(&quot;myPoint()&quot;) public Object myAround(ProceedingJoinPoint proceedingJoinPoint)&#123; Object[] args = proceedingJoinPoint.getArgs(); String name = proceedingJoinPoint.getSignature().getName(); Object proceed = null; try &#123; System.out.println(&quot;环绕前置通知:&quot;+name+&quot;方法开始，参数是&quot;+Arrays.asList(args)); //利用反射调用目标方法，就是method.invoke() proceed = proceedingJoinPoint.proceed(args); System.out.println(&quot;环绕返回通知:&quot;+name+&quot;方法返回，返回值是&quot;+proceed); &#125; catch (Throwable e) &#123; System.out.println(&quot;环绕异常通知&quot;+name+&quot;方法出现异常，异常信息是：&quot;+e); &#125;finally &#123; System.out.println(&quot;环绕后置通知&quot;+name+&quot;方法结束&quot;); &#125; return proceed; &#125;&#125; ​ 在spring中，默认是按照切面名称的字典顺序进行执行的，但是如果想自己改变具体的执行顺序的话，可以使用@Order注解来解决，数值越小，优先级越高。 LogUtil.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.mashibing.util;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspect@Order(2)public class LogUtil &#123; @Pointcut(&quot;execution( public int com.mashibing.inter.MyCalculator.*(int,int))&quot;) public void myPoint()&#123;&#125; @Before(&quot;myPoint()&quot;) public static void start(JoinPoint joinPoint)&#123;// System.out.println(&quot;XXX方法开始执行，使用的参数是：&quot;+ Arrays.asList(objects));// System.out.println(method.getName()+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(objects)); Object[] args = joinPoint.getArgs(); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(args)); &#125; @AfterReturning(value = &quot;myPoint()&quot;,returning = &quot;result&quot;) public static void stop(JoinPoint joinPoint,Object result)&#123;// System.out.println(&quot;XXX方法执行结束，结果是：&quot;+ Arrays.asList(objects));// System.out.println(method.getName()+&quot;方法执行结束，结果是：&quot;+ Arrays.asList(objects)); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法执行完成，结果是：&quot;+result); &#125; @AfterThrowing(value = &quot;myPoint()&quot;,throwing = &quot;exception&quot;) public static void logException(JoinPoint joinPoint,Exception exception)&#123;// System.out.println(method.getName()+&quot;方法出现异常：&quot;+ e.getMessage()); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法出现异常：&quot;+exception.getMessage()); &#125; @After(&quot;myPoint()&quot;) private int end(JoinPoint joinPoint)&#123;// System.out.println(method.getName()+&quot;方法执行结束了......&quot;); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Log:&quot;+name+&quot;方法执行结束了......&quot;); return 0; &#125; /** * 环绕通知是spring中功能最强大的通知 * @param proceedingJoinPoint * @return */ //@Around(&quot;myPoint()&quot;) public Object myAround(ProceedingJoinPoint proceedingJoinPoint)&#123; Object[] args = proceedingJoinPoint.getArgs(); String name = proceedingJoinPoint.getSignature().getName(); Object proceed = null; try &#123; System.out.println(&quot;环绕前置通知:&quot;+name+&quot;方法开始，参数是&quot;+Arrays.asList(args)); //利用反射调用目标方法，就是method.invoke() proceed = proceedingJoinPoint.proceed(args); System.out.println(&quot;环绕返回通知:&quot;+name+&quot;方法返回，返回值是&quot;+proceed); &#125; catch (Throwable e) &#123; System.out.println(&quot;环绕异常通知&quot;+name+&quot;方法出现异常，异常信息是：&quot;+e); &#125;finally &#123; System.out.println(&quot;环绕后置通知&quot;+name+&quot;方法结束&quot;); &#125; return proceed; &#125;&#125; SecurityAspect.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.mashibing.util;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;@Component@Aspect@Order(1)public class SecurityAspect &#123; @Before(&quot;com.mashibing.util.LogUtil.myPoint()&quot;) public static void start(JoinPoint joinPoint)&#123; Object[] args = joinPoint.getArgs(); String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法开始执行，参数是：&quot;+ Arrays.asList(args)); &#125; @AfterReturning(value = &quot;com.mashibing.util.LogUtil.myPoint()&quot;,returning = &quot;result&quot;) public static void stop(JoinPoint joinPoint,Object result)&#123; String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法执行完成，结果是：&quot;+result); &#125; @AfterThrowing(value = &quot;com.mashibing.util.LogUtil.myPoint()&quot;,throwing = &quot;exception&quot;) public static void logException(JoinPoint joinPoint,Exception exception)&#123; String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法出现异常：&quot;+exception.getMessage()); &#125; @After(&quot;com.mashibing.util.LogUtil.myPoint()&quot;) private int end(JoinPoint joinPoint)&#123; String name = joinPoint.getSignature().getName(); System.out.println(&quot;Security:&quot;+name+&quot;方法执行结束了......&quot;); return 0; &#125; /** * 环绕通知是spring中功能最强大的通知 * @param proceedingJoinPoint * @return */ //@Around(&quot;myPoint()&quot;) public Object myAround(ProceedingJoinPoint proceedingJoinPoint)&#123; Object[] args = proceedingJoinPoint.getArgs(); String name = proceedingJoinPoint.getSignature().getName(); Object proceed = null; try &#123; System.out.println(&quot;环绕前置通知:&quot;+name+&quot;方法开始，参数是&quot;+Arrays.asList(args)); //利用反射调用目标方法，就是method.invoke() proceed = proceedingJoinPoint.proceed(args); System.out.println(&quot;环绕返回通知:&quot;+name+&quot;方法返回，返回值是&quot;+proceed); &#125; catch (Throwable e) &#123; System.out.println(&quot;环绕异常通知&quot;+name+&quot;方法出现异常，异常信息是：&quot;+e); &#125;finally &#123; System.out.println(&quot;环绕后置通知&quot;+name+&quot;方法结束&quot;); &#125; return proceed; &#125;&#125; ​ 如果需要添加环绕通知呢，具体的执行顺序又会是什么顺序呢？ ​ 因为环绕通知在进行添加的时候，是在切面层引入的，所以在哪个切面添加环绕通知，那么就会在哪个切面执行。 ☀3.基于配置的AOP配置 ​ 之前我们讲解了基于注解的AOP配置方式，下面我们开始讲一下基于xml的配置方式，虽然在现在的企业级开发中使用注解的方式比较多，但是你不能不会，因此需要简单的进行配置，注解配置快速简单，配置的方式共呢个完善。 1、将所有的注解都进行删除 2、添加配置文件 aop.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;bean id=&quot;logUtil&quot; class=&quot;com.mashibing.util.LogUtil2&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;securityAspect&quot; class=&quot;com.mashibing.util.SecurityAspect&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;myCalculator&quot; class=&quot;com.mashibing.inter.MyCalculator&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;globalPoint&quot; expression=&quot;execution(public int com.mashibing.inter.MyCalculator.*(int,int))&quot;/&gt; &lt;aop:aspect ref=&quot;logUtil&quot;&gt; &lt;aop:pointcut id=&quot;mypoint&quot; expression=&quot;execution(public int com.mashibing.inter.MyCalculator.*(int,int))&quot;/&gt; &lt;aop:before method=&quot;start&quot; pointcut-ref=&quot;mypoint&quot;&gt;&lt;/aop:before&gt; &lt;aop:after method=&quot;end&quot; pointcut-ref=&quot;mypoint&quot;&gt;&lt;/aop:after&gt; &lt;aop:after-returning method=&quot;stop&quot; pointcut-ref=&quot;mypoint&quot; returning=&quot;result&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;logException&quot; pointcut-ref=&quot;mypoint&quot; throwing=&quot;exception&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:around method=&quot;myAround&quot; pointcut-ref=&quot;mypoint&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;securityAspect&quot;&gt; &lt;aop:before method=&quot;start&quot; pointcut-ref=&quot;globalPoint&quot;&gt;&lt;/aop:before&gt; &lt;aop:after method=&quot;end&quot; pointcut-ref=&quot;globalPoint&quot;&gt;&lt;/aop:after&gt; &lt;aop:after-returning method=&quot;stop&quot; pointcut-ref=&quot;globalPoint&quot; returning=&quot;result&quot;&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=&quot;logException&quot; pointcut-ref=&quot;globalPoint&quot; throwing=&quot;exception&quot;&gt;&lt;/aop:after-throwing&gt; &lt;aop:around method=&quot;myAround&quot; pointcut-ref=&quot;mypoint&quot;&gt;&lt;/aop:around&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://aner1001.gitee.io/tags/Spring/"}]},{"title":"Spring学习笔记-IOC注解","slug":"技术知识/Java/框架/Spring/Spring学习笔记-IOC注解","date":"2021-02-25T08:11:44.000Z","updated":"2021-02-25T08:11:44.000Z","comments":true,"path":"posts/2021/02/25/024c1ad1f288/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/25/024c1ad1f288/","excerpt":"我们都是通过xml文件进行bean或者某些属性的赋值，其实还有另外一种注解的方式，在企业开发中使用的很多，在bean上添加注解，可以快速的将bean注册到ioc容器。","text":"我们都是通过xml文件进行bean或者某些属性的赋值，其实还有另外一种注解的方式，在企业开发中使用的很多，在bean上添加注解，可以快速的将bean注册到ioc容器。 ☀1.使用注解的方式注册bean到IOC容器中 applicationContext.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 如果想要将自定义的bean对象添加到IOC容器中，需要在类上添加某些注解 Spring中包含4个主要的组件添加注解： @Controller:控制器，推荐给controller层添加此注解 @Service:业务逻辑，推荐给业务逻辑层添加此注解 @Repository:仓库管理，推荐给数据访问层添加此注解 @Component:给不属于以上基层的组件添加此注解 注意：我们虽然人为的给不同的层添加不同的注解，但是在spring看来，可以在任意层添加任意注解 spring底层是不会给具体的层次验证注解，这样写的目的只是为了提高可读性，最偷懒的方式 就是给所有想交由IOC容器管理的bean对象添加component注解 使用注解需要如下步骤： 1、添加上述四个注解中的任意一个 2、添加自动扫描注解的组件，此操作需要依赖context命名空间 3、添加自动扫描的标签context:component-scan 注意：当使用注解注册组件和使用配置文件注册组件是一样的，但是要注意： 1、组件的id默认就是组件的类名首字符小写，如果非要改名字的话，直接在注解中添加即可 2、组件默认情况下都是单例的,如果需要配置多例模式的话，可以在注解下添加@Scope注解 --&gt; &lt;!-- 定义自动扫描的基础包: base-package:指定扫描的基础包，spring在启动的时候会将基础包及子包下所有加了注解的类都自动 扫描进IOC容器 --&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot;&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; PersonController.java 12345678910package com.mashibing.controller;import org.springframework.stereotype.Controller;@Controllerpublic class PersonController &#123; public PersonController() &#123; System.out.println(&quot;创建对象&quot;); &#125;&#125; PersonService.java 1234567package com.mashibing.service;import org.springframework.stereotype.Service;@Servicepublic class PersonService &#123;&#125; PersonDao.java 12345678package com.mashibing.dao;import org.springframework.stereotype.Repository;@Repository(&quot;personDao&quot;)@Scope(value=&quot;prototype&quot;)public class PersonDao &#123;&#125; ☀2.定义扫描包时要包含的类和不要包含的类 ​ 当定义好基础的扫描包后，在某些情况下可能要有选择性的配置是否要注册bean到IOC容器中，此时可以通过如下的方式进行配置。 applicationContext.xml 123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.mashibing&quot; use-default-filters=&quot;false&quot;&gt; &lt;!-- 当定义好基础扫描的包之后，可以排除包中的某些类，使用如下的方式: type:表示指定过滤的规则 annotation：按照注解进行排除，标注了指定注解的组件不要,expression表示要过滤的注解 assignable：指定排除某个具体的类，按照类排除，expression表示不注册的具体类名 aspectj：后面讲aop的时候说明要使用的aspectj表达式，不用 custom：定义一个typeFilter,自己写代码决定哪些类被过滤掉，不用 regex：使用正则表达式过滤，不用 --&gt;&lt;!-- &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;--&gt; &lt;!--指定只扫描哪些组件，默认情况下是全部扫描的，所以此时要配置的话需要在component-scan标签中添加 use-default-filters=&quot;false&quot;--&gt; &lt;context:include-filter type=&quot;assignable&quot; expression=&quot;com.mashibing.service.PersonService&quot;/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; ☀3.使用@AutoWired进行自动注入 使用注解的方式实现自动注入需要使用@AutoWired注解。 PersonController.java 1234567891011121314151617181920package com.mashibing.controller;import com.mashibing.service.PersonService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class PersonController &#123; @Autowired private PersonService personService; public PersonController() &#123; System.out.println(&quot;创建对象&quot;); &#125; public void getPerson()&#123; personService.getPerson(); &#125;&#125; PersonService.java 12345678910111213141516package com.mashibing.service;import com.mashibing.dao.PersonDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class PersonService &#123; @Autowired private PersonDao personDao; public void getPerson()&#123; personDao.getPerson(); &#125;&#125; PersonDao.java 1234567891011package com.mashibing.dao; import org.springframework.stereotype.Repository;@Repositorypublic class PersonDao &#123; public void getPerson()&#123; System.out.println(&quot;PersonDao:getPerson&quot;); &#125;&#125; 注意：当使用AutoWired注解的时候，自动装配的时候是根据类型实现的。 ​ 1、如果只找到一个，则直接进行赋值， ​ 2、如果没有找到，则直接抛出异常， ​ 3、如果找到多个，那么会按照变量名作为id继续匹配, ​ 1、匹配上直接进行装配 ​ 2、如果匹配不上则直接报异常 PersonServiceExt.java 1234567891011121314151617package com.mashibing.service;import com.mashibing.dao.PersonDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class PersonServiceExt extends PersonService&#123; @Autowired private PersonDao personDao; public void getPerson()&#123; System.out.println(&quot;PersonServiceExt......&quot;); personDao.getPerson(); &#125;&#125; PersonController.java 1234567891011121314151617181920package com.mashibing.controller;import com.mashibing.service.PersonService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;@Controllerpublic class PersonController &#123; @Autowired private PersonService personServiceExt; public PersonController() &#123; System.out.println(&quot;创建对象&quot;); &#125; public void getPerson()&#123; personServiceExt.getPerson(); &#125;&#125; ​ 还可以使用@Qualifier注解来指定id的名称，让spring不要使用变量名,当使用@Qualifier注解的时候也会有两种情况： ​ 1、找到，则直接装配 ​ 2、找不到，就会报错 PersonController.java 12345678910111213141516171819202122package com.mashibing.controller;import com.mashibing.service.PersonService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;@Controllerpublic class PersonController &#123; @Autowired @Qualifier(&quot;personService&quot;) private PersonService personServiceExt2; public PersonController() &#123; System.out.println(&quot;创建对象&quot;); &#125; public void getPerson()&#123; personServiceExt2.getPerson(); &#125;&#125; ​ 通过上述的代码我们能够发现，使用@AutoWired肯定是能够装配上的，如果装配不上就会报错。 ☀4.@AutoWired可以进行定义在方法上 ​ 当我们查看@AutoWired注解的源码的时候发现，此注解不仅可以使用在成员变量上，也可以使用在方法上。 PersonController.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.mashibing.controller;import com.mashibing.dao.PersonDao;import com.mashibing.service.PersonService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;@Controllerpublic class PersonController &#123; @Qualifier(&quot;personService&quot;) @Autowired private PersonService personServiceExt2; public PersonController() &#123; System.out.println(&quot;创建对象&quot;); &#125; public void getPerson()&#123; System.out.println(&quot;personController...&quot;+personServiceExt2);// personServiceExt2.getPerson(); &#125; /** * 当方法上有@AutoWired注解时： * 1、此方法在bean创建的时候会自动调用 * 2、这个方法的每一个参数都会自动注入值 * @param personDao */ @Autowired public void test(PersonDao personDao)&#123; System.out.println(&quot;此方法被调用:&quot;+personDao); &#125; /** * @Qualifier注解也可以作用在属性上，用来被当作id去匹配容器中的对象，如果没有 * 此注解，那么直接按照类型进行匹配 * @param personService */ @Autowired public void test2(@Qualifier(&quot;personServiceExt&quot;) PersonService personService)&#123; System.out.println(&quot;此方法被调用：&quot;+personService); &#125;&#125; ☀5.自动装配的注解@AutoWired，@Resource ​ 在使用自动装配的时候，出了可以使用@AutoWired注解之外，还可以使用@Resource注解，大家需要知道这两个注解的区别。 ​ 1、@AutoWired:是spring中提供的注解，@Resource:是jdk中定义的注解，依靠的是java的标准 ​ 2、@AutoWired默认是按照类型进行装配，默认情况下要求依赖的对象必须存在，@Resource默认是按照名字进行匹配的，同时可以指定name属性。 ​ 3、@AutoWired只适合spring框架，而@Resource扩展性更好 PersonController.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mashibing.controller;import com.mashibing.dao.PersonDao;import com.mashibing.service.PersonService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Controllerpublic class PersonController &#123; @Qualifier(&quot;personService&quot;) @Resource private PersonService personServiceExt2; public PersonController() &#123; System.out.println(&quot;创建对象&quot;); &#125; public void getPerson()&#123; System.out.println(&quot;personController...&quot;+personServiceExt2); personServiceExt2.getPerson(); &#125; /** * 当方法上有@AutoWired注解时： * 1、此方法在bean创建的时候会自动调用 * 2、这个方法的每一个参数都会自动注入值 * @param personDao */ @Autowired public void test(PersonDao personDao)&#123; System.out.println(&quot;此方法被调用:&quot;+personDao); &#125; /** * @Qualifier注解也可以作用在属性上，用来被当作id去匹配容器中的对象，如果没有 * 此注解，那么直接按照类型进行匹配 * @param personService */ @Autowired public void test2(@Qualifier(&quot;personServiceExt&quot;) PersonService personService)&#123; System.out.println(&quot;此方法被调用：&quot;+personService); &#125;&#125; ☀6.泛型依赖注入 ​ 为了讲解泛型依赖注入，首先我们需要先写一个基本的案例，按照我们之前学习的知识： Student.java 1234package com.mashibing.bean;public class Student &#123;&#125; Teacher.java 1234package com.mashibing.bean;public class Teacher &#123;&#125; BaseDao.java 123456789package com.mashibing.dao;import org.springframework.stereotype.Repository;@Repositorypublic abstract class BaseDao&lt;T&gt; &#123; public abstract void save();&#125; StudentDao.java 1234567891011package com.mashibing.dao;import com.mashibing.bean.Student;import org.springframework.stereotype.Repository;@Repositorypublic class StudentDao extends BaseDao&lt;Student&gt;&#123; public void save() &#123; System.out.println(&quot;保存学生&quot;); &#125;&#125; TeacherDao.java 1234567891011package com.mashibing.dao;import com.mashibing.bean.Teacher;import org.springframework.stereotype.Repository;@Repositorypublic class TeacherDao extends BaseDao&lt;Teacher&gt; &#123; public void save() &#123; System.out.println(&quot;保存老师&quot;); &#125;&#125; StudentService.java 12345678910111213141516package com.mashibing.service;import com.mashibing.dao.StudentDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class StudentService &#123; @Autowired private StudentDao studentDao; public void save()&#123; studentDao.save(); &#125;&#125; TeacherService.java 123456789101112131415package com.mashibing.service;import com.mashibing.dao.TeacherDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class TeacherService &#123; @Autowired private TeacherDao teacherDao; public void save()&#123; teacherDao.save(); &#125;&#125; MyTest.java 123456789101112131415161718import com.mashibing.service.StudentService;import com.mashibing.service.TeacherService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import javax.sql.DataSource;import java.sql.SQLException;public class MyTest &#123; public static void main(String[] args) throws SQLException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); StudentService studentService = context.getBean(&quot;studentService&quot;,StudentService.class); studentService.save(); TeacherService teacherService = context.getBean(&quot;teacherService&quot;,TeacherService.class); teacherService.save(); &#125;&#125; ​ 上述代码是我们之前的可以完成的功能，但是可以思考，Service层的代码是否能够改写： BaseService.java 12345678910111213141516package com.mashibing.service;import com.mashibing.dao.BaseDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;public class BaseService&lt;T&gt; &#123; @Autowired BaseDao&lt;T&gt; baseDao; public void save()&#123; System.out.println(&quot;自动注入的对象：&quot;+baseDao); baseDao.save(); &#125;&#125; StudentService.java 1234567891011package com.mashibing.service;import com.mashibing.bean.Student;import com.mashibing.dao.StudentDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class StudentService extends BaseService&lt;Student&gt; &#123;&#125; TeacherService.java 1234567891011package com.mashibing.service;import com.mashibing.bean.Teacher;import com.mashibing.dao.TeacherDao;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class TeacherService extends BaseService&lt;Teacher&gt;&#123;&#125;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://aner1001.gitee.io/tags/Spring/"}]},{"title":"Spring学习笔记-IOC配置","slug":"技术知识/Java/框架/Spring/Spring学习笔记-IOC配置","date":"2021-02-25T07:26:53.000Z","updated":"2021-02-25T07:26:53.000Z","comments":true,"path":"posts/2021/02/25/9cb0a8c2857f/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/25/9cb0a8c2857f/","excerpt":"如何使用IOC容器，体会spring的优势。","text":"如何使用IOC容器，体会spring的优势。 ☀1.spring_helloworld ☀(1)使用手动加载jar包的方式实现，分为三个步骤，现在几乎不用 导包：导入这五个包即可 commons-logging-1.2.jar spring-beans-5.2.3.RELEASE.jar spring-context-5.2.3.RELEASE.jar spring-core-5.2.3.RELEASE.jar spring-expression-5.2.3.RELEASE.jar 写配置 Person.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.mashibing.bean;public class Person &#123; private int id; private String name; private int age; private String gender; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ioc.xml 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--注册一个对象，spring回自动创建这个对象--&gt; &lt;!-- 一个bean标签就表示一个对象 id:这个对象的唯一标识 class:注册对象的完全限定名 --&gt; &lt;bean id=&quot;person&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;!--使用property标签给对象的属性赋值 name:表示属性的名称 value：表示属性的值 --&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 SpringDemoTest.java 12345678910111213141516package com.mashibing.test;import com.mashibing.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class SpringDemoTest &#123; public static void main(String[] args) &#123; //ApplicationContext:表示ioc容器 //ClassPathXmlApplicationContext:表示从当前classpath路径中获取xml文件的配置 //根据spring的配置文件来获取ioc容器对象 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;); Person person = (Person) context.getBean(&quot;person&quot;); System.out.println(person); &#125;&#125; ☀(2)使用maven的方式来构建项目 创建maven项目 定义项目的groupId.artifactId 添加对应的pom依赖 pom.xml 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.mashibing&lt;/groupId&gt; &lt;artifactId&gt;spring_demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.3.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写代码 Person.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.mashibing.bean;public class Person &#123; private int id; private String name; private int age; private String gender; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 测试 MyTest.java 1234567891011import com.mashibing.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;); Person person = (Person) context.getBean(&quot;person&quot;); System.out.println(person); &#125;&#125; 总结： 以上两种方式创建spring的项目都是可以的，但是在现在的企业开发环境中使用更多的还是maven这样的方式，无须自己处理jar之间的依赖关系，也无须提前下载jar包，只需要配置相关的pom即可，因此推荐大家使用maven的方式，具体的maven操作大家可以看maven的详细操作文档。 **搭建spring项目需要注意的点：** 1.一定要将配置文件添加到类路径中，使用idea创建项目的时候要放在resource目录下 2.导包的时候别忘了commons-logging-1.2.jar包 **细节点：** 1.ApplicationContext就是IOC容器的接口，可以通过此对象获取容器中创建的对象 2.对象在Spring容器创建完成的时候就已经创建完成，不是需要用的时候才创建 3.对象在IOC容器中存储的时候都是单例的，如果需要多例需要修改属性 4.创建对象给属性赋值的时候是通过setter方法实现的 5.对象的属性是由setter/getter方法决定的，而不是定义的成员属性 ☀2.spring对象的获取及属性赋值方式 ☀1.通过bean的id获取IOC容器中的对象（上面已经用过） ☀2.通过bean的类型获取对象 MyTest.java 1234567891011import com.mashibing.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;); Person bean = context.getBean(Person.class); System.out.println(bean); &#125;&#125; 注意：通过bean的类型在查找对象的时候，在配置文件中不能存在两个类型一致的bean对象，如果有的话，可以通过如下方法 MyTest.java 1234567891011import com.mashibing.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;); Person person = context.getBean(&quot;person&quot;, Person.class); System.out.println(person); &#125;&#125; ☀3.通过构造器给bean对象赋值 ioc.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!--给person类添加构造方法--&gt;&lt;bean id=&quot;person2&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;lisi&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;gender&quot; value=&quot;女&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!--在使用构造器赋值的时候可以省略name属性，但是此时就要求必须严格按照构造器参数的顺序来填写了--&gt;&lt;bean id=&quot;person3&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;lisi&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;20&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!--如果想不按照顺序来添加参数值，那么可以搭配index属性来使用--&gt; &lt;bean id=&quot;person4&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;constructor-arg value=&quot;lisi&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;1&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;女&quot; index=&quot;3&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;20&quot; index=&quot;2&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!--当有多个参数个数相同，不同类型的构造器的时候，可以通过type来强制类型--&gt;将person的age类型设置为Integer类型public Person(int id, String name, Integer age) &#123; this.id = id; this.name = name; this.age = age; System.out.println(&quot;Age&quot;); &#125; public Person(int id, String name, String gender) &#123; this.id = id; this.name = name; this.gender = gender; System.out.println(&quot;gender&quot;); &#125;&lt;bean id=&quot;person5&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;lisi&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;20&quot; type=&quot;java.lang.Integer&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;!--如果不修改为integer类型，那么需要type跟index组合使用--&gt; &lt;bean id=&quot;person5&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;constructor-arg value=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;lisi&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;20&quot; type=&quot;int&quot; index=&quot;2&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; ☀4.通过命名空间为bean赋值，简化配置文件中属性声明的写法 1.导入命名空间 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; 2.添加配置 1&lt;bean id=&quot;person6&quot; class=&quot;com.mashibing.bean.Person&quot; p:id=&quot;3&quot; p:name=&quot;wangwu&quot; p:age=&quot;22&quot; p:gender=&quot;男&quot;&gt;&lt;/bean&gt; ☀5.为复杂类型进行赋值操作 在之前的测试代码中，我们都是给最基本的属性进行赋值操作，在正常的企业级开发中还会遇到给各种复杂类型赋值，如集合.数组.其他对象等。 Person.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package com.mashibing.bean;import java.util.*;public class Person &#123; private int id; private String name=&quot;dahuang&quot;; private int age; private String gender; private Address address; private String[] hobbies; private List&lt;Book&gt; books; private Set&lt;Integer&gt; sets; private Map&lt;String,Object&gt; maps; private Properties properties; public Person(int id, String name, int age, String gender) &#123; this.id = id; this.name = name; this.age = age; this.gender = gender; System.out.println(&quot;有参构造器&quot;); &#125; public Person(int id, String name, int age) &#123; this.id = id; this.name = name; this.age = age; System.out.println(&quot;Age&quot;); &#125; public Person(int id, String name, String gender) &#123; this.id = id; this.name = name; this.gender = gender; System.out.println(&quot;gender&quot;); &#125; public Person() &#123; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getGender() &#123; return gender; &#125; public void setGender(String gender) &#123; this.gender = gender; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public List&lt;Book&gt; getBooks() &#123; return books; &#125; public void setBooks(List&lt;Book&gt; books) &#123; this.books = books; &#125; public Map&lt;String, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;String, Object&gt; maps) &#123; this.maps = maps; &#125; public Properties getProperties() &#123; return properties; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; public String[] getHobbies() &#123; return hobbies; &#125; public void setHobbies(String[] hobbies) &#123; this.hobbies = hobbies; &#125; public Set&lt;Integer&gt; getSets() &#123; return sets; &#125; public void setSets(Set&lt;Integer&gt; sets) &#123; this.sets = sets; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &quot;, gender=&#x27;&quot; + gender + &#x27;\\&#x27;&#x27; + &quot;, address=&quot; + address + &quot;, hobbies=&quot; + Arrays.toString(hobbies) + &quot;, books=&quot; + books + &quot;, sets=&quot; + sets + &quot;, maps=&quot; + maps + &quot;, properties=&quot; + properties + &#x27;&#125;&#x27;; &#125;&#125; Book.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.mashibing.bean;public class Book &#123; private String name; private String author; private double price; public Book() &#123; &#125; public Book(String name, String author, double price) &#123; this.name = name; this.author = author; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Book&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, author=&#x27;&quot; + author + &#x27;\\&#x27;&#x27; + &quot;, price=&quot; + price + &#x27;&#125;&#x27;; &#125;&#125; Address.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.mashibing.bean;public class Address &#123; private String province; private String city; private String town; public Address() &#123; &#125; public Address(String province, String city, String town) &#123; this.province = province; this.city = city; this.town = town; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getTown() &#123; return town; &#125; public void setTown(String town) &#123; this.town = town; &#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;province=&#x27;&quot; + province + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &quot;, town=&#x27;&quot; + town + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ioc.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd&quot;&gt; &lt;!--给复杂类型的赋值都在property标签内进行--&gt; &lt;bean id=&quot;person&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;property name=&quot;name&quot;&gt; &lt;!--赋空值--&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;!--通过ref引用其他对象，引用外部bean--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/property&gt; &lt;!--引用内部bean--&gt; &lt;!-- &lt;property name=&quot;address&quot;&gt; &lt;bean class=&quot;com.mashibing.bean.Address&quot;&gt; &lt;property name=&quot;province&quot; value=&quot;北京&quot;&gt;&lt;/property&gt; &lt;property name=&quot;city&quot; value=&quot;北京&quot;&gt;&lt;/property&gt; &lt;property name=&quot;town&quot; value=&quot;西城区&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt;--&gt; &lt;!--为list赋值--&gt; &lt;property name=&quot;books&quot;&gt; &lt;list&gt; &lt;!--内部bean--&gt; &lt;bean id=&quot;book1&quot; class=&quot;com.mashibing.bean.Book&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;多线程与高并发&quot;&gt;&lt;/property&gt; &lt;property name=&quot;author&quot; value=&quot;马士兵&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;1000&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--外部bean--&gt; &lt;ref bean=&quot;book2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--给map赋值--&gt; &lt;property name=&quot;maps&quot; ref=&quot;myMap&quot;&gt;&lt;/property&gt; &lt;!--给property赋值--&gt; &lt;property name=&quot;properties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;aaa&quot;&gt;aaa&lt;/prop&gt; &lt;prop key=&quot;bbb&quot;&gt;222&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!--给数组赋值--&gt; &lt;property name=&quot;hobbies&quot;&gt; &lt;array&gt; &lt;value&gt;book&lt;/value&gt; &lt;value&gt;movie&lt;/value&gt; &lt;value&gt;game&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--给set赋值--&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;111&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;value&gt;222&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;address&quot; class=&quot;com.mashibing.bean.Address&quot;&gt; &lt;property name=&quot;province&quot; value=&quot;河北&quot;&gt;&lt;/property&gt; &lt;property name=&quot;city&quot; value=&quot;邯郸&quot;&gt;&lt;/property&gt; &lt;property name=&quot;town&quot; value=&quot;武安&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;book2&quot; class=&quot;com.mashibing.bean.Book&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;JVM&quot;&gt;&lt;/property&gt; &lt;property name=&quot;author&quot; value=&quot;马士兵&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;1200&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--级联属性--&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address.province&quot; value=&quot;北京&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--util名称空间创建集合类型的bean--&gt; &lt;util:map id=&quot;myMap&quot;&gt; &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key2&quot; value-ref=&quot;book2&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;key03&quot;&gt; &lt;bean class=&quot;com.mashibing.bean.Book&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;西游记&quot; &gt;&lt;/property&gt; &lt;property name=&quot;author&quot; value=&quot;吴承恩&quot; &gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;100&quot; &gt;&lt;/property&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;/util:map&gt;&lt;/beans&gt; ☀6.继承关系bean的配置 ioc.xml 12345678910&lt;bean id=&quot;person&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--parent:指定bean的配置信息继承于哪个bean--&gt;&lt;bean id=&quot;person2&quot; class=&quot;com.mashibing.bean.Person&quot; parent=&quot;person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lisi&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 如果想实现Java文件的抽象类，不需要将当前bean实例化的话，可以使用abstract属性 12345678910&lt;bean id=&quot;person&quot; class=&quot;com.mashibing.bean.Person&quot; abstract=&quot;true&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--parent:指定bean的配置信息继承于哪个bean--&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.mashibing.bean.Person&quot; parent=&quot;person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;lisi&quot;&gt;&lt;/property&gt; &lt;/bean&gt; ☀7.bean对象创建的依赖关系 bean对象在创建的时候是按照bean在配置文件的顺序决定的，也可以使用depend-on标签来决定顺序 ioc.xml 123&lt;bean id=&quot;book&quot; class=&quot;com.mashibing.bean.Book&quot; depends-on=&quot;person,address&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;address&quot; class=&quot;com.mashibing.bean.Address&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;person&quot; class=&quot;com.mashibing.bean.Person&quot;&gt;&lt;/bean&gt; depend-on标签详细说明: spring的IOC容器负责bean的管理，当实例化一个bean是，spring保证该Bean所依赖的其他bean已经初始化。一般情况下，用元素建立对其他bean的依赖关系。 比如： 123&lt;bean id=&quot;a&quot; class=&quot;com.yanln.spring.bean.A&quot;&gt; &lt;/bean&gt;&lt;bean id=&quot;b&quot; class=&quot;com.yanln.spring.bean.B&quot; p:a-ref=&quot;a&quot;&gt; &lt;/bean&gt; 但在某些情况下，这种bean之间的依赖关系并不那么明显。 举个例子：某个论坛系统拥有很多系统参数（如会话过期时间.缓存更新时间等），这些系统参数用于控制系统的运行逻辑。比如： 123456789public class SystemSettings&#123; //缓存更新时间 public static int REFRESH_CYCLE = 60; ......&#125; 在SystemSettings中为每一个系统参数提供了默认值，但对于一个灵活的论坛是需要提供一个管理后台的，在管理后台中可以调整这些系统参数并保存到后台数据库中，而在系统启动时，初始化程序从数据库后台加载这些系统参数的值来覆盖系统默认值。比如： 12345678910111213public class SystemInit&#123; public SystemInit()&#123; //模拟从数据库中加载的系统参数配置值 SystemSettings.REFRESH_CYCLE=100; ...... &#125;&#125; 假设论坛系统有一个缓存刷新管理器，它需要根据系统参数SystemSettings.REFRESH_CYCLE创建缓存刷新定时任务 1234567891011121314151617public class CacheManager&#123; public CacheManager()&#123; Timer t = new Timer(); TimerTask cacheTask = new CacheTask(); //缓存刷新定时处理 t.schedule(cacheTask,0,SystemSettings.REFRESH_CYCLE); &#125; ......&#125; 在以上的实例中，CacheManager类需要用到SystemSetting类的值,而SystemSettings的值有SystemInit负责初始化，虽然CacheManager不直接依赖SystemInit，但从逻辑上看，CacheManager希望在SystemInit加载并完成系统参数设置后再启动，以获得最新的系统参数值。如果这三个bean都在spring配置文件中定义，我们如何保证SystemInit在CacheManager之前进行初始化呢？ *spring允许用户通过depends-on属性指定bean前置依赖的bean,前置依赖的bean会在本bean实例化之前创建好：* 123&lt;bean id=&quot;sysinit&quot; class=&quot;SystemInit&quot;&gt;&lt;bean id=&quot;manager&quot; class=&quot;CacheManager&quot; depends-on=&quot;sysinit&quot;/&gt; **如果前置依赖于多个 Bean，则可以通过分号，逗号或空格的方式配置 Bean 的名称。**** ☀8.bean的作用域控制，是否是单例 ioc.xml 1234567891011&lt;!--bean的作用域：singleton.prototype.request.session默认情况下是单例的prototype：多实例的 容器启动的时候不会创建多实例bean，只有在获取对象的时候才会创建该对象 每次创建都是一个新的对象singleton：默认的单例对象 在容器启动完成之前就已经创建好对象 获取的所有对象都是同一个--&gt;&lt;bean id=&quot;person4&quot; class=&quot;com.mashibing.bean.Person&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; ☀9.利用工厂模式创建bean对象 在之前的案例中，所有bean对象的创建都是通过反射得到对应的bean实例，其实在spring中还包含另外一种创建bean实例的方式，就是通过工厂模式进行对象的创建 在利用工厂模式创建bean实例的时候有两种方式，分别是静态工厂和实例工厂。 静态工厂：工厂本身不需要创建对象，但是可以通过静态方法调用，对象=工厂类.静态工厂方法名（）； 实例工厂：工厂本身需要创建对象，工厂类 工厂对象=new 工厂类；工厂对象.get对象名（）； PersonStaticFactory.java 12345678910111213package com.mashibing.factory;import com.mashibing.bean.Person;public class PersonStaticFactory &#123; public static Person getPerson(String name)&#123; Person person = new Person(); person.setId(1); person.setName(name); return person; &#125;&#125; ioc.xml 123456789&lt;!--静态工厂的使用：class:指定静态工厂类factory-method:指定哪个方法是工厂方法--&gt;&lt;bean id=&quot;person5&quot; class=&quot;com.mashibing.factory.PersonStaticFactory&quot; factory-method=&quot;getPerson&quot;&gt; &lt;!--constructor-arg：可以为方法指定参数--&gt; &lt;constructor-arg value=&quot;lisi&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; PersonInstanceFactory.java 12345678910111213package com.mashibing.factory;import com.mashibing.bean.Person;public class PersonInstanceFactory &#123; public Person getPerson(String name)&#123; Person person = new Person(); person.setId(1); person.setName(name); return person; &#125;&#125; ioc.xml 12345678910&lt;!--实例工厂使用--&gt;&lt;!--创建实例工厂类--&gt;&lt;bean id=&quot;personInstanceFactory&quot; class=&quot;com.mashibing.factory.PersonInstanceFactory&quot;&gt;&lt;/bean&gt;&lt;!--factory-bean:指定使用哪个工厂实例factory-method:指定使用哪个工厂实例的方法--&gt;&lt;bean id=&quot;person6&quot; class=&quot;com.mashibing.bean.Person&quot; factory-bean=&quot;personInstanceFactory&quot; factory-method=&quot;getPerson&quot;&gt; &lt;constructor-arg value=&quot;wangwu&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; ☀10.继承FactoryBean来创建对象 FactoryBean是Spring规定的一个接口，当前接口的实现类，Spring都会将其作为一个工厂，但是在ioc容器启动的时候不会创建实例，只有在使用的时候才会创建对象 MyFactoryBean.java 12345678910111213141516171819202122232425262728293031323334353637383940package com.mashibing.factory;import com.mashibing.bean.Person;import org.springframework.beans.factory.FactoryBean;/** * 实现了FactoryBean接口的类是Spring中可以识别的工厂类，spring会自动调用工厂方法创建实例 */public class MyFactoryBean implements FactoryBean&lt;Person&gt; &#123; /** * 工厂方法，返回需要创建的对象 * @return * @throws Exception */ @Override public Person getObject() throws Exception &#123; Person person = new Person(); person.setName(&quot;maliu&quot;); return person; &#125; /** * 返回创建对象的类型,spring会自动调用该方法返回对象的类型 * @return */ @Override public Class&lt;?&gt; getObjectType() &#123; return Person.class; &#125; /** * 创建的对象是否是单例对象 * @return */ @Override public boolean isSingleton() &#123; return false; &#125;&#125; ioc.xml 1&lt;bean id=&quot;myfactorybean&quot; class=&quot;com.mashibing.factory.MyFactoryBean&quot;&gt;&lt;/bean&gt; ☀11.bean对象的初始化和销毁方法 在创建对象的时候，我们可以根据需要调用初始化和销毁的方法 Address.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.mashibing.bean;public class Address &#123; private String province; private String city; private String town; public Address() &#123; System.out.println(&quot;address被创建了&quot;); &#125; public Address(String province, String city, String town) &#123; this.province = province; this.city = city; this.town = town; &#125; public String getProvince() &#123; return province; &#125; public void setProvince(String province) &#123; this.province = province; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getTown() &#123; return town; &#125; public void setTown(String town) &#123; this.town = town; &#125; public void init()&#123; System.out.println(&quot;对象被初始化&quot;); &#125; public void destory()&#123; System.out.println(&quot;对象被销毁&quot;); &#125; @Override public String toString() &#123; return &quot;Address&#123;&quot; + &quot;province=&#x27;&quot; + province + &#x27;\\&#x27;&#x27; + &quot;, city=&#x27;&quot; + city + &#x27;\\&#x27;&#x27; + &quot;, town=&#x27;&quot; + town + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; ioc.xml 12345&lt;!--bean生命周期表示bean的创建到销毁 如果bean是单例，容器在启动的时候会创建好，关闭的时候会销毁创建的bean 如果bean是多礼，获取的时候创建对象，销毁的时候不会有任何的调用 --&gt; &lt;bean id=&quot;address&quot; class=&quot;com.mashibing.bean.Address&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt;&lt;/bean&gt; MyTest.java 1234567891011121314import com.mashibing.bean.Address;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ioc2.xml&quot;); Address address = context.getBean(&quot;address&quot;, Address.class); System.out.println(address); //applicationContext没有close方法，需要使用具体的子类 ((ClassPathXmlApplicationContext)context).close(); &#125;&#125; ☀12.配置bean对象初始化方法的前后处理方法 spring中包含一个BeanPostProcessor的接口，可以在bean的初始化方法的前后调用该方法，如果配置了初始化方法的前置和后置处理器，无论是否包含初始化方法，都会进行调用 MyBeanPostProcessor.java 1234567891011121314151617181920212223242526272829303132package com.mashibing.bean;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class MyBeanPostProcessor implements BeanPostProcessor &#123; /** * 在初始化方法调用之前执行 * @param bean 初始化的bean对象 * @param beanName xml配置文件中的bean的id属性 * @return * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;postProcessBeforeInitialization:&quot;+beanName+&quot;调用初始化前置方法&quot;); return bean; &#125; /** * 在初始化方法调用之后执行 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;postProcessAfterInitialization:&quot;+beanName+&quot;调用初始化后缀方法&quot;); return bean; &#125;&#125; ioc.xml 1&lt;bean id=&quot;myBeanPostProcessor&quot; class=&quot;com.mashibing.bean.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt; ☀3.spring创建第三方bean对象 在Spring中，很多对象都是单实例的，在日常的开发中，我们经常需要使用某些外部的单实例对象，例如数据库连接池，下面我们来讲解下如何在spring中创建第三方bean实例。 1.导入数据库连接池的pom文件 123456789101112&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.21&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt; 2.编写配置文件 ioc.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/demo&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.编写测试文件 MyTest.java 123456789101112131415import com.alibaba.druid.pool.DruidDataSource;import com.mashibing.bean.Address;import com.mashibing.bean.Person;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.sql.SQLException;public class MyTest &#123; public static void main(String[] args) throws SQLException &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ioc3.xml&quot;); DruidDataSource dataSource = context.getBean(&quot;dataSource&quot;, DruidDataSource.class); System.out.println(dataSource); System.out.println(dataSource.getConnection()); &#125;&#125; ☀4.spring引用外部配置文件 在resource中添加dbconfig.properties 1234username=rootpassword=123456url=jdbc:mysql://localhost:3306/demodriverClassName=com.mysql.jdbc.Driver 编写配置文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--加载外部配置文件 在加载外部依赖文件的时候需要context命名空间 --&gt; &lt;context:property-placeholder location=&quot;classpath:dbconfig.properties&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driverClassName&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; ☀5.spring基于xml文件的自动装配 当一个对象中需要引用另外一个对象的时候，在之前的配置中我们都是通过property标签来进行手动配置的，其实在spring中还提供了一个非常强大的功能就是自动装配，可以按照我们指定的规则进行配置，配置的方式有以下几种： default/no：不自动装配 byName：按照名字进行装配，以属性名作为id去容器中查找组件，进行赋值，如果找不到则装配null byType：按照类型进行装配,以属性的类型作为查找依据去容器中找到这个组件，如果有多个类型相同的bean对象，那么会报异常，如果找不到则装配null constructor：按照构造器进行装配，先按照有参构造器参数的类型进行装配，没有就直接装配null；如果按照类型找到了多个，那么就使用参数名作为id继续匹配，找到就装配，找不到就装配null ioc.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.mashibing.bean.Address&quot;&gt; &lt;property name=&quot;province&quot; value=&quot;河北&quot;&gt;&lt;/property&gt; &lt;property name=&quot;city&quot; value=&quot;邯郸&quot;&gt;&lt;/property&gt; &lt;property name=&quot;town&quot; value=&quot;武安&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.mashibing.bean.Person&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;person2&quot; class=&quot;com.mashibing.bean.Person&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;person3&quot; class=&quot;com.mashibing.bean.Person&quot; autowire=&quot;constructor&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; ☀6.SpEL的使用 SpEL:Spring Expression Language,spring的表达式语言，支持运行时查询操作对象 使用#&#123;...&#125;作为语法规则，所有的大括号中的字符都认为是SpEL. ioc.xml 123456789101112&lt;bean id=&quot;person4&quot; class=&quot;com.mashibing.bean.Person&quot;&gt; &lt;!--支持任何运算符--&gt; &lt;property name=&quot;age&quot; value=&quot;#&#123;12*2&#125;&quot;&gt;&lt;/property&gt; &lt;!--可以引用其他bean的某个属性值--&gt; &lt;property name=&quot;name&quot; value=&quot;#&#123;address.province&#125;&quot;&gt;&lt;/property&gt; &lt;!--引用其他bean--&gt; &lt;property name=&quot;address&quot; value=&quot;#&#123;address&#125;&quot;&gt;&lt;/property&gt; &lt;!--调用静态方法--&gt; &lt;property name=&quot;hobbies&quot; value=&quot;#&#123;T(java.util.UUID).randomUUID().toString().substring(0,4)&#125;&quot;&gt;&lt;/property&gt; &lt;!--调用非静态方法--&gt; &lt;property name=&quot;gender&quot; value=&quot;#&#123;address.getCity()&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://aner1001.gitee.io/tags/Spring/"}]},{"title":"Spring学习笔记-基本介绍","slug":"技术知识/Java/框架/Spring/Spring学习笔记-基本介绍","date":"2021-02-25T07:13:14.000Z","updated":"2021-02-25T07:13:14.000Z","comments":true,"path":"posts/2021/02/25/426fd5e7199b/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/25/426fd5e7199b/","excerpt":"spring是一个开源框架。 ​spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。 ​spring是一个IOC和AOP的容器框架。","text":"spring是一个开源框架。 ​spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。 ​spring是一个IOC和AOP的容器框架。 ☀1、框架 ​ 框架就是一些类和接口的集合，通过这些类和接口协调来完成一系列的程序实现。JAVA框架可以分为三层：表示层，业务层和物理层。框架又叫做开发中的半成品，它不能提供整个WEB应用程序的所有东西，但是有了框架，我们就可以集中精力进行业务逻辑的开发而不用去关心它的技术实现以及一些辅助的业务逻辑。大家熟知的Structs和Spring就是表示层和业务层框架的强力代表。（说的太官方了） ​ 人话： ​ 框架就是某些个人或者组织定义了一系列的类或者接口，提前定义好了一些实现，用户可以在这些类和接口的基础之上，使用这些类来迅速的形成某个领域或者某个行业的解决方案，简化开发的过程，提高开发的效率。就好比：你要盖一座房子，先把柱子，房梁等先建设好，然后只需要向房子中填充就可以了，可以按照自己的需求进行设计，其实我们做的项目、系统都是类似的方式，如果所有的代码全部都需要自己实现，那么这个工程就太庞大了，所以可以先创建出一些基础的模板框架，开发人员只需要按照自己的需求向架子中填充内容，完成自己独特需求即可，这就是框架存在的意义。其实我们之前定义的简单的工具类这些东西也是类似的原理，只不过比较单一简单而已，因此，在现在的很多项目系统开发的过程中都是利用框架进行开发。 ☀2、spring（春天） 架构设计 ​ 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 ​ 单一应用架构 ​ 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。 ​ 垂直应用架构 ​ 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，提升效率的方法之一是将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 ​ 分布式服务架构 ​ 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 ​ 流动计算架构 ​ 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。 Java主流框架演变之路 ​ 1、JSP+Servlet+JavaBean ​ 2、MVC三层架构 ​ 3、使用EJB进行应用的开发，但是EJB是重量级框架（在使用的时候，过多的接口和依赖，侵入性强），在使用上比较麻烦 ​ 4、Struts1/Struts2+Hibernate+Spring ​ 5、SpringMVC+Mybatis+Spring ​ 6、SpringBoot开发，约定大于配置 Spring官网 官网地址：https://spring.io/projects/spring-framework#overview 压缩包下载地址：https://repo.spring.io/release/org/springframework/spring/ 源码地址：https://github.com/spring-projects/spring-framework Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application’s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release. Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be standalone applications (such as batch or integration workloads) that do not need a server. Spring is open source. It has a large and active community that provides continuous feedback based on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very long time. Spring 使创建 Java 企业应用程序变得更加容易。它提供了在企业环境中接受 Java 语言所需的一切,，并支持 Groovy 和 Kotlin 作为 JVM 上的替代语言，并可根据应用程序的需要灵活地创建多种体系结构。 从 Spring Framework 5.0 开始，Spring 需要 JDK 8(Java SE 8+)，并且已经为 JDK 9 提供了现成的支持。 Spring支持各种应用场景， 在大型企业中, 应用程序通常需要运行很长时间，而且必须运行在 jdk 和应用服务器上，这种场景开发人员无法控制其升级周期。 其他可能作为一个单独的jar嵌入到服务器去运行，也有可能在云环境中。还有一些可能是不需要服务器的独立应用程序(如批处理或集成的工作任务)。 Spring 是开源的。它拥有一个庞大而且活跃的社区，提供不同范围的，真实用户的持续反馈。这也帮助Spring不断地改进,不断发展。 核心解释 ​ spring是一个开源框架。 ​ spring是为了简化企业开发而生的，使得开发变得更加优雅和简洁。 ​ spring是一个IOC和AOP的容器框架。 ​ IOC：控制反转 ​ AOP：面向切面编程 ​ 容器：包含并管理应用对象的生命周期，就好比用桶装水一样，spring就是桶，而对象就是水 使用spring的优点 ​ 1、Spring通过DI、AOP和消除样板式代码来简化企业级Java开发 ​ 2、Spring框架之外还存在一个构建在核心框架之上的庞大生态圈，它将Spring扩展到不同的领域，如Web服务、REST、移动开发以及NoSQL ​ 3、低侵入式设计，代码的污染极低 ​ 4、独立于各种应用服务器，基于Spring框架的应用，可以真正实现Write Once,Run Anywhere的承诺 ​ 5、Spring的IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦 ​ 6、Spring的AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用 ​ 7、Spring的ORM和DAO提供了与第三方持久层框架的的良好整合，并简化了底层的数据库访问 ​ 8、Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部 如何简化开发 ​ 基于POJO的轻量级和最小侵入性编程 ​ 通过依赖注入和面向接口实现松耦合 ​ 基于切面和惯例进行声明式编程 ​ 通过切面和模板减少样板式代码 spring的模块划分图 12345678模块解释：Test:Spring的单元测试模块Core Container:核心容器模块AOP+Aspects:面向切面编程模块Instrumentation:提供了class instrumentation支持和类加载器的实现来在特定的应用服务器上使用,几乎不用Messaging:包括一系列的用来映射消息到方法的注解,几乎不用Data Access/Integration:数据的获取/整合模块，包括了JDBC,ORM,OXM,JMS和事务模块Web:提供面向web整合特性 ☀3、IOC（Inversion of Control）:控制反转 为什么要引入IOC 创建一个普通的java项目，完成下述功能 UserDao.java 12345package com.mashibing.dao;public interface UserDao &#123; public void getUser();&#125; UserDaoImpl.java 12345678910package com.mashibing.dao.impl;import com.mashibing.dao.UserDao;public class UserDaoImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;获取用户数据&quot;); &#125;&#125; UserService.java 123456package com.mashibing.service;public interface UserService &#123; public void getUser();&#125; UserServiceImpl.java 1234567891011121314151617package com.mashibing.service.impl;import com.mashibing.dao.UserDao;import com.mashibing.dao.impl.UserDaoImpl;import com.mashibing.dao.impl.UserDaoMysqlImpl;import com.mashibing.service.UserService;public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; SpringDemoTest.java 123456789101112package com.mashibing.test;import com.mashibing.service.UserService;import com.mashibing.service.impl.UserServiceImpl;public class SpringDemoTest &#123; public static void main(String[] args) &#123; UserService service = new UserServiceImpl(); service.getUser(); &#125;&#125; 在之前的代码编写过程中，我们都是这么完成我们的功能的，但是如果增加一个UserDao的实现类呢？ UserDaoMysqlImpl.java 12345678910package com.mashibing.dao.impl;import com.mashibing.dao.UserDao;public class UserDaoMysqlImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;mysql&quot;); &#125;&#125; 如果我们想要使用mysql的话，那么就必须要修改UserServiceImpl.java的代码： 1234567891011121314151617package com.mashibing.service.impl;import com.mashibing.dao.UserDao;import com.mashibing.dao.impl.UserDaoImpl;import com.mashibing.dao.impl.UserDaoMysqlImpl;import com.mashibing.service.UserService;public class UserServiceImpl implements UserService &#123; private UserDao userDao = new UserDaoImpl(); @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 但是如果我们再增加一个oracle的类呢？ UserDaoOracleImpl.java 12345678910package com.mashibing.dao.impl;import com.mashibing.dao.UserDao;public class UserDaoOracleImpl implements UserDao &#123; @Override public void getUser() &#123; System.out.println(&quot;oracle&quot;); &#125;&#125; 此时UserService还是要继续修改，很显然这样的方式已经不适用于我们的需求了，那么怎么解决呢，可以使用如下的方式 UserServiceImpl.java 123456789101112131415161718package com.mashibing.service.impl;import com.mashibing.dao.UserDao;import com.mashibing.dao.impl.UserDaoImpl;import com.mashibing.service.UserService;public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao)&#123; this.userDao = userDao; &#125; @Override public void getUser() &#123; userDao.getUser(); &#125;&#125; 测试类SpringDemoTest.java 1234567891011121314151617package com.mashibing.test;import com.mashibing.dao.impl.UserDaoMysqlImpl;import com.mashibing.dao.impl.UserDaoOracleImpl;import com.mashibing.service.UserService;import com.mashibing.service.impl.UserServiceImpl;public class SpringDemoTest &#123; public static void main(String[] args) &#123; UserServiceImpl userService = new UserServiceImpl(); userService.setUserDao(new UserDaoMysqlImpl()); userService.getUser(); userService.setUserDao(new UserDaoOracleImpl()); userService.getUser(); &#125;&#125; 其实从刚刚的代码中，大家应该能体会解耦的重要性了，下面我们就开始学习Spring的IOC。 IOC初始 ​ 想要搞明白IOC，那么需要搞清楚如下几个问题： 12341、谁控制谁2、控制什么3、什么是反转4、哪些方面被反转 基本概念 12IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern.IOC与大家熟知的依赖注入同理，. 这是一个通过依赖注入对象的过程 也就是说，它们所使用的对象，是通过构造函数参数，工厂方法的参数或这是从工厂方法的构造函数或返回值的对象实例设置的属性，然后容器在创建bean时注入这些需要的依赖。 这个过程相对普通创建对象的过程是反向的（因此称之为IoC），bean本身通过直接构造类来控制依赖关系的实例化或位置，或提供诸如服务定位器模式之类的机制。 如果这个过程比较难理解的话，那么可以想象自己找女朋友和婚介公司找女朋友的过程。如果这个过程能够想明白的话，那么我们现在回答上面的问题： 12341、谁控制谁：在之前的编码过程中，都是需要什么对象自己去创建什么对象，有程序员自己来控制对象，而有了IOC容器之后，就会变成由IOC容器来控制对象，2、控制什么：在实现过程中所需要的对象及需要依赖的对象3、什么是反转：在没有IOC容器之前我们都是在对象中主动去创建依赖的对象，这是正转的，而有了IOC之后，依赖的对象直接由IOC容器创建后注入到对象中，由主动创建变成了被动接受，这是反转.4、哪些方面被反转：依赖的对象 DI与IOC 1很多人把IOC和DI说成一个东西，笼统来说的话是没有问题的，但是本质上还是有所区别的,希望大家能够严谨一点，IOC和DI是从不同的角度描述的同一件事，IOC是从容器的角度描述，而DI是从应用程序的角度来描述，也可以这样说，IOC是设计思想，而DI是具体的实现方式 ☀4、总结 ​ 在此处总结中，希望大家能够能够明白两件事： ​ 1、解耦 ​ 在面向对象设计的软件系统中，底层的实现都是由N个对象组成的，所有的对象通过彼此的合作，最终实现系统的业务逻辑。 ​ 需要注意的是，在这样的组合关系中，一旦某一个对象出现了问题，那么其他对象肯定回有所影响，这就是耦合性太高的缘故，但是对象的耦合关系是无法避免的，也是必要的。随着应用程序越来越庞大，对象的耦合关系可能越来越复杂，经常需要多重依赖关系，因此，无论是架构师还是程序员，在面临这样的场景的时候，都需要减少这些对象的耦合性。 ​ 耦合的关系不仅仅是对象与对象之间，也会出现在软件系统的各个模块之间，是我们需要重点解决的问题。而为了解决对象之间的耦合度过高的问题，我们就可以通过IOC来实现对象之间的解耦，spring框架就是IOC理论最最广泛的应用。 ​ 从上图中可以看到，当引入了第三方的容器之后，几个对象之间就没有了耦合关系，全部对象都交由容器来控制，这个容器就相当于粘合剂，将系统的对象粘合在一起发挥作用。 ​ 2、生态 ​ 任何一个语言或者任何一个框架想要立于不败之地，那么很重要的就是它的生态。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://aner1001.gitee.io/tags/Spring/"}]},{"title":"Mysql多表和事务","slug":"技术知识/数据库/Mysql/Mysql多表和事务","date":"2021-02-24T23:04:01.000Z","updated":"2021-02-24T23:04:01.000Z","comments":true,"path":"posts/2021/02/24/12d58c006c24/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/24/12d58c006c24/","excerpt":"多表查询 事务 DCL","text":"多表查询 事务 DCL 学习链接 ☀多表查询： ☀查询语法： 12345select 列名列表from 表名列表where.... ☀准备sql 123456789101112131415161718192021# 创建部门表 CREATE TABLE dept( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20) ); INSERT INTO dept (NAME) VALUES (&#x27;开发部&#x27;),(&#x27;市场部&#x27;),(&#x27;财务部&#x27;); # 创建员工表 CREATE TABLE emp ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), gender CHAR(1), -- 性别 salary DOUBLE, -- 工资 join_date DATE, -- 入职日期 dept_id INT, FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键) ); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;孙悟空&#x27;,&#x27;男&#x27;,7200,&#x27;2013-02-24&#x27;,1); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;猪八戒&#x27;,&#x27;男&#x27;,3600,&#x27;2010-12-02&#x27;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;唐僧&#x27;,&#x27;男&#x27;,9000,&#x27;2008-08-08&#x27;,2); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;白骨精&#x27;,&#x27;女&#x27;,5000,&#x27;2015-10-07&#x27;,3); INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;蜘蛛精&#x27;,&#x27;女&#x27;,4500,&#x27;2011-03-14&#x27;,1); ☀笛卡尔积： 有两个集合A,B .取这两个集合的所有组成情况。 要完成多表查询，需要消除无用的数据 ☀多表查询的分类： ☀内连接查询： ☀隐式内连接： 使用where条件消除无用数据 例子： – 查询所有员工信息和对应的部门信息 1SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`; – 查询员工表的名称，性别。部门表的名称 1234567891011SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;--取别名的方式SELECT t1.name, -- 员工表的姓名 t1.gender,-- 员工表的性别 t2.name -- 部门表的名称FROM emp t1, dept t2WHERE t1.`dept_id` = t2.`id`; ☀显式内连接： ​ 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件 ​ 例如： 12SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`; ​ 内连接查询： ​ 1.从哪些表中查询数据 ​ 2.条件是什么 ​ 3.查询哪些字段 ☀外链接查询： ☀1. 左外连接： * 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件； * 查询的是左表所有数据以及其交集部分。 * 例子： -- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称 1SELECT t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`; ​ ☀2. 右外连接： * 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件； * 查询的是右表所有数据以及其交集部分。 * 例子： 1SELECT * FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`; ☀子查询： 概念：查询中嵌套查询，称嵌套查询为子查询。 – 查询工资最高的员工信息 – 1 查询最高的工资是多少 9000 1SELECT MAX(salary) FROM emp; – 2 查询员工信息，并且工资等于9000的 1SELECT * FROM emp WHERE emp.`salary` = 9000; – 一条sql就完成这个操作。子查询 1SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp); ☀子查询不同情况 子查询的结果是单行单列的： 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =* – 查询员工工资小于平均工资的人 1SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp); 子查询的结果是多行单列的： 子查询可以作为条件，使用运算符in来判断 – 查询’财务部’和’市场部’所有的员工信息 12SELECT id FROM dept WHERE NAME = &#x27;财务部&#x27; OR NAME = &#x27;市场部&#x27;;SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2; – 子查询 1SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#x27;财务部&#x27; OR NAME = &#x27;市场部&#x27;); 子查询的结果是多行多列的： 子查询可以作为一张虚拟表参与查询 – 查询员工入职日期是2011-11-11日之后的员工信息和部门信息 – 子查询 12SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &#x27;2011-11-11&#x27;) t2WHERE t1.id = t2.dept_id; – 普通内连接 1SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt; &#x27;2011-11-11&#x27; ☀多表查询练习 ☀建表 123456-- 部门表CREATE TABLE dept ( id INT PRIMARY KEY PRIMARY KEY, -- 部门id dname VARCHAR(50), -- 部门名称 loc VARCHAR(50) -- 部门所在地 ); 123456-- 添加4个部门INSERT INTO dept(id,dname,loc) VALUES (10,&#x27;教研部&#x27;,&#x27;北京&#x27;), (20,&#x27;学工部&#x27;,&#x27;上海&#x27;), (30,&#x27;销售部&#x27;,&#x27;广州&#x27;), (40,&#x27;财务部&#x27;,&#x27;深圳&#x27;); 123456-- 职务表，职务名称，职务描述CREATE TABLE job ( id INT PRIMARY KEY, jname VARCHAR(20), description VARCHAR(50)); 123456-- 添加4个职务INSERT INTO job (id, jname, description) VALUES(1, &#x27;董事长&#x27;, &#x27;管理整个公司，接单&#x27;),(2, &#x27;经理&#x27;, &#x27;管理部门员工&#x27;),(3, &#x27;销售员&#x27;, &#x27;向客人推销产品&#x27;),(4, &#x27;文员&#x27;, &#x27;使用办公软件&#x27;); 12345678910111213-- 员工表CREATE TABLE emp ( id INT PRIMARY KEY, -- 员工id ename VARCHAR(50), -- 员工姓名 job_id INT, -- 职务id mgr INT , -- 上级领导 joindate DATE, -- 入职日期 salary DECIMAL(7,2), -- 工资 bonus DECIMAL(7,2), -- 奖金 dept_id INT, -- 所在部门编号 CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id), CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)); ​ ​ ​ 12345678910111213141516-- 添加员工INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES(1001,&#x27;孙悟空&#x27;,4,1004,&#x27;2000-12-17&#x27;,&#x27;8000.00&#x27;,NULL,20),(1002,&#x27;卢俊义&#x27;,3,1006,&#x27;2001-02-20&#x27;,&#x27;16000.00&#x27;,&#x27;3000.00&#x27;,30),(1003,&#x27;林冲&#x27;,3,1006,&#x27;2001-02-22&#x27;,&#x27;12500.00&#x27;,&#x27;5000.00&#x27;,30),(1004,&#x27;唐僧&#x27;,2,1009,&#x27;2001-04-02&#x27;,&#x27;29750.00&#x27;,NULL,20),(1005,&#x27;李逵&#x27;,4,1006,&#x27;2001-09-28&#x27;,&#x27;12500.00&#x27;,&#x27;14000.00&#x27;,30),(1006,&#x27;宋江&#x27;,2,1009,&#x27;2001-05-01&#x27;,&#x27;28500.00&#x27;,NULL,30),(1007,&#x27;刘备&#x27;,2,1009,&#x27;2001-09-01&#x27;,&#x27;24500.00&#x27;,NULL,10),(1008,&#x27;猪八戒&#x27;,4,1004,&#x27;2007-04-19&#x27;,&#x27;30000.00&#x27;,NULL,20),(1009,&#x27;罗贯中&#x27;,1,NULL,&#x27;2001-11-17&#x27;,&#x27;50000.00&#x27;,NULL,10),(1010,&#x27;吴用&#x27;,3,1006,&#x27;2001-09-08&#x27;,&#x27;15000.00&#x27;,&#x27;0.00&#x27;,30),(1011,&#x27;沙僧&#x27;,4,1004,&#x27;2007-05-23&#x27;,&#x27;11000.00&#x27;,NULL,20),(1012,&#x27;李逵&#x27;,4,1006,&#x27;2001-12-03&#x27;,&#x27;9500.00&#x27;,NULL,30),(1013,&#x27;小白龙&#x27;,4,1004,&#x27;2001-12-03&#x27;,&#x27;30000.00&#x27;,NULL,20),(1014,&#x27;关羽&#x27;,4,1007,&#x27;2002-01-23&#x27;,&#x27;13000.00&#x27;,NULL,10); 123456-- 工资等级表CREATE TABLE salarygrade ( grade INT PRIMARY KEY, -- 级别 losalary INT, -- 最低工资 hisalary INT -- 最高工资); 1234567-- 添加5个工资等级INSERT INTO salarygrade(grade,losalary,hisalary) VALUES(1,7000,12000),(2,12010,14000),(3,14010,20000),(4,20010,30000),(5,30010,99990); ☀需求： 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述 123456789101112131415/*分析：1.员工编号，员工姓名，工资，需要查询emp表 职务名称，职务描述 需要查询job表2.查询条件 emp.job_id = job.id*/SELECT t1.`id`, -- 员工编号 t1.`ename`, -- 员工姓名 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description` -- 职务描述FROM emp t1, job t2WHERE t1.`job_id` = t2.`id`; 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置 12345678910111213141516/*分析：1. 员工编号，员工姓名，工资 emp 职务名称，职务描述 job 部门名称，部门位置 dept2. 条件： emp.job_id = job.id and emp.dept_id = dept.id*/SELECT t1.`id`, -- 员工编号 t1.`salary`,-- 工资 t2.`jname`, -- 职务名称 t2.`description`, -- 职务描述 t3.`dname`, -- 部门名称 t3.`loc` -- 部门位置FROM emp t1, job t2,dept t3WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`; 3.查询员工姓名，工资，工资等级 123456789101112/*分析：1.员工姓名，工资 emp 工资等级 salarygrade2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalaryemp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary*/SELECT t1.ename , t1.`salary`, t2.*FROM emp t1, salarygrade t2WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`; 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级 ​ 12345678910111213141516171819/*分析：1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept 工资等级 salarygrade2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary*/SELECT t1.`ename`, t1.`salary`, t2.`jname`, t2.`description`, t3.`dname`, t3.`loc`, t4.`grade`FROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.`job_id` = t2.`id`AND t1.`dept_id` = t3.`id`AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`; ​ 5.查询出部门编号、部门名称、部门位置、部门人数 12345678910111213141516/*分析：1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表2.使用分组查询。按照emp.dept_id完成分组，查询count(id)3.使用子查询将第2步的查询结果和dept表进行关联查询*/SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.totalFROM dept t1,(SELECT dept_id,COUNT(id) totalFROM empGROUP BY dept_id) t2WHERE t1.`id` = t2.dept_id; 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询 123456789101112131415161718192021222324252627/*分析：1.姓名 emp， 直接上级的姓名 emp* emp表的id 和 mgr 是自关联2.条件 emp.id = emp.mgr3.查询左表的所有数据，和 交集数据* 使用左外连接查询*//*selectt1.ename,t1.mgr,t2.`id`,t2.enamefrom emp t1, emp t2where t1.mgr = t2.`id`;*/SELECT t1.ename, t1.mgr, t2.`id`, t2.`ename`FROM emp t1 LEFT JOIN emp t2ON t1.`mgr` = t2.`id`; ☀事务 ☀事务的基本介绍 概念： 如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作： 开启事务： start transaction; 回滚：rollback; 提交：commit; 例子： 123456789101112131415161718192021CREATE TABLE account ( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(10), balance DOUBLE);-- 添加数据INSERT INTO account (NAME, balance) VALUES (&#x27;zhangsan&#x27;, 1000), (&#x27;lisi&#x27;, 1000);SELECT * FROM account;UPDATE account SET balance = 1000;-- 张三给李四转账 500 元-- 0. 开启事务START TRANSACTION;-- 1. 张三账户 -500UPDATE account SET balance = balance - 500 WHERE NAME = &#x27;zhangsan&#x27;;-- 2. 李四账户 +500-- 出错了...UPDATE account SET balance = balance + 500 WHERE NAME = &#x27;lisi&#x27;;-- 发现执行没有问题，提交事务COMMIT;-- 发现出问题了，回滚事务ROLLBACK; MySQL数据库中事务默认自动提交 事务提交的两种方式： 自动提交： mysql就是自动提交的 一条DML(增删改)语句会自动提交一次事务。 手动提交： Oracle 数据库默认 是手动提交事务 需要先开启事务，再提交 修改事务的默认提交方式： 查看事务的默认提交方式：SELECT @@autocommit; – 1 代表自动提交 0 代表手动提交 修改默认提交方式： set @@autocommit = 0; ​ ☀事务的四大特征： 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。 持久性：当事务提交或回滚后，数据库会持久化的保存数据。 隔离性：多个事务之间。相互独立。 一致性：事务操作前后，数据总量不变 ☀ ☀事务的隔离级别（了解） **概念：**多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。 存在问题： 脏读：一个事务，读取到另一个事务中没有提交的数据 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 隔离级别： read uncommitted：读未提交 产生的问题：脏读、不可重复读、幻读 2. read committed：读已提交 （Oracle） 产生的问题：不可重复读、幻读 3. repeatable read：可重复读 （MySQL默认） 产生的问题：幻读 4. serializable：串行化 可以解决所有的问题 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 数据库查询隔离级别： select @@tx_isolation; 数据库设置隔离级别： set global transaction isolation level 级别字符串; 演示： set global transaction isolation level read uncommitted; start transaction; – 转账操作 update account set balance = balance - 500 where id = 1; update account set balance = balance + 500 where id = 2; ☀DCL： ☀SQL分类： DDL：操作数据库和表 DML：增删改表中数据 DQL：查询表中数据 DCL：管理用户，授权 ☀DBA： 数据库管理员 ☀DCL：管理用户，授权 管理用户 添加用户： 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 删除用户： 语法：DROP USER '用户名'@'主机名'; 修改用户密码： 123456789101112131415UPDATE USER SET PASSWORD = PASSWORD(&#x27;新密码&#x27;) WHERE USER = &#x27;用户名&#x27;;UPDATE USER SET PASSWORD = PASSWORD(&#x27;abc&#x27;) WHERE USER = &#x27;lisi&#x27;;SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;主机名&#x27; = PASSWORD(&#x27;新密码&#x27;);SET PASSWORD FOR &#x27;root&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;123&#x27;);* mysql中忘记了root用户的密码？1. cmd -- &gt; net stop mysql 停止mysql服务* 需要管理员运行该cmd2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功4. use mysql;5. update user set password = password(&#x27;你的新密码&#x27;) where user = &#x27;root&#x27;;6. 关闭两个窗口7. 打开任务管理器，手动结束mysqld.exe 的进程8. 启动mysql服务9. 使用新密码登录。 查询用户： 12345-- 1. 切换到mysql数据库USE myql;-- 2. 查询user表SELECT * FROM USER;* 通配符： % 表示可以在任意主机使用用户登录数据库 权限管理： 查询权限： 123-- 查询权限SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;SHOW GRANTS FOR &#x27;lisi&#x27;@&#x27;%&#x27;; 授予权限： 123-- 授予权限grant 权限列表 on 数据库名.表名 to &#x27;用户名&#x27;@&#x27;主机名&#x27;;-- 给张三用户授予所有权限，在任意数据库任意表上 撤销权限： 123-- 撤销权限：revoke 权限列表 on 数据库名.表名 from &#x27;用户名&#x27;@&#x27;主机名&#x27;;REVOKE UPDATE ON db3.`account` FROM &#x27;lisi&#x27;@&#x27;%&#x27;;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://aner1001.gitee.io/tags/Mysql/"}]},{"title":"Mysql约束学习笔记","slug":"技术知识/数据库/Mysql/Mysql约束","date":"2021-02-24T13:22:58.000Z","updated":"2021-02-24T13:22:58.000Z","comments":true,"path":"posts/2021/02/24/92fb3c16122d/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/24/92fb3c16122d/","excerpt":"DQL:查询语句 排序查询 聚合函数 分组查询 分页查询 约束 多表之间的关系 范式 数据库的备份和还原","text":"DQL:查询语句 排序查询 聚合函数 分组查询 分页查询 约束 多表之间的关系 范式 数据库的备份和还原 学习文档 ☀DQL:查询语句 ☀排序查询 语法：order by 子句 order by 排序字段1 排序方式1 ， 排序字段2 排序方式2… 排序方式： ASC：升序，默认的。 DESC：降序。 注意： 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。 ☀聚合函数： 将一列数据作为一个整体，进行纵向的计算。 count：计算个数 一般选择非空的列：主键 count(*) max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 注意：聚合函数的计算，排除null值。 解决方案： (1)选择不包含非空的列进行计算 (2)IFNULL函数 ☀分组查询: 语法：group by 分组字段； 注意： 分组之后查询的字段：分组字段、聚合函数 where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 – 按照性别分组。分别查询男、女同学的平均分 SELECT sex , AVG(math) FROM student GROUP BY sex; – 按照性别分组。分别查询男、女同学的平均分,人数 SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex; – 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex; – 按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人 SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2; SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2; ​ ☀分页查询 语法：limit 开始的索引,每页查询的条数; 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 – 每页显示3条记录 SELECT * FROM student LIMIT 0,3; – 第1页 SELECT * FROM student LIMIT 3,3; – 第2页 SELECT * FROM student LIMIT 6,3; – 第3页 limit 是一个MySQL&quot;方言&quot; ☀约束 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。 分类： 主键约束：primary key 非空约束：not null 唯一约束：unique 外键约束：foreign key ☀非空约束：not null 某一列的值不能为null 创建表时添加约束 CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL – name为非空 ); 创建表完后，添加非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 删除name的非空约束 ALTER TABLE stu MODIFY NAME VARCHAR(20); ☀唯一约束：unique 某一列的值不能重复 注意： 唯一约束可以有NULL值，但是只能有一条记录为null 在创建表时，添加唯一约束 CREATE TABLE stu( id INT, phone_number VARCHAR(20) UNIQUE – 手机号 ); 删除唯一约束 ALTER TABLE stu DROP INDEX phone_number; 在表创建完后，添加唯一约束 ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE; ☀主键约束：primary key。 注意： 含义：非空且唯一 一张表只能有一个字段为主键 主键就是表中记录的唯一标识 在创建表时，添加主键约束 create table stu( id int primary key,-- 给id添加主键约束 name varchar(20) ); 删除主键 – 错误 alter table stu modify id int ; ALTER TABLE stu DROP PRIMARY KEY; 创建完表后，添加主键 ALTER TABLE stu MODIFY id INT PRIMARY KEY; 自动增长： 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长 在创建表时，添加主键约束，并且完成主键自增长 create table stu( id int primary key auto_increment,-- 给id添加主键约束 name varchar(20) ); 3. 删除自动增长 ALTER TABLE stu MODIFY id INT; 添加自动增长 ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; ​ ​ ☀外键约束：foreign key 让表于表产生关系，从而保证数据的正确性。 在创建表时，可以添加外键 语法： create table 表名( … 外键列 constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称) ); 删除外键 ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; 创建表之后，添加外键 ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称); 级联操作 添加级联操作 语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE ; 分类： 1. 级联更新：ON UPDATE CASCADE 2. 级联删除：ON DELETE CASCADE ​ ☀数据库的设计 ☀多表之间的关系 分类： 一对一(了解)： 如：人和身份证 分析：一个人只有一个身份证，一个身份证只能对应一个人 一对多(多对一)： 如：部门和员工 分析：一个部门有多个员工，一个员工只能对应一个部门 多对多： 如：学生和课程 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择 实现关系： 一对多(多对一)： 如：部门和员工 实现方式：在多的一方建立外键，指向一的一方的主键。 多对多： 如：学生和课程 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键 一对一(了解)： 如：人和身份证 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。 案例 – 创建旅游线路分类表 tab_category – cid 旅游线路分类主键，自动增长 – cname 旅游线路分类名称非空，唯一，字符串 100 CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) NOT NULL UNIQUE ); – 创建旅游线路表 tab_route /* rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类 */ CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid) ); /*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100 */ CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) UNIQUE NOT NULL, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT ‘男’, telephone VARCHAR(11), email VARCHAR(100) ); /* 创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次 */ CREATE TABLE tab_favorite ( rid INT, – 线路id DATE DATETIME, uid INT, – 用户id – 创建复合主键 PRIMARY KEY(rid,uid), – 联合主键 FOREIGN KEY (rid) REFERENCES tab_route(rid), FOREIGN KEY(uid) REFERENCES tab_user(uid) ); ​ ☀数据库设计的范式 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求 设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。 目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 分类： 第一范式（1NF）：每一列都是不可分割的原子数据项 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖） 几个概念： 函数依赖：A–&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号–&gt;姓名。 （学号，课程名称） --&gt; 分数 完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。 例如：（学号，课程名称） --&gt; 分数 部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 例如：（学号，课程名称） – &gt; 姓名 传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A 例如：学号–&gt;系名，系名–&gt;系主任 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码 例如：该表中码为：（学号，课程名称） 主属性：码属性组中的所有属性 非主属性：除过码属性组的属性 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） ☀数据库的备份和还原 命令行： 语法： 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原： 登录数据库 创建数据库 使用数据库 执行文件。source 文件路径 图形化工具：","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://aner1001.gitee.io/tags/Mysql/"}]},{"title":"Mysql基础学习笔记","slug":"技术知识/数据库/Mysql/Mysql基础","date":"2021-02-24T10:42:59.000Z","updated":"2021-02-24T10:42:59.000Z","comments":true,"path":"posts/2021/02/24/a82d4b3fe70f/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/24/a82d4b3fe70f/","excerpt":"数据库的基本概念 MySQL数据库软件 安装 卸载 配置 SQL基本语法.","text":"数据库的基本概念 MySQL数据库软件 安装 卸载 配置 SQL基本语法. ☀数据库的基本概念 数据库的英文单词： DataBase 简称 ： DB 什么数据库？ 用于存储和管理数据的仓库。 数据库的特点： 持久化存储数据的。其实数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 – SQL 常见的数据库软件 参见《MySQL基础.pdf》 ☀MySQL数据库软件 安装 参见《MySQL基础.pdf》 卸载 去mysql的安装目录找到my.ini文件 复制 datadir=“C:/ProgramData/MySQL/MySQL Server 5.5/Data/” 卸载MySQL 删除C:/ProgramData目录下的MySQL文件夹。 配置 MySQL服务启动 手动。 cmd–&gt; services.msc 打开服务的窗口 使用管理员打开cmd net start mysql : 启动mysql的服务 net stop mysql:关闭mysql服务 MySQL登录 mysql -uroot -p密码 mysql -hip -uroot -p连接目标的密码 mysql --host=ip --user=root --password=连接目标的密码 MySQL退出 exit quit MySQL目录结构 MySQL安装目录：basedir=“D:/develop/MySQL/” 配置文件 my.ini MySQL数据目录：datadir=“C:/ProgramData/MySQL/MySQL Server 5.5/Data/” 几个概念 数据库：文件夹 表：文件 数据：数据 ☀SQL 1.什么是SQL？ Structured Query Language：结构化查询语言 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法 SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 3 种注释 单行注释: – 注释内容 或 # 注释内容(mysql 特有) 多行注释: /* 注释 */ SQL分类 DDL(Data Definition Language)数据定义语言 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 DML(Data Manipulation Language)数据操作语言 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 DQL(Data Query Language)数据查询语言 用来查询数据库中表的记录(数据)。关键字：select, where 等 DCL(Data Control Language)数据控制语言(了解) 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 ☀DDL:操作数据库、表 操作数据库：CRUD C(Create):创建 创建数据库： create database 数据库名称; 创建数据库，判断不存在，再创建： create database if not exists 数据库名称; 创建数据库，并指定字符集 create database 数据库名称 character set 字符集名; 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk create database if not exists db4 character set gbk; R(Retrieve)：查询 查询所有数据库的名称: show databases; 查询某个数据库的字符集:查询某个数据库的创建语句 show create database 数据库名称; U(Update):修改 修改数据库的字符集 alter database 数据库名称 character set 字符集名称; D(Delete):删除 删除数据库 drop database 数据库名称; 判断数据库存在，存在再删除 drop database if exists 数据库名称; 使用数据库 查询当前正在使用的数据库名称 select database(); 使用数据库 use 数据库名称; 操作表 C(Create):创建 语法： create table 表名( 列名1 数据类型1, 列名2 数据类型2, … 列名n 数据类型n ); 注意：最后一列，不需要加逗号（,） 数据库类型： int：整数类型 age int, double:小数类型 score double(5,2) date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar：字符串 name varchar(20):姓名最大20个字符 zhangsan 8个字符 张三 2个字符 创建表 create table student( id int, name varchar(32), age int , score double(4,1), birthday date, insert_time timestamp ); * 复制表： * create table 表名 like 被复制的表名; R(Retrieve)：查询 查询某个数据库中所有的表名称 show tables; 查询表结构 desc 表名; U(Update):修改 修改表名 alter table 表名 rename to 新的表名; 修改表的字符集 alter table 表名 character set 字符集名称; 添加一列 alter table 表名 add 列名 数据类型; 修改列名称 类型 alter table 表名 change 列名 新列别 新数据类型; alter table 表名 modify 列名 新数据类型; 删除列 alter table 表名 drop 列名; D(Delete):删除 drop table 表名; drop table if exists 表名 ; 客户端图形化工具：SQLYog ☀DML:增删改表中数据 添加数据： 语法： insert into 表名(列名1,列名2,…列名n) values(值1,值2,…值n); 注意： 列名和值要一一对应。 如果表名后，不定义列名，则默认给所有列添加值 insert into 表名 values(值1,值2,…值n); 除了数字类型，其他类型需要使用引号(单双都可以)引起来 删除数据： 语法： delete from 表名 [where 条件] 注意： 如果不加条件，则删除表中所有记录。 如果要删除所有记录 delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作 TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。 修改数据： 语法： update 表名 set 列名1 = 值1, 列名2 = 值2,… [where 条件]; 注意： 如果不加任何条件，则会将表中所有记录全部修改。 ☀DQL：查询表中的记录 select * from 表名; 语法： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 基础查询 多个字段的查询 select 字段名1，字段名2… from 表名； 注意： 如果查询所有字段，则可以使用*来替代字段列表。 去除重复： distinct 计算列 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null 表达式1：哪个字段需要判断是否为null 如果该字段为null后的替换值。 起别名： as：as也可以省略 条件查询 where子句后跟条件 运算符 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt; BETWEEN…AND IN( 集合) LIKE：模糊查询 占位符： _:单个任意字符 %：多个任意字符 IS NULL and 或 &amp;&amp; or 或 || not 或 ! – 查询年龄大于20岁 SELECT * FROM student WHERE age &gt; 20; SELECT * FROM student WHERE age &gt;= 20; – 查询年龄等于20岁 SELECT * FROM student WHERE age = 20; – 查询年龄不等于20岁 SELECT * FROM student WHERE age != 20; SELECT * FROM student WHERE age &lt;&gt; 20; – 查询年龄大于等于20 小于等于30 SELECT * FROM student WHERE age &gt;= 20 &amp;&amp; age &lt;=30; SELECT * FROM student WHERE age &gt;= 20 AND age &lt;=30; SELECT * FROM student WHERE age BETWEEN 20 AND 30; – 查询年龄22岁，18岁，25岁的信息 SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25 SELECT * FROM student WHERE age IN (22,18,25); – 查询英语成绩为null SELECT * FROM student WHERE english = NULL; – 不对的。null值不能使用 = （!=） 判断 SELECT * FROM student WHERE english IS NULL; – 查询英语成绩不为null SELECT * FROM student WHERE english IS NOT NULL; ​ – 查询姓马的有哪些？ like ​ SELECT * FROM student WHERE NAME LIKE ‘马%’; ​ – 查询姓名第二个字是化的人 ​ SELECT * FROM student WHERE NAME LIKE &quot;化%&quot;; ​ – 查询姓名是3个字的人 ​ SELECT * FROM student WHERE NAME LIKE '__'; ​ – 查询姓名中包含德的人 ​ SELECT * FROM student WHERE NAME LIKE ‘%德%’; ​","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://aner1001.gitee.io/tags/Mysql/"}]},{"title":"windows10使用记录","slug":"技术知识/计算机/Windows/windows10使用记录","date":"2021-02-24T01:34:52.000Z","updated":"2021-02-24T01:34:52.000Z","comments":true,"path":"posts/2021/02/24/e9e028dc5bc5/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/24/e9e028dc5bc5/","excerpt":"","text":"☀快捷键 快捷键 描述 Win+1/2/3 按从左到右的位置，打开已开启的窗口。 Win+Shift+s 截图 Win+w 共享写字板Whiteboard等工具,全屏截图。 Win+G 游戏录像. Win+Tab 打开任务视图。 WIn+M 回到桌面。 Alt+F4 关闭当前窗口。当在Windows桌面时，唤出电源选项。上下选择关机、重启、睡眠。 『≡』+v+d 显示或者关闭桌面图标。 shift+tab 切换弹出框中的选项。 ctrl+tab 切换弹出框中的tab选项卡。 ☀常用操作 ☀取消开机时的账户密码 1.Win+R打开运行窗口，输入netplwiz 2.打开用户账户后，取消勾选即可。 ☀取消win10输入法的简繁切换快捷键 🤷‍♀️主要是此快捷键会和idea全局搜索冲突。 主界面右下导航栏，右击输入法，设置。 ☀关闭防火墙 cmd窗口，输入control命令，进入控制面板。 系统和安全 windows Defender防火墙 关闭windows防火墙：","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://aner1001.gitee.io/tags/windows/"}]},{"title":"Java序列化","slug":"技术知识/Java/基础/Java序列化","date":"2021-02-22T12:26:01.000Z","updated":"2021-02-22T12:26:01.000Z","comments":true,"path":"posts/2021/02/22/3c7056d4a750/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/22/3c7056d4a750/","excerpt":"序列化：指堆内存中的java对象数据，通过某种方式把对存储到磁盘文件中，或者传递给其他网络节点（网络传输）。这个过程称为序列化，通常是指将数据结构或对象转化成二进制的过程。","text":"序列化：指堆内存中的java对象数据，通过某种方式把对存储到磁盘文件中，或者传递给其他网络节点（网络传输）。这个过程称为序列化，通常是指将数据结构或对象转化成二进制的过程。 ☀一、序列化与反序列化 序列化：指堆内存中的java对象数据，通过某种方式把对存储到磁盘文件中，或者传递给其他网络节点（网络传输）。这个过程称为序列化，通常是指将数据结构或对象转化成二进制的过程。 即将对象转化为二进制，用于保存，或者网络传输。 反序列化：把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。也就是将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程 与序列化相反，将二进制转化成对象。 ☀二、序列化的作用 ① 想把内存中的对象保存到一个文件中或者数据库中时候； ② 想用套接字在网络上传送对象的时候； ③ 想通过RMI传输对象的时候 一些应用场景，涉及到将对象转化成二进制，序列化保证了能够成功读取到保存的对象。 ☀三、java的序列化实现 要实现对象的序列化，最直接的操作就是实现Serializable接口 使用IO流中的对象流可以实现序列化操作，将对象保存到文件，再读取出来。 首先创建一个对象，并实现Serializable接口： 12345678910111213141516171819202122232425262728293031import java.io.Serializable;public class User implements Serializable&#123; private static final long serialVersionUID = 1L; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125;&#125; 用对象流写一个保存对象与读取对象的工具类： 1234567891011121314151617181920212223242526272829303132333435import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;public class SerializeUtil &#123; // 保存对象，序列化 public static void saveObject(Object object) throws Exception &#123; ObjectOutputStream out = null; FileOutputStream fout = null; try &#123; fout = new FileOutputStream(&quot;D:/1.txt&quot;); out = new ObjectOutputStream(fout); out.writeObject(object); &#125; finally &#123; fout.close(); out.close(); &#125; &#125; // 读取对象，反序列化 public static Object readObject() throws Exception &#123; ObjectInputStream in = null; FileInputStream fin = null; try &#123; fin = new FileInputStream(&quot;D:/1.txt&quot;); in = new ObjectInputStream(fin); Object object = in.readObject(); return object; &#125; finally &#123; fin.close(); in.close(); &#125; &#125;&#125; 测试： 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; User user = new User(); user.setName(&quot;旭旭宝宝&quot;); user.setAge(33); // 保存 try &#123; SerializeUtil.saveObject(user); &#125; catch (Exception e) &#123; System.out.println(&quot;保存时异常：&quot; + e.getMessage()); &#125; // 读取 User userObject; try &#123; userObject = (User) SerializeUtil.readObject(); System.out.println(userObject); &#125; catch (Exception e) &#123; System.out.println(&quot;读取时异常：&quot; + e.getMessage()); &#125; &#125;&#125; ☀四、序列化ID的作用 可以看到，我们在进行序列化时，加了一个serialVersionUID字段，这便是序列化ID 1private static final long serialVersionUID = 1L; 这个序列化ID起着关键的作用，它决定着是否能够成功反序列化！java的序列化机制是通过判断运行时类的serialVersionUID来验证版本一致性的，在进行反序列化时，JVM会把传进来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。 即序列化ID是为了保证成功进行反序列化。 ☀五、默认的序列化ID 当我们一个实体类中没有显式的定义一个名为“serialVersionUID”、类型为long的变量时，Java序列化机制会根据编译时的class自动生成一个serialVersionUID作为序列化版本比较，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID。譬如，当我们编写一个类时，随着时间的推移，我们因为需求改动，需要在本地类中添加其他的字段，这个时候再反序列化时便会出现serialVersionUID不一致，导致反序列化失败。那么如何解决呢？便是在本地类中添加一个“serialVersionUID”变量，值保持不变，便可以进行序列化和反序列化。 如果没有显示指定serialVersionUID，会自动生成一个。 只有同一次编译生成的class才会生成相同的serialVersionUID 但是如果出现需求变动，Bean类发生改变，则会导致反序列化失败。为了不出现这类的问题，所以我们最好还是显式的指定一个serialVersionUID。 ☀六、序列化的其他问题 静态变量不会被序列化（ static,transient） 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化。 ☀七、使用效率更高的序列化框架—Protostuff 其实java的原生序列化方式（通过实现Serialiable接口），效率并不是最高的。 github上有一个分析序列化效率的项目：https://github.com/eishay/jvm-serializers/wiki 其中看的出来性能最优的为google开发的colfer ，但是由于colfer的使用难度太大，而更多的都是使用protostuff序列化框架。适用改框架要引入两个库（core与runtime）。 protostuff工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.Map;import java.util.concurrent.ConcurrentHashMap;import com.dyuproject.protostuff.LinkedBuffer;import com.dyuproject.protostuff.ProtobufIOUtil;import com.dyuproject.protostuff.Schema;import com.dyuproject.protostuff.runtime.RuntimeSchema;public class SerializeUtil &#123; private static Map&lt;Class&lt;?&gt;, Schema&lt;?&gt;&gt; cachedSchema = new ConcurrentHashMap&lt;&gt;(); @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; byte[] serializer(T obj) &#123; Class&lt;T&gt; clazz = (Class&lt;T&gt;) obj.getClass(); Schema&lt;T&gt; schema = getSchema(clazz); return ProtobufIOUtil.toByteArray(obj, schema, LinkedBuffer.allocate(256)); &#125; public static &lt;T&gt; T deSerializer(byte[] bytes, Class&lt;T&gt; clazz) &#123; T message; try &#123; message = clazz.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; Schema&lt;T&gt; schema = getSchema(clazz); ProtobufIOUtil.mergeFrom(bytes, message, schema); return message; &#125; @SuppressWarnings(&quot;unchecked&quot;) public static &lt;T&gt; Schema&lt;T&gt; getSchema(Class&lt;T&gt; clazz) &#123; Schema&lt;T&gt; schema = (Schema&lt;T&gt;) cachedSchema.get(clazz); if (schema == null) &#123; schema = RuntimeSchema.createFrom(clazz); if (schema != null) &#123; cachedSchema.put(clazz, schema); &#125; &#125; return schema; &#125;&#125; 这样即使我们的User类就不用再实现Serialiable接口了，同样可以进行序列化，效率也更高。 ☀转载参考博客: java序列化详解","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"}],"tags":[{"name":"Serializable","slug":"Serializable","permalink":"http://aner1001.gitee.io/tags/Serializable/"}]},{"title":"Maven","slug":"技术知识/工具/Maven","date":"2021-02-20T13:46:43.000Z","updated":"2021-02-20T13:46:43.000Z","comments":true,"path":"posts/2021/02/20/057902a79d03/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/20/057902a79d03/","excerpt":"Maven是Apache的一款开源的项目管理工具。在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导jar包、拆分项目等效果。","text":"Maven是Apache的一款开源的项目管理工具。在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导jar包、拆分项目等效果。 ☀❀什么是Maven 目前无论使用IDEA还是Eclipse等其他IDE，使用里面ANT工具。ANT工具帮助我们进行编译，打包运行等工作。 Apache基于ANT进行了升级，研发出了全新的自动化构建工具Maven。 Maven是Apache的一款开源的项目管理工具。 以后无论是普通javase项目还是javaee项目，我们都创建的是Maven项目。 Maven使用项目对象模型(POM-Project Object Model,项目对象模型)的概念,可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导jar包、拆分项目等效果。 ☀Maven的下载_目录结构_IDEA整合Maven ☀【1】IDEA默认整合了Maven： ☀【2】下载地址： http://maven.apache.org/ ☀【3】目录结构： bin：存放的是执行文件，命令 在IDEA中可以直接集成Maven: conf目录：下面有一个非常重要的配置文件–》settings.xml—》maven的核心配置文件/全局配置文件。 .m2目录：如果没有.m2目录 ，自己手动执行mvn命令：mvn help:system ☀Maven仓库 Maven仓库是基于简单文件系统存储的，集中化管理Java API资源（构件）的一个服务。 仓库中的任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径。得益于 Maven 的坐标机制，任何 Maven项目使用任何一个构件的方式都是完全相同的。 Maven 可以在某个位置统一存储所有的 Maven 项目共享的构件，这个统一的位置就是仓库，项目构建完毕后生成的构件也可以安装或者部署到仓库中，供其它项目使用。 对于Maven来说，仓库分为两类：本地仓库和远程仓库。 ☀远程仓库 不在本机中的一切仓库，都是远程仓库：分为中央仓库 和 本地私服仓库 远程仓库指通过各种协议如file://和http://访问的其它类型的仓库。这些仓库可能是第三方搭建的真实的远程仓库，用来提供他们的构件下载（例如repo.maven.apache.org和uk.maven.org是Maven的中央仓库）。其它“远程”仓库可能是你的公司拥有的建立在文件或HTTP服务器上的内部仓库(不是Apache的那个中央仓库，而是你们公司的私服，你们自己在局域网搭建的maven仓库)，用来在开发团队间共享私有构件和管理发布的。 默认的远程仓库使用的Apache提供的中央仓库： https://mvnrepository.com/ ☀本地仓库 本地仓库指本机的一份拷贝，用来缓存远程下载，包含你尚未发布的临时构件。 ☀仓库配置 ☀在settings.xml文件中配置本地仓库 本地仓库是开发者本地电脑中的一个目录，用于缓存从远程仓库下载的构件。默认的本地仓库是${user.home}/.m2/repository。用户可使用settings.xml文件修改本地仓库。具体内容如下： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt; &lt;!-- 本地仓库配置 --&gt; &lt;localRepository&gt;具体本地仓库位置&lt;/localRepository&gt; &lt;!-- 省略，具体信息参考后续内容。 --&gt;&lt;/settings&gt; ☀在settings.xml文件中配置镜像仓库 如果仓库A可以提供仓库B存储的所有内容，那么就可以认为A是B的一个镜像。例如：在国内直接连接中央仓库下载依赖，由于一些特殊原因下载速度非常慢。这时，我们可以使用阿里云提供的镜像http://maven.aliyun.com/nexus/content/groups/public/来替换中央仓库http://repol.maven.org/maven2/。修改maven的setting.xml文件，具体内容如下： 12345678910&lt;mirror&gt; &lt;!-- 指定镜像ID（可自己改名） --&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;!-- 匹配中央仓库（阿里云的仓库名称，不可以自己起名，必须这么写）--&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;!-- 指定镜像名称（可自己改名） --&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;!-- 指定镜像路径（镜像地址） --&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; ☀仓库优先级问题 个人理解：依赖有优先级，因为私服中的依赖不一定是全量。 ☀JDK的配置 当你的idea中有多个jdk的时候，就需要指定你编译和运行的jdk： 在settings.xml中配置： 12345678910111213141516&lt;profile&gt; &lt;!-- settings.xml中的id不能随便起的 --&gt; &lt;!-- 告诉maven我们用jdk1.8 --&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;!-- 开启JDK的使用 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;!-- 配置编译器信息 --&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 配置的前提是你的idea中要有1.8的jdk 💚总结： 在settings.xml中：配置了三个信息： 【1】本地仓库 【2】镜像仓库 【3】JDK ☀Maven工程类型 【1】POM工程 POM工程是逻辑工程。用在父级工程或聚合工程中。用来做jar包的版本控制。 【2】JAR工程 将会打包成jar，用作jar包使用。即常见的本地工程 —&gt; Java Project。 【3】WAR工程 将会打包成war，发布在服务器上的工程。 ☀在IDEA中创建Maven工程 ☀Maven项目结构 标准目录结构： ❀src/main/java 这个目录下储存java源代码 ❀src/main/resources 储存主要的资源文件。比如xml配置文件和properties文件 ❀src/test/java 储存测试用的类，比如JUNIT的测试一般就放在这个目录下面 因为测试类本身实际是不属于项目的，所以放在任何一个包下都显得很尴尬，所以maven专门创建了一个测试包 用于存放测试的类 ❀src/test/resources 可以自己创建你，储存测试环境用的资源文件 ❀src 包含了项目所有的源代码和资源文件，以及其他项目相关的文件。 ❀target 编译后内容放置的文件夹 ❀pom.xml 是Maven的基础配置文件。配置项目和项目之间关系，包括配置依赖关系等等 结构图： wiki123456789--MavenDemo 项目名 --.idea 项目的配置，自动生成的，无需关注。 --src -- main 实际开发内容 --java 写包和java代码，此文件默认只编译.java文件 --resource 所有配置文件。最终编译把配置文件放入到classpath中。 -- test 测试时使用，自己写测试类或junit工具等 --java 储存测试用的类 pom.xml 整个maven项目所有配置内容。 注意：目录名字不可以随便改，因为maven进行编译或者jar包生成操作的时候，是根据这个目录结构来找的，你若轻易动，那么久找不到了。 ☀POM模式-Maven工程关系 Maven工具基于POM（Project Object Model，项目对象模型）模式实现的。在Maven中每个项目都相当于是一个对象，对象（项目）和对象（项目）之间是有关系的。关系包含了：依赖、继承、聚合，实现Maven项目可以更加方便的实现导jar包、拆分项目等效果。 ☀依赖 【1】依赖关系： 即A工程开发或运行过程中需要B工程提供支持，则代表A工程依赖B工程。 在这种情况下，需要在A项目的pom.xml文件中增加下属配置定义依赖关系。 通俗理解：就是导jar包。 B工程可以是自己的项目打包后的jar包，也可以是中央仓库的jar包。 【2】如何注入依赖呢？ 在pom.xml文件 根元素project下的 dependencies标签中，配置依赖信息，内可以包含多个 dependence元素，以声明多个依赖。每个依赖dependence标签都应该包含以下元素：groupId, artifactId, version : 依赖的基本坐标， 对于任何一个依赖来说，基本坐标是最重要的， Maven根据坐标才能找到需要的依赖。 【3】依赖的好处： 省去了程序员手动添加jar包的操作，省事！！ 可以帮我们解决jar包冲突问题： ☀特性_依赖的传递性 传递性依赖是Maven2.0的新特性。假设你的项目依赖于一个库，而这个库又依赖于其他库。你不必自己去找出所有这些依赖，你只需要加上你直接依赖的库，Maven会隐式的把这些库间接依赖的库也加入到你的项目中。这个特性是靠解析从远程仓库中获取的依赖库的项目文件实现的。一般的，这些项目的所有依赖都会加入到项目中，或者从父项目继承，或者通过传递性依赖。 如果A依赖了B，那么C依赖A时会自动把A和B都导入进来。 创建A项目后，选择IDEA最右侧Maven面板lifecycle，双击install后就会把项目安装到本地仓库中，其他项目就可以通过坐标引用此项目。 案例： 项目1：MavenDemo项目依赖了Mybatis的内容： 注意：请将项目1打包为jar包—》重新打包 再创建项目2：让项目2依赖项目1： 从上面可以证明：项目2依赖项目1，项目1依赖Mybatis工程，–》传递性—》项目2可以直接使用Mybatis工程。 ☀原则_两个原则 【1】第一原则：最短路径优先原则 “最短路径优先”意味着项目依赖关系树中路径最短的版本会被使用。 例如，假设A、B、C之间的依赖关系是A-&gt;B-&gt;C-&gt;D(2.0) 和A-&gt;E-&gt;(D1.0)，那么D(1.0)会被使用，因为A通过E到D的路径更短。 【2】第二原则：最先声明原则 依赖路径长度是一样的的时候，第一原则不能解决所有问题，比如这样的依赖关系：A–&gt;B–&gt;Y(1.0)，A–&gt;C–&gt;Y(2.0)，Y(1.0)和Y(2.0)的依赖路径长度是一样的，都为2。那么到底谁会被解析使用呢？在maven2.0.8及之前的版本中，这是不确定的，但是maven2.0.9开始，为了尽可能避免构建的不确定性，maven定义了依赖调解的第二原则：第一声明者优先。在依赖路径长度相等的前提下，在POM中依赖声明的顺序决定了谁会被解析使用。顺序最靠前的那个依赖优胜。 ☀排除依赖 exclusions： 用来排除传递性依赖 其中可配置多个exclusion标签，每个exclusion标签里面对应的有groupId, artifactId, version三项基本元素。注意：不用写版本号。 比如：A—&gt;B—&gt;C (Mybatis.jar) 排除C中的Mybatis.jar 。 ☀依赖范围 依赖范围就决定了你依赖的坐标 在什么情况下有效，什么情况下无效： ❀compile 这是默认范围。如果没有指定，就会使用该依赖范围。表示该依赖在编译和运行时都生效。 ❀provided 已提供依赖范围。使用此依赖范围的Maven依赖。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍(如：servlet-api)。 ❀runtime runtime范围表明编译时不需要生效，而只在运行时生效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。 ❀system 系统范围与provided类似，不过你必须显式指定一个本地系统路径的JAR，此类依赖应该一直有效，Maven也不会去仓库中寻找它。但是，使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。 ❀test test范围表明使用此依赖范围的依赖，只在编译测试代码和运行测试的时候需要，应用的正常运行不需要此类依赖。典型的例子就是JUnit，它只有在编译测试代码及运行测试的时候才需要。Junit的jar包就在测试阶段用就行了，你导出项目的时候没有必要把junit的东西到处去了就，所在在junit坐标下加入scope-test。 ❀Import import范围只适用于pom文件中的部分。表明指定的POM必须使用部分的依赖。 注意：import只能用在dependencyManagement的scope里。 ❤️心得：编译时需要的Jar，运行时一定需要。运行时需要的jar，编译时不一定需要。 定义一个父工程–》POM工程： 注意：工程1要打成自己的jar包 定义一个子工程： 如果父工程中加入score-import 相当于强制的指定了版本号： 如果父工程中加入score-import 相当于强制的指定了版本号： ☀继承 【1】继承关系： 如果A工程继承B工程，则代表A工程默认依赖B工程依赖的所有资源，且可以应用B工程中定义的所有资源信息。 被继承的工程（B工程）只能是POM工程。 注意：在父项目中放在中的内容时不被子项目继承，不可以直接使用 放在中的内容主要目的是进行版本管理。里面的内容在子项目中依赖时坐标只需要填写 和即可。（注意：如果子项目不希望使用父项目的版本，可以明确配置version）。 父工程是一个POM工程： 创建子工程： 本质上：POM文件的继承 ☀聚合 当我们开发的工程拥有2个以上模块的时候，每个模块都是一个独立的功能集合。比如某大学系统中拥有搜索平台，学习平台，考试平台等。开发的时候每个平台都可以独立编译，测试，运行。这个时候我们就需要一个聚合工程。 在创建聚合工程的过程中，总的工程必须是一个POM工程（Maven Project）（聚合项目必须是一个pom类型的项目，jar项目war项目是没有办法做聚合工程的），各子模块可以是任意类型模块（Maven Module）。 前提：继承。 聚合包含了继承的特性。 聚合时多个项目的本质还是一个项目。这些项目被一个大的父项目包含。且这时父项目类型为pom类型。同时在父项目的pom.xml中出现表示包含的所有子模块。 总项目：一般总项目：POM项目 具体模块： ☀常见插件 ☀编译器插件 通过编译器插件，我们可以配置使用的JDK或者说编译器的版本： 【1】 settings.xml文件中配置全局编译器插件： 找到profiles节点，在里面加入profile节点： 123456789101112131415&lt;profile&gt; &lt;!-- 定义的编译器插件ID，全局唯一，名字随便起 --&gt; &lt;id&gt;jdk-1.7&lt;/id&gt; &lt;!-- 插件标记，activeByDefault ：true默认编译器，jdk提供编译器版本 --&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.7&lt;/jdk&gt; &lt;/activation&gt; &lt;!-- 配置信息source-源信息，target-字节码信息，compilerVersion-编译过程版本 --&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.7&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 【2】配置编译器插件：pom.xml配置片段 1234567891011121314151617181920&lt;!-- 配置maven的编译插件 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;!--JDK编译插件 --&gt; &lt;plugin&gt; &lt;!--插件坐标 --&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;!-- --&gt; &lt;configuration&gt; &lt;!-- 源代码使用JDK版本--&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;!-- 源代码编译为class文件的版本，要保持跟上面版本一致--&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ☀资源拷贝插件 Maven在打包时默认只将src/main/resources里的配置文件拷贝到项目中并做打包处理，而非resource目录下的配置文件在打包时不会添加到项目中。 我们的配置文件，一般都放在：src/main/resources 然后打包后配置文件就会在target的classes下面放着： 测试： 我现在想把非resources下面的文件也打包到classes下面： 需要配置： pom.xml配置片段： 1234567891011121314151617&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 配置好以后，那么你设置的位置下的配置文件都会被打包了： ☀tomcat插件 我们如果创建war项目，必然要部署在服务器上，方式： （1）部署在远程服务器上 （2）将IDEA和外部tomcat产生关联，然后将项目部署在外部tomcat上 现在学习一个新的方式，不再依赖外部的tomcat，maven提供了tomcat插件，我们可以配置来使用。 创建web项目：war项目： 在index.jsp中随便写点东西： 使用Tomcat插件发布部署并执行war工程的时候，需要使用启动命令，启动命令为： tomcat7:run。命令中的tomcat7是插件命名，由插件提供商决定。run为插件中的具体功能。 （注意：之前用的编译器插件，资源拷贝插件，不是可运行的插件，maven直接帮我们运行了，但是tomcat属于可运行插件，它什么时候工作需要程序员来控制，怎么控制呢？我们必须通过命令来运行控制） 具体pom.xml文件的配置如下： 12345678910111213141516&lt;build&gt; &lt;plugins&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 配置Tomcat监听端口 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;!-- 配置项目的访问路径(Application Context) --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 执行命令： 显示tomcat启动成功： 在浏览器中访问index.jsp页面： ☀Maven常见命令介绍 Maven的命令非常多，我们只是讲解常用的几个：（所有命令都可以在控制台运行的） ☀❀ install 本地安装， 包含编译，打包，安装到本地仓库 编译 - javac 打包 - jar， 将java代码打包为jar文件 安装到本地仓库 - 将打包的jar文件，保存到本地仓库目录中。 ☀❀ clean 清除已编译信息。 删除工程中的target目录。 ☀❀ compile 只编译。 javac命令 ☀❀ package 打包。 包含编译，打包两个功能。 install和package的区别： package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库 install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://aner1001.gitee.io/tags/Maven/"}]},{"title":"方便老人使用Win10系统的一些配置","slug":"生活知识/经验感悟/方便老人使用Win10系统的一些配置","date":"2021-02-13T08:01:10.000Z","updated":"2021-02-13T08:01:10.000Z","comments":true,"path":"posts/2021/02/13/5594880059a2/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/13/5594880059a2/","excerpt":"给外婆弄了一台电脑。记录一些方便老人使用的Win10配置攻略。 教会她玩，锻炼大脑，防止老年痴呆。","text":"给外婆弄了一台电脑。记录一些方便老人使用的Win10配置攻略。 教会她玩，锻炼大脑，防止老年痴呆。 ☀1.设置项 不要设置开机密码。 设置——设备——鼠标，将鼠标调得尽可能大。光标尽可能粗。 设置——系统——显示，将显示文本、应用的百分比调大。 设置——系统——显示，开启夜间模式。 设置——系统——存储，更改文件保存位置。 桌面图标，设置为最大显示。 文件夹选项中，设置鼠标单击就能打开应用。 文件夹选项设置所有文件都显示大图标。 选择好壁纸，可以使老年人清晰地看到图标。 降低UAC的警报等级和减少Windows Defender的提示并提高Edge的防护； 用户前往开始菜单下的Windows Defender安全中心，然后左下角设置关掉提示； 前往Windows Defender安全中心并进入“应用和浏览器控制”——前两个直接选择阻止。 避免老年人一个不小心安装全家桶，所以我们需要在搞定一切之后限制一下允许安装软件的方式。设置——应用——在“正在安装应用”一栏选择“仅允许来自应用商店的应用”。 ☀2.辅助工具 汉王，手写唐人笔。 电脑关机bat脚本。并设置快捷方式，将快捷方式绑定快捷键如F11，只需要按一下，就可以将电脑关机，不需要从右下方的小窗中层层点击。在键盘上贴上标识，因为我买的键盘是黑色的，所以只需要在对应按键上贴一个白色的粘布条就可以。很显眼方便。 12@echo offshutdown -s -t 0 自动关闭窗口脚本。 1.下载安装autohotkey工具。 2.编辑脚本，意思是将win键功能转为按下alt+F4功能。 1LWin::Send !&#123;F4&#125; 3.创建脚本的快捷方式，并放入开机启动项目。放入路径：C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp 的文件夹中。 优酷的视频软件，目前用起来还不错，可以设置桌面项，打开直接可以看。注意设置将广告弹窗都去除。用于优酷单独下载的视频播放。 爱奇艺软件。下载的视频也能单独播放。用于爱奇艺单独下载的视频播放。 迅雷影音软件。用于单独下载的电视剧电影播放。可以设置打开开后自动播放，并且可以自动播放下一个，非常方便。 音乐软件可以选择Microsoft Store中的网易云音乐和QQ音乐，UWP版本，非常好看美观。 ☀3.教学 学会开机和关机。 学会点击打开软件。 学会关闭软件。 学会打开视频，音乐。 学会暂停（空格）。 学会鼠标滚轮。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"电脑配置","slug":"生活知识/经验感悟/电脑配置","date":"2021-02-09T01:39:00.000Z","updated":"2021-02-09T01:39:00.000Z","comments":true,"path":"posts/2021/02/09/019484e7867e/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/09/019484e7867e/","excerpt":"程序员要有一台好电脑，即可以敲代码🎹飞快，又可以玩游戏🎮。现在还属于正在逆袭中的屌丝程序员，所以要搞一台性价比高的。","text":"程序员要有一台好电脑，即可以敲代码🎹飞快，又可以玩游戏🎮。现在还属于正在逆袭中的屌丝程序员，所以要搞一台性价比高的。 心得： 买小的配件，散热、风扇等，可以多平台搜索参考，应对缺货，特别是过年的时候，过年不打烊。淘宝、京东、拼多多、抖音也可以！ B站点击量最多的装机教程 ☀CPU 最终还是选择了10600kf不超频，性价比高。 ☀经验 AMD选择盒装，Inter选择散片。 参数 盒装 散片 来源渠道 正规零售商品 电脑整机原料 售后政策 三年官方保修 一年店家保修 赠送散热 低端送散热高端不送 完全不送散热 随机体质 体质靠摸奖 可能被人挑过体质 ☀选择 10400f 900多确实很实惠。而且能带3070. 10600kf 200块钱买0.5GHz的主频提升不亏的，主要是放在之前，哪里会有这种好事，有钱都找不到这种选择， 200块钱，啥都不用干，直接让全核心睿频4.0GHz直接提升到全核心睿频4.5GHz，性能直接提升12.5%，最主要的是10600KF这颗CPU的功耗还不高，默认跑FPU功耗也就百来瓦，直接用压10400F的散热器就可以稳压，根本不用担心什么散热器还需要怎么加强的问题， 对于主板来说，只要不是那种会锁65W长时睿频功耗墙的B460/H410，基本上就不用担心说主板带不动的问题，像微星这波B460/H410就都带得动10600KF，不用担心带不动。 i5 10600KF可以看成小一号的i7 10700F， 这俩都是Comet Lake架构，即Skylake的终极马甲，直接对比数据， i5 10600KF 6C12T 全核心睿频4.5GHz， i7 10700F 8C16T 全核心睿频4.6GHz. 10600KF最高可以上到3090的显卡（不过由于3080和3090之间异常巨大的价差，所以一般来说在这期间CPU也会被升级 5600x 觉得太贵，多出的20%性能意义不大，够用就行，相较于英特尔的降价。选择英特尔更加香。 ☀散热 ☀选择 [雅浚G3] 159 众推，就选这个了。拼多多115拿下。 [利民霜灵 FS140] 259 ☀经验 对比风量和噪音。 ☀显卡 先用1060 6g 过渡，溢价严重，必须做一个等等党。 ☀挑选 3070 3060TI 性能优秀，低功耗。和3070差13%。 2080super强2%-3%。 ☀内存条 内存条，两个8G比一个16G的要好。 ☀挑选 雷克沙2666 阿斯加特8GB 2666频率 T2 ☀SSD固态硬盘 最终选择了三星大厂。 ☀选择 三星970 EVO PLUS NVME m.2 529元 三星的很好，稳定。5年质保。 东芝，大厂，性价比高。 浦科特。 英特尔 建兴 西部数据SN750 500G 477元 ☀经验 是否需要200的散热马甲？暂时不需要，主板自带。 优先选择自己生产存储颗粒的固态硬盘品牌。 容量越大寿命越久 3.TLC颗粒价格便宜，用几年换新就可以了。 ☀HDD机械硬盘 1T，自带老机器上继续用。 ##主板 微星 MORTAR 迫击炮。 ☀选择 微星： ​ MORTAR 迫击炮，选择了这个网红。 ​ TORPEDO 鱼雷 ☀电源 ☀经验： 好的电源是关键，能够保护，硬件，使得硬件寿命更长。 显卡+CPU工号+100W给主板硬盘等。 ☀选择 鑫谷：650W 航嘉WD600K 600w金牌 379 ☀机箱 ☀经验 机箱走线教学 机箱安装风扇选择背部抽风的位置。 前面进风风扇，转速调整最低。上面的抽风风扇，转速稍微比前面进风高一点点。最后位置的风扇。后面选择高转速，低噪音。 支持大板型一定支持小板型，选择机箱最大型号小一号的主板，方便走线。 一定选下置电源，降低重心不容易倒，有很好的风道。上置电源容易被铐。 要有电源仓，方便走线。 支架式设计，不利于通风，比较丑。 接口位置，接口可以朝前。朝上容易积灰，后期做好防护和遮挡。现在最多的是朝上。 不要买便宜的透明机箱。 风扇1~3个。 对体积没要求买大机箱。方便走线，散热更好。 300元以上机箱妥妥的。 ☀风扇： 风量扇: 安装离CPU近。，出风。超过70cfm属于大风量。 风压扇 进风。2以上属于大风压。 在不考虑噪音和寿命，选择入门级的的风扇就可以了。性价比。在温度上和百元级别差距不大。 接口： 4针通过电流进行pwm调速。根据台电脑温度控制转速。单个35元以上支持。 RGB灯光： 有共用一根线控制的。控制效果单一。 如果主板支持12v 4针，可提供过，主板来控制颜色。 5v-3pin可编程RGB。 轴承： ##配置表 参考： 选择下方这个了： 规格 名称 价格 数量 合计 补充 CPU I5-10600KF 六核心十二线程 1125 1 1125 淘宝散片 主板 微星B460M迫击炮 690 1 690 淘宝 散热 雅俊G3散热器 109 1 109 拼多多 内存 阿斯加特洛极L1 16G 8X2 2666 179 2 358 淘宝 显卡 七彩虹3060Ti-8G Ultra W OC 4649 1 4649 淘宝 机械硬盘 根据自己预算加装 0 1 0 固态硬盘 西部数据SN750 500G 433 1 433 淘宝 电源 航嘉WD600K 600w金牌 359 1 359 淘宝 机箱 MATX（机箱右侧自选） 淘宝 风扇 根据自己预算加装 0 0 规格 名称 价格 数量 合计 补充 CPU I5-10400F 六核心十二线程 919 1 919 淘宝散片 主板 微星B460爆破弹（+220迫击炮） 460 1 460 淘宝 散热 雅俊G3散热器 109 1 109 淘宝 内存 威刚万紫千红16G 8X2 2666 358 1 358 淘宝 显卡 铭瑄1660S-6G终结者 2159 1 2159 淘宝 机械硬盘 根据自己预算加装 0 1 0 固态硬盘 铠侠RC10 500G 369 1 369 淘宝 电源 先马500p 500w金牌 194 1 194 拼多多 机箱 ITX（机箱右侧自选） 淘宝 风扇 根据自己预算加装 0 0 规格 名称 价格 数量 合计 补充 CPU R5-5600X 6核心十二现场 2099 1 2099 淘宝散片 主板 微星B550M迫击炮 699 1 699 淘宝 散热 雅俊G3散热器 109 1 109 淘宝 内存 阿斯加特W2 16G 8X2 3200 449 1 449 拼多多 显卡 七彩虹3070-8G AD OC 5399 1 5399 淘宝 机械硬盘 根据自己预算加装 0 1 0 固态硬盘 西部数据SN750 500G 433 1 433 淘宝 电源 航嘉WD600K 600w金牌 359 1 359 淘宝 机箱 MATX（机箱右侧自选） 淘宝 风扇 根据自己预算加装 0 0 软件： 杀毒推荐：avast。最佳免费杀毒软件。360国际版。 清理软件，ccleaner netspeedmonitor,监控 网络流量。 谷歌插件：infinity 定制页面 adblock plus 过滤广告。 adsafe，主流视频广告。 listary pro 建立索引。可以瞬间查找电脑上的应用。 休眠文件随着使用越来越大。 cmd输入 1powercfg -h off #关闭休眠模式。 win10自动跟新，","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"linux-vi","slug":"技术知识/计算机/Linux/linux-vi","date":"2021-02-08T05:30:03.000Z","updated":"2021-02-08T05:30:03.000Z","comments":true,"path":"posts/2021/02/08/8fb759bdc2c9/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/8fb759bdc2c9/","excerpt":"linux vi命令详解，在网上找到的，已经很详细了，直接转接的。 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指 令。由于 对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编 辑器，学会它后，您将在Linux的世界里畅行无阻。","text":"linux vi命令详解，在网上找到的，已经很详细了，直接转接的。 vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指 令。由于 对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编 辑器，学会它后，您将在Linux的世界里畅行无阻。 注：本文中#代表了注释。 ☀1、vi的基本概念 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 **❤️个人理解：**vi将连续的字符串作为单词，无论长度是多长。即使一整行是连续的，就是看做一个单词。空格作为单词之间的间隔。 ☀2、vi的基本操作 a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： 1vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到 「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： : w filename （输入 「w filename」将文章以指定的文件名filename保存）相当于是另存为操作。 : wq (输入「wq」，存盘并退出vi) : q! (输入q!， 不存盘强制退出vi) ☀3、命令行模式（command mode）功能键 1）. 插入模式 按「i」切换进入插入模式「insert mode」，按&quot;i&quot;进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从光标所在行的下一行的行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往&quot;后&quot;移动一页。对应单词back。 按「ctrl」+「f」：屏幕往&quot;前&quot;移动一页。对应单词forward。 按「ctrl」+「u」：屏幕往&quot;后&quot;移动半页。 按「ctrl」+「d」：屏幕往&quot;前&quot;移动半页。 按数字「0」：移到文章的开头。经过测试连按两下g，可行。0目前是跳到行首。 按「G」：移动到文章的最后。经过测试，shift+g，就是大写G，可行。 按「$」,shift+4：移动到光标所在行的&quot;行尾&quot;。 按「^」,shift+6：移动到光标所在行的&quot;行首&quot; 按「w」：光标跳到下个单词的开头。如果是在当前单词的中间，先跳到当前当前单词的开头。 按「e」：光标跳到下个单词的字尾。如果是在当前单词的中间，先跳到当前当前单词的字尾。 按「b」：光标回到上个单词的开头。与w跳转相反，功能一直。 按「#l」：光标移到该行的第#个位置，如：5l, 56l。实际测试，光标总是以当前位置为坐标，向右移动#个位置。 ​ 按 shift+ `：将光标中的小写字母转换为大写字母。 4）. 删除文字 「x」：每按一次，删除光标所在位置的&quot;后面&quot;一个字符。实际测试，删除光标包裹着的字符。 「#x」：例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符。实际测试，删除光标包裹着的外加后面的字符一共6个。 「X」：大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符。 「#X」：例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符。 「dd」：删除光标所在行。 「#dd」：从光标所在行开始删除#行 「dG」: 删除当前行到后面所有的行. 「d$」: 删除当前光标所在位置至行尾的内容 ​ 「d1G」: 删除当前行到第一行所有的行. 经过测试x和dd命令实际就是剪切效果。可以通过p命令粘贴。 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能。如果是粘贴行，则会在光标选中位置的行下方或者上方新建一行粘贴。 P：大写P是在光标左侧进行字符串粘贴或者上方进行行粘贴。 6）. 替换 「r」：替换光标所在处的字符。 先按一下r，开启替换模式，再按下实际需要改变的字符。 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。开启全局的替换模式。🌏 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次回复。 就是撤销上一次的操作。undo 8）. 更改 「cw」：剪切光标所在处的单词。相当于yw加上了剪切功能。 「c#w」：例如，「c3w」剪切更改3个字。实际测试失败，等以后换别的linux系统再观察。 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号。 「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 ☀4、Last line mode下命令简介 在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。从光标位置处开始查找。 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来。 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 F) 删除行 ​ 「:.,$d」:删除当前行至后面所有的行 G) 复制 ​ 「:.,$y」:复制当前行到最后一行的内容. H) 替换 ​ 「:.,$s/#//」:替换文本,当前行到最后一行,替换#字符为空. ☀5、vi命令列表 1、下表列出命令模式下的一些键的功能： 键 功能 h 左移光标一个字符 l 右移光标一个字符 k 光标上移一行 j 光标下移一行 Ctrl+f 向前翻屏 Ctrl+b 向后翻屏 Ctrl+d 向前翻半屏 Ctrl+u 向后翻半屏 ^ 光标移动至行首 $ 光标移动至行尾 0 数字&quot;0&quot;，光标移至文章的开头，目前是跳到行首。 G 光标移至文章的最后 g+g 光标移至文章第一行行首。 w 光标跳到下个单词的开头。如果是在当前单词的中间，先跳到当前当前单词的开头。 e 光标跳到下个单词的字尾。如果是在当前单词的中间，先跳到当前当前单词的字尾。 b 光标回到上个单词的开头。与w跳转相反，功能一直。 #l 光标总是以当前位置为坐标，向右移动#个位置。 i 在光标位置前插入字符 a 在光标所在位置的后一个字符开始增加 o 插入新的一行，从行首开始输入 ESC 从输入状态退至命令行状态。 x 删除光标后面的字符 #x 删除光标后的＃个字符 X (大写X)，删除光标前面的字符 #X 表示删除光标所在位置的&quot;前面&quot;#个字符。 dd 删除光标所在的行 #dd 删除从光标所在行数的#行 dG 删除当前行到后面所有的行. d1G 删除当前行到第一行所有的行. d$ 删除当前光标所在位置至行尾的内容 yw 复制光标所在位置的一个字 #yw 复制光标所在位置的#个字 yy 复制光标所在位置的一行 #yy 复制从光标所在行数的#行 p 单词字符向右粘贴，行向下粘贴。 P 单词字符向左粘贴，行向上粘贴。 r 替换光标所在处的字符。 R 替换光标所到之处的字符，直到按下「ESC」键为止。 u 取消操作 cw 剪切光标所在位置的单词。 c#w 剪切光标所在位置的#个字。 ctrl+g 列出光标所在行的行号。 #G 移动光标至文章的第#行行首。 ~ 将光标中的小写字母转换为大写字母。 Last line modle模式 键 功能 set nu 文件中的每一行前面列出行号。 #+回车 跳到#行行首。 /关键字,?关键字 查找字符 w 保存文件 q 退出 wq 保存并退出。 q! 强制退出。 「:.,$d」 删除当前行至后面所有的行 「:.,$y」 复制当前行到最后一行的内容. 「:.,$s/#//」 替换文本,当前行到最后一行,替换#字符为空. 2、下表列出行命令模式下的一些指令 w filename 储存正在编辑的文件为filename wq filename 储存正在编辑的文件为filename，并退出vi q! 放弃所有修改，退出vi set nu 显示行号 /或? 查找，在/后输入要查找的内容 n 与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。 ☀对于第一次用vi，有几点注意要提醒一下： 1、 用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。切换方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键。 3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:）","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://aner1001.gitee.io/tags/linux/"},{"name":"vi","slug":"vi","permalink":"http://aner1001.gitee.io/tags/vi/"}]},{"title":"养狗","slug":"生活知识/经验感悟/宠物/小狗","date":"2021-02-08T03:00:34.000Z","updated":"2021-02-08T03:00:34.000Z","comments":true,"path":"posts/2021/02/08/58ba0fe94918/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/58ba0fe94918/","excerpt":"🐶从小就喜欢狗，很喜欢柴犬。","text":"🐶从小就喜欢狗，很喜欢柴犬。 ☀食物 狗狗最喜欢吃肉。 鸡肉/牛肉干。 肉干可以自制也可以选择购买，和狗粮搭配起来给狗狗吃。 ☀注意 猪肉太油腻了狗狗吃了会有很大的体味儿。 ​ 🐾","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"抓老鼠","slug":"生活知识/经验感悟/抓老鼠","date":"2021-02-08T02:55:22.000Z","updated":"2021-02-08T02:55:22.000Z","comments":true,"path":"posts/2021/02/08/fe01419141dd/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/fe01419141dd/","excerpt":"🐭以前帮人用捕鼠笼抓过老鼠。","text":"🐭以前帮人用捕鼠笼抓过老鼠。 ☀捕鼠夹篇： 1.老鼠喜欢贴边走，墙角的拐角处。 2.老鼠经常出没的路径 3.夹老鼠一定要有耐心哦，夹子放好之后，不能老是走到附近去观望。 4.不能老是移动夹子的位子，夹子在一个地方放久了就一定会有收获的。 ☀诱饵篇： 最爱吃的是谷物类、瓜子、花生和油炸食品。 坚果是老鼠的最爱，因为它们喜欢磨牙，而坚果恰好又壳很硬。此外，坚果的味道也是它们最喜欢的。 坚果 坚果绝对是老鼠的最爱，因为它们du喜欢磨牙，而坚果恰好又壳很硬。此外，坚zhi果的dao味道也是它们最喜欢的。 肉类 老鼠也算半个肉食动物了，它们也喜欢吃肉。 水果 散发着甜甜的香味是水果是很好的诱饵。苹果，梨子之类的普通水果就可以把它们吸引过来。 奶制品 就是散发着浓浓奶香的东西，比如奶酪，面包，牛奶之类的。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"养乌龟","slug":"生活知识/经验感悟/宠物/乌龟","date":"2021-02-08T02:34:46.000Z","updated":"2021-02-08T02:34:46.000Z","comments":true,"path":"posts/2021/02/08/ec259c387299/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/ec259c387299/","excerpt":"🐢家里养了乌龟，需要细心照顾，记录一些心得经验。","text":"🐢家里养了乌龟，需要细心照顾，记录一些心得经验。 ☀养小乌龟方法 如果是巴西龟幼龟，少摸他少摸他少摸他，尤其是头部! 另外要保持湿润温暖的环境。 在喂食方面，饭粒、龟粮和虾米都可以作为食物。 小乌龟每隔3-4天需要更换用水，注意换水的水需要隔夜或放置两三天再换。 还要让小乌龟经常嗮太阳，避免其生病。 不要用透明的玻璃缸，小龟（如巴西和草龟）分不清玻璃和水（都透明）会一直向前爬，随后就出现掉爪和磨破皮—现发展成腐皮，不好治。 水不能太深—对小龟而言，尤其是养在玻璃缸里又深水的话，小龟一直向前游，游累了没歇脚的地方就会呛水。水刚过背即可。 温度保持在20-30度，温差不能过5度，过低过高的温度下龟没食欲，短时温差超5度，小龟易感冒、肺炎。 日光晒背要适度，不能暴晒，早上的阳光晒个十分钟即可。 喂食在水中进行，水龟即使在岸上得到食物也要跑回水中吞咽。 养小乌龟的时候不要用手摸来摸去的： 特别是刚买回的小乌龟，无论是大人还是孩子总想拿起来看看，小孩子更是要把小乌龟倒起身看，这样摸来摸去是不利于小乌龟的养殖的，小乌龟是冷血动物，手温远远高于小乌龟的适宜温度，这样会让小乌龟觉得不适或生病的，再加上人手上有各种各样的病毒细菌，对小乌龟都会形成伤害，代来疾病的伤害。 要注意给小乌龟晒太阳： 在太阳高照的中午，如果把小乌龟的龟缸搬到太阳下，我们会发现小乌龟会把龟壳浮出水晒太阳。这是因为小乌龟是冷血动物，它要通过吸收太阳的能量来维持体内的热量，另一个方面是太阳有杀菌作用，小乌乌龟通过太阳的照射有利于杀死背部的细菌，起到保护身体的作用，因此，要经常给小乌龟晒太阳，以利于小乌龟的健康成长。 小乌龟的壳要常洗： 要定期给小乌龟清理龟壳，可选用纯净水倒入碗中，然后用一个小软毛刷沾水，给小乌龟刷壳，这样能清理壳上的细菌，能有效防止病毒感染，小乌龟能吃能排，龟缸里的水不两天就污浊起来，不仅要给小乌龟经常刷洗，还要给水经常清理，及时换水和清除龟便。 小乌龟缸的水不要太深： 对于缸里的水一般高出三到五公分就可以了，它不像鱼那样水深了反而活的更好，小乌龟属两栖类的，它在陆地上也能呼吸，因此水多了不利小乌龟肺部呼吸。另外，在龟缸还要摆放些石头类的东西作为底部，不要只放进水，这样是不利于小乌龟成活的，在龟缸铺上石子，最好形成坡度，这样更有利于小乌龟活动。 ☀干养治病 我们所谓的干养呢，其实就是将龟离开水，保持身体的干燥，并放置在干爽的环境下修养疗伤的。正是因为龟出现了咬趾、腐皮腐甲、断尾、擦伤等等的外在伤病时，所采取的暂时人为干涉措施。为的是不让伤病继续恶化或者防止伤口感染，等待龟的自愈康复。同时呢要保证适宜的温度和湿度，每天可以泡澡1-2次，泡澡时龟会自行喝水的。在水龟有外伤时，干养护理其实是有利于康复。 干养不只是无水饲养，还需要垫一块湿毛巾（对于水龟）。另外水龟在无水状态是无法吞食的，每天要有半小时放在水里进行喂食。 生病水龟加温干养的方法 方法一：直接将病龟放置在设备齐全的陆龟箱内饲养。 方法二：采用套箱式加温，小箱放置在大箱内，大箱内用加热棒对水进行加温，大箱盖盖4/5或3/4保温。如果温度不够，在箱子的上方放置加热灯或者在箱盖上放置加热垫，建议外箱使用保温材料保温。小龟仔可以放置在小容器里，然后让小容器漂浮在加温水箱内。 泡澡：准备好泡澡容器和与饲养环境温度相同(或高出2～3℃)的水，然后将龟抓出来泡澡喂食。如果室内温度低于25℃，则需要在泡澡容器上方放置25W、40W或100W的加热灯加温。泡澡结束后将病龟的身体擦干再放回到加温箱中。如果室内温度低于15℃，建议先给室内大环境加温，然后再给龟泡澡，或将泡澡容器放到加温箱内给龟泡澡。 ☀水养加温用药 龟需要加温到30度不是一次性上到30度哦，比如今天开始加温水温20，那么我们每天增加两度，直到30度才开始治疗 ，这是为了给龟慢慢适应温度上升，不然容易造成应急反应，也容易失水而死 。 除了腐皮烂甲以外的疾病，需要24小时恒温30度才能治疗。 满足24小时恒温30度的前提下，水位到眼睛. 水每天加药，水臭就换，换水的时候换等温水。 注意事项：如果还没加温，请从常温开始，每天增加2度，直到30度才能投药。 ☀肠胃炎 ☀病因： 长时间喂食生肉，肉不太好消化。在肠胃里面变质。生肉、虾、黄粉虫。有几率造成，每个乌龟体质不一样。 冬天温度没超过20都，还再喂乌龟。 刚买回来就喂食。需要静养两天，保证不浮水。 ☀治疗办法： 将水莫过嘴巴。目的，逼他喝水。 一般用妈咪爱药，一斤水，一克药。 一般泡两三天换一次水。泡24小时，换一次水，没有排便，48小时。 乌龟肠胃炎过程中，绝对不能喂乌龟。 等到排便排成正常的粪便，黑色的粪便。只要不是白色的果冻状。说明快有点好了。治好之后不会浮水。有些乌龟可能是太瘦了，不会浮水。 、","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"有用的电话","slug":"生活知识/经验感悟/有用的电话","date":"2021-02-08T02:29:44.000Z","updated":"2021-02-08T02:29:44.000Z","comments":true,"path":"posts/2021/02/08/6ed975d42439/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/6ed975d42439/","excerpt":"☎️有用的电话记录","text":"☎️有用的电话记录 ☀投诉 假、过期发票 投诉电话：12366","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"山楂","slug":"生活知识/健康/山楂","date":"2021-02-08T02:16:27.000Z","updated":"2021-02-08T02:16:27.000Z","comments":true,"path":"posts/2021/02/08/4e2e6ebcc544/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/4e2e6ebcc544/","excerpt":"山楂好处真的多。(✪ω✪)","text":"山楂好处真的多。(✪ω✪) ☀功效： 很强的助消化功能 降血脂 软化血管 调节心肌、扩张血管、加大冠心血流量和降低血清胆固醇 帮助女性缓解痛经，还能排除体内淤血，还对一些跌打损伤造成的淤血有辅助治疗的作用。 还有很多研究实验证明，在山楂中能够提取到阻断亚硝胺合成的物质，山楂还可抑制黄曲霉素的对人体的致癌作用。 维生素C含量丰富抗氧化 促进脂肪类食物的消化。 平喘化痰。 ☀泡法： 每天使用的山楂剂量是25克 在泡山楂之前，先倒入少量开水，晃动晃动杯子后吧水倒掉，这样涮洗涮洗山楂，能除去山楂上附着的灰尘等脏东西。 开水温度最好在80°–90° 一般8–10片山楂干倒入400–500ML开水。 每天泡1—2次 当泡了几次山楂后，如果山楂发白了，说明山楂已经泡的够数了，应该及时丢弃山楂换新的，再喝没味了，也没有减肥、消食等功效了。 ☀搭配： 可降压的决明子 抗氧化的何首乌 减肥可以加上荷叶、生黄芪， 降血压或是清肝明目可以加上菊花。因此山楂每次泡水的剂量不能超过20克，菊花则不能超过15克。 ☀注意事项: ☀1.怎样喝山楂茶，才能既达到降血脂的目的，又不至于喝出胃病呢。 有些人喝了一段时间山楂茶后，还没来得及看到血脂下降，却先喝出了胃病。 患胃病的人一般不宜空腹喝山楂茶，特别是胃酸过多、胃炎、胃溃疡、反流性胃炎、反流性食管炎患者，不适合饮用。 面（吃多了）消食用麦芽，米（吃多了）消食用稻芽，肉（吃多了）消食用山楂。 想通过喝山楂茶降低血脂，不是短期内就能达到的。 要坚持每天饮用，日久天长才能达到降血脂、软化血管的作用。 饭后半小时再喝山楂水 ☀购买 尽量选择颜色亮一些的 颜色发黄的山楂说明晒干之前就不新鲜了。 购买山楂请您关注山楂的“长相”；一般长相扁圆的相对较酸，甜蜜的山楂长相比较正圆。 山楂皮上有很多的点儿，购买时可以适当关注，一般山楂上果点紧密且粗糙的果实偏酸，小巧且光滑的果实偏甜一些。 购买山楂的时候可以询问产地，一般河南与河北的山楂相对而言比较偏甜；而东北和山东的山楂则更为偏酸。 比较甜的山楂一般果肉呈现白色、红色或者黄色；绿色果实相对会更酸一些。 言说于此，您会发现：山楂是一种不错的水果，也可以说是一种不错的零食，建议您吃，更建议您要健康食用。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"}],"tags":[]},{"title":"泡脚","slug":"生活知识/健康/泡脚","date":"2021-02-08T01:54:36.000Z","updated":"2021-02-08T01:54:36.000Z","comments":true,"path":"posts/2021/02/08/8e8a521c82d3/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/8e8a521c82d3/","excerpt":"喜欢泡脚(￣▽￣)~*","text":"喜欢泡脚(￣▽￣)~* 知识都在百度百科，去原站阅读。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"}],"tags":[]},{"title":"牛奶","slug":"生活知识/健康/牛奶","date":"2021-02-08T01:03:00.000Z","updated":"2021-02-08T01:03:00.000Z","comments":true,"path":"posts/2021/02/08/f613d1b27cfe/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/08/f613d1b27cfe/","excerpt":"🌹喜欢喝牛奶，天天喝，所以对牛奶要有一些了解和认知。才能有更好的选择。知道自己要喝什么。","text":"🌹喜欢喝牛奶，天天喝，所以对牛奶要有一些了解和认知。才能有更好的选择。知道自己要喝什么。 因为平时冬泳、洗冷水澡、跳绳等锻炼习惯，消耗比较大，所以本人选择全脂的。 ☀全脂牛奶 全脂牛奶就是普通牛奶，其成分接近与纯牛奶，含乳脂肪在3.1%以上，其是以生鲜牛乳为原料，经标准化，均质，巴氏杀菌或超高温杀菌，冷却后灌装制成的产品。全脂奶粉 它基本保持了牛奶的营养成分，适于各种年龄消费者，尤其适于中青年。 ☀脱脂牛奶 脱脂牛奶是指以生鲜牛乳为主要原料，经过脱脂，均质，巴氏杀菌或超高温杀菌，冷却后得到的产品，其脂肪含量在0.5%以下。脱脂奶粉中的蛋白质、碳水化合物比一般奶粉高1/3左右，钙、维生素、磷的含量也比一般奶粉高。而脱脂奶粉中脂肪含量很低，热量也比一般奶粉低得多。脱脂乳粉 牛乳脱脂后加工而成，口味较淡，适于中老年、肥胖和不适于摄入脂肪的消费者。 ☀区别 全脂奶粉营养很高，营养价值更全面，因为它包含了好多脂溶性维生素，并且味道也更好，所以不能说全脂奶粉没有脱脂好，从营养价值、从能量的大小都要比脱脂奶粉好。 1、营养含量不同：国际营养科学联盟亚太临床营养学会食品安全中心主任李铎教授解释说，全脂牛奶含有大约3%到3.5%的脂肪，低脂牛奶含有1.5%到1.8%的脂肪，脱脂牛奶含有不到0.5%的脂肪。“全脂牛奶含有牛奶的所有成分；脱脂牛奶除去了对人体不利或有害的脂肪，保留了牛奶中对人体有益的营养成分，如蛋白质、维生素、矿物质、微量元素等。” 2、适用人群不同：对于我国消费者，李教授建议说，婴幼儿可以饮用全脂牛奶，健康成年人应喝脱脂牛奶或低脂牛奶。患有高血脂、高血压、血栓等心血管系统疾病，以及糖尿病、肥胖等代谢性疾病的人应该喝脱脂牛奶。 ☀注意事项 牛奶和茶是不可以一起喝的。因为一项最新研究提出，向提神的茶水中加入牛奶，或茶与牛奶同时喝，会破坏茶的所有有益健康的成分。 试验显示，虽然茶通过增加动脉壁的收缩能力提高了血流速度，但牛奶却完全阻碍了这一有益健康的效果。 因此喝茶一小时左右后再喝牛奶，这样会利于牛奶的吸收。 酸奶和牛奶可以一起喝。 ☀研究和建议 保持健康体重 1、常喝牛奶好处多多。据国外媒体9月20日报道，《美国临床营养学杂志》刊登以色列一项最新研究发现，常喝牛奶能保持健康体重，每天喝1杯牛奶，减肥效果更佳。 2、这项为期两年的减肥研究涉及300多名40～65岁的男女参试者，所有参试者体重超标或近乎超标。研究期间，参试者都进食低脂肪低碳水化合物地中海饮食。 3、研究人员发现，每天喝一杯牛奶的参试者比不喝牛奶的人减肥效果更好。每天喝牛奶最多的成年参试者(每天近两杯牛奶)6个月之后，钙摄入量最多的参试者2年后体重减轻5.4公斤，相比之下，通过牛奶及奶制品摄入最低量钙的参试者只同期仅减重3.1公斤。研究还发现，牛奶或奶制品每增加6盎司(相当于170克牛奶)，6个月可平均成功减肥4.5公斤。 4、除了钙之外，研究人员还发现，维生素D水平也是影响减肥成功的一大独立因素。这与早期研究结果不谋而合。牛奶及奶制品是维生素D的重要食物来源。 5、研究人员建议，吃对食物、积极锻炼、每天满足3杯脱脂或低脂牛奶的推荐饮用量，有助于保持健康体重。另外，最好选择脱脂牛奶，因为脱脂牛奶含有包括钙和维生素D在内的 9大重要营养，而且8盎司(约合227克)脱脂牛奶含热量仅为80卡路里。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"}],"tags":[]},{"title":"友好的食物","slug":"生活知识/健康/友好的食物","date":"2021-02-07T07:34:52.000Z","updated":"2021-02-07T07:34:52.000Z","comments":true,"path":"posts/2021/02/07/ad96e2a5bad4/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/ad96e2a5bad4/","excerpt":"😋活出健康，也好吃得健康！","text":"😋活出健康，也好吃得健康！ 荞麦燕麦小米 降脂降压降糖","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"}],"tags":[]},{"title":"不能一起吃的食物","slug":"生活知识/健康/不能一起吃的食物","date":"2021-02-07T07:20:20.000Z","updated":"2021-02-07T07:20:20.000Z","comments":true,"path":"posts/2021/02/07/31160378d01a/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/31160378d01a/","excerpt":"💥食物之间的化学反应，吃了就爆炸。请爱护:💓:自己身体。","text":"💥食物之间的化学反应，吃了就爆炸。请爱护:💓:自己身体。 酸味水果不能和牛奶一起吃。 大多味道发酸的水果中含有大量果酸，牛奶中所含的蛋白质遇果酸会凝固，大家可以自己在家试一试，很有趣，马上就结块了。因此吃李子，桔子，杏子等酸味水果时不宜喝牛奶或者食用蛋白质食物（奶油，含大量奶油的奶霜等）。倒不是说组合吃会导致什么生命危险，但是肠胃虚弱的人会腹痛腹泻，严重会呕吐，长期这样吃对消化系统和肾脏也不好。 螃蟹和柿子 这样吃要倒下，食物相冲是会比较危险。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"}],"tags":[]},{"title":"个人身体情况","slug":"生活知识/健康/个人身体情况","date":"2021-02-07T07:20:20.000Z","updated":"2021-02-07T07:20:20.000Z","comments":true,"path":"posts/2021/02/07/bb06163b0a54/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/bb06163b0a54/","excerpt":"个人身体情况的总结和治疗预防攻略。 程序员要有一个好的身体才行,才能敲出上万行牛逼代码!争取一年比一年好！👍","text":"个人身体情况的总结和治疗预防攻略。 程序员要有一个好的身体才行,才能敲出上万行牛逼代码!争取一年比一年好！👍 ☀总结： ☀【1】腰椎间盘膨出 长期久坐以及不健康的坐姿导致。 ☀改善方法： 倒挂是有助于长高的。还可以让脑部暂时有更多的血液供应，促进血液循环。因为这种运动会刺激脑垂体分泌更多的生长激素促进生长（原理：倒挂时血液汇集大脑，垂体血液供应充足，功能增强）。同理，倒挂会拉开椎间隙，使身体增高，相当于做中医牵拉理疗。倒挂还能使面部皮肤越来越好。但是一切事物不可走极端，每天倒挂不能超过1小时，关键在坚持。一天长时间倒挂会导致脑部长期充血，以后老了很容易出现头痛症状。年龄比较大的人千万别做。以及有心脑血管病的和高血压的不能做此运动。对颈椎和腰椎间盘突出或膨出有一定改善，最好是吃饭2小时后倒挂，每次控制在10分钟以内，我就是这样做的，近两个月了，腰椎不像以前那样累不得了，但一定要坚持才会起效。 中医按摩。 食物疗法。 游泳。 视频锻炼学习： ☀【2】超重 目前是24.1。基本不超重。继续减下去。​​，已小于24😄 1、体重指数（体重(kg)÷身高(m)的平方）≥24为超重，≥28为肥胖。 2、饮食宜低脂肪、低糖、低盐，控制主食量，辅以适量优质蛋白（鱼、蛋、奶类等）以及 各种蔬菜。 3、加强运动消耗多余脂肪。可依年龄及身体状况，选择适合自己的运动方式和运动时间， 以达到减轻体重的目的。 4、推荐运动三要素，频率：每周至少三次；强度：心率达到（170－年龄）次/分；时间： 平均每次半小时以上。运动以微汗为宜。 ☀【3】血压正常高值 目前,收缩压:132,舒张压:83. 根据我国流行病学统计，血压水平120-139/80-89mmHg的人群，10年后心血管风险比血压水 平110/75mmHg的人群增加1倍以上；血压在此范围的中年人群，10年后分别有45%和64%成为 高血压患者。建议改变生活方式，低脂、低盐饮食，戒烟限酒，坚持适量运动，保持正常体 重，减少精神压力，保持心理平衡等，定期监测血压，以免发展为高血压。 血压高怎么办？参考链接 血压高的症状 1、早期表现：早期多无症状，偶尔体检时发现血压增高，或在精神紧张，情绪激动或劳累后感头晕、头痛、眼花、耳鸣、失眠、乏力、注意力不集中等症状，可能系高级精神功能失调所致。早期血压仅暂时升高，随病程进展血压持续升高，脏器受累。 2、脑部表现：头痛、头晕常见。多由于情绪激动，过度疲劳，气候变化或停用降压药而诱发。血压急骤升高。剧烈头痛、视力障碍、恶心、呕吐、抽搐、昏迷、一过性偏瘫、失语等 3、心脏表现：早期，心功能代偿，症状不明显，后期，心功能失代偿，发生心力衰竭。 4、肾脏表现：长期高血压致肾小动脉硬化。肾功能减退时，可引起夜尿，多尿、尿中含蛋白、管型及红细胞。尿浓缩功能低下，酚红排泄及尿素廓清障碍。出现氮质血症及尿毒症。 5、动脉改变。 6、眼底改变。 血压高的原因 引起血压升高是有很多原因的，下面，我们就一起去看看哪些因素会引起血压升高。 1、肥胖是引起血压升高的重要原因。脂肪过多挤压血管，当管道被挤压以后，动力源需要加大动力才可能使原来的循环达到流通，动力源动力加大，管道压力也会随之加大，就形成了高压。 2、由其他疾病引发的血压升高。例如脑血管疾病、肾脏疾病、心脏方面的先天及后天的缺失等疾病。它们会引起血凝过高等等原因，从而导致血压升高。 3、血液中缺乏负离子也是导致高血压的重要原因。 4、摄入食盐多者，高血压发病率高。建议不要吃高盐和厚味食物及烟酒。 5、精神紧张是造成高血压的一大因素。现在，我们中年人大部分在单位里都是骨干，青年人也都是重任在肩，而且生活中也会发生很多事情，都会对中青年人精神上产生一种压力。 6、人体缺钙也会引起高血压。膳食中钙不足可促使血压升高。 7、大约半数高血压患者有家族史。 ☀降低办法： (一)合理膳食 如果血压升高的话，大家要格外注意自己的饮食习惯，要注意定时定量，不可过饥过饱，暴饮暴食。各种食物搭配合理，不可偏食。 1、三餐：注意自己的三餐饮食，要保证定时定量、少量多餐。 2、清单低油：并且三餐要避免吃高热能食物，并且少食动物脂肪和动物内脏。晚餐尽量吃的清淡，因为过量油腻食物会诱发中风。要荤素搭配，合理配比，多吃一些粗粮。 3、低盐：每天严格控制吃盐量，尽量少吃腌制品，例如腌肉、咸菜等含盐量较高的食物。 4、高钾：富含钾的食物进入人体可以对抗钠所引起的升压和血管损伤作用，可以多吃一些富含钾的食物，例如冬菇、黑枣、杏仁、核桃、花生等。 5、果蔬：每天人体需要b族维生素维生素c可以通过多吃新鲜清淡，易消化含水份多的蔬菜及水果来满足，有人提倡每天吃1-2只苹果有益于健康水果还可补充钙钾铁镁等，柿子、核桃、大蒜、芹菜、荠菜、绿豆等高纤维食品也具有降压作用。 6、补钙：如果发现自己的血压有所升高，可以适当补充一些钙，可以吃一些钙片或者喝些牛奶。因此，及早注意饮食中钙的供应和吸收，对高血压防治是有益的。含钙较多的食物有大豆及豆制品，奶及奶制品，鱼、虾、蟹、蛋、黑木耳或白木耳、紫菜、雪里红等，这些在日常生活中均应注意适当摄入。 7、补铁：研究发现，当血压有所升高时，补充一些铁元素可以有效降低血压。当自己的血压有所升高时，可以多吃一些富含铁的食物，例如木耳。 8、饮水：当血压升高时，可以适当和一些茶水，因为茶水有很多好处，它可以软化血管，使血液流通，也可以有效控制血压，长期服用茶水对人体是有好处的。但是，不建议喝很浓的茶水。 (二)适量运动 运动对于降低血压有很好的功效。运动不仅可以促进血液循环，降低胆固醇的生成外，并能增强肌肉、骨骼与关节僵硬的发生。运动能增加食欲，促进肠胃蠕动、预防便秘、改善睡眠。有持续运动的习惯：最好是做到有氧运动，才会有帮助。有氧运动同减肥一样可以降低血压，如散步、慢跑、太极拳、骑自行车和游泳都是有氧运动。 (三)戒烟限酒 烟叶内含有尼古丁，它会刺激兴奋中枢神经和交感神经，使心率加快，同时也促使肾上腺释放大量儿茶酚胺，使小动脉收缩，导致血压升高。并且大量饮酒也是对什么有百害而无一益的，大量饮高浓度的酒精会导致动脉硬化，加重高血压。 (四)心理平衡 在生活中如果出现精神压力大的时候，其心理表现是紧张、易怒、情绪不稳，这会使血压升高，因此，当心理压力大的时候，选择倾诉是一个很好地办法。 (五)自我管理 人要对自己负责任，对自己的身体负责，也是对家人和朋友负责。我们每天要坚持测量血压，并给自己制定一个降压计划并持之以恒的坚持下去。 (六)按时就医 如果出现出现眼花，头晕，恶心呕吐，视物不清，偏瘫，失语，意识障碍，呼吸困难，肢体乏力等严重不适的症状，立即到医院就医。如病情危重，请求救120急救中心。 结语：如果血压升高的话，大家要格外注意自己的饮食习惯，要注意定时定量，不可过饥过饱，暴饮暴食。各种食物搭配合理，不可偏食。要低盐少油饮食，尽量少吃盐分很高的食物。多吃一些富含维生素B和维生素C的蔬菜水果，多食具有降压作用的食品。 ☀【4】淋巴细胞百分比增高 值：52.0 正常值：20 – 50 继续观察。 提示可能存在某些病毒性感染，若有症状请专科明确诊断，治疗原发病，无症状者可动态观 察。 ☀【5】甲状腺结节 可以去医院做一下检查。 甲状腺左侧叶见数枚边界尚清晰的低回声，最大约3×2mm是临床常见的病征，恶性病变虽不常见，但性质难以鉴别。建议您及时去医院专科做进一步检查，以便明确诊断。 ☀【6】前列腺钙化灶 建议定期超声检查，观察其大小变化。 预防 1.保持良好心情，培养兴趣爱好，树立坚定的信心，消除焦虑情绪，转移对前列腺疾病的注意力。 2.饮食注意，忌辛辣食物，忌烟酒，多吃水果蔬菜，饮食营养丰富，养成良好的生活习惯，增强抗病能力。 3.注意劳逸结合，防止过度疲劳，适当进行体育锻炼，尤其是加强盆腔肌肉的运动，避免长期久坐、骑自行车等。 4.性生活要有规律，避免过少和过频。 5.日常生活多饮水，多排尿，保持大小便通畅。 ☀【7】肾结晶 肾结晶可单发或多发，结晶梗阻可伴肾盂积水。小的结晶，不出现症状时可不处理。平常出汗较多或者运动后出汗多的患者，如果不注意大量饮水，不仅不会自愈，反而可能会肾结晶进一步堆积，形成较大的肾结石。较大或出现绞痛及有肾盂积水时，请到泌尿外科治疗。 ☀自愈办法： 肾结晶在有些时候可以自愈。肾结晶是指还没形成肾脏结石的肾盏内结晶，或者十分微小的肾结石，有自行排出体外的可能。往往肾结晶是体检时B超或CT发现，通常不需要治疗。 多喝水，多排尿。每天至少2000~2500毫升的白开水。 多做一些跳跃运动，可以促进结石的排出。跳绳💫。 少吃含草酸盐较多的蔬菜，例如菠菜、芹菜等。少吃一些海鲜类豆制品。 最后也可以口服排石颗粒治疗。 ☀【8】色弱 不影响生活，没事。 1、是对颜色的辨认能力降低，属于色觉异常。 2、与色觉相关的职业选择受限。 ☀【9】屈光不正 近视导致，应该没事。 注意用眼卫生，定期眼科随访。 ☀历年体检报告清单 报告 2020年","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"}],"tags":[]},{"title":"车","slug":"生活知识/经验感悟/车","date":"2021-02-07T07:15:47.000Z","updated":"2021-02-07T07:15:47.000Z","comments":true,"path":"posts/2021/02/07/19d308c0e863/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/19d308c0e863/","excerpt":"🚗 车的选购心得，以后可能会用到。","text":"🚗 车的选购心得，以后可能会用到。 ☀提新车步骤 ☀携带物品 身份证、驾驶证、银行卡。手电筒。几百元现金。 多看一眼合同，对数字。 办保险。注意生效时间。从提车开始。 ☀检查 车子停在室外，光线比较好。容易看凹陷和划痕。用手电筒检查车漆。斜对着日光多换几个角度看看。有一块漆面反光和其他漆面不一样，可能做过油漆。 1.车子的保险杠，比较容易刮。 检查接缝大小： 检查门的开关声音大小，看看每个门声音是否都一样。 检查轮胎，是否有轮胎毛。检查轮胎的胎压，183~189，检查刹车片。新车0磨损。 2.反光镜的位置。 3.生产日期 副驾驶B柱下面。汽车制造年月，名牌。所有生产日期都不能超过，车子名牌的生产日期。 如果配件还生产得晚，说明配件是换过的，不是原装配件。 国产车超过6个月，进口车超过1年，基本时间有点长了。算是库存车。 每一块玻璃上面，标注的生产日期。点在前，上半年生产，用数字7减去这个点。点在后面，下半年生产，用13减去点的数量。 轮胎生产日期：后面数字代表年份，前面数字代表周数。 检查安全带的生产日期：直接看号码。 4.机油尺 打开发动机盖子。抽出机油尺。打开机油盖，看有没有乳化现象。重点检查机油。 机油乳化。顶多发黑。 5.合格证 检查车子的合格证。拿到说明书，排放标准的证件，开好发票。 发票4联。盖章。 车辆一致性证书。 交强险和商业一致性保单。 三包凭证。 维修保养手册。 看PDI检测单，并且拍照。 使用说明书。 环保标志。 购车合同。 贷款合同。 两把钥匙。 临牌。 对好车架号： 6.随车工具 打开后备箱，检查随车工具。三角警示牌，备胎，换台工具。 7.检查灯光和电子设备。新车行驶100km以内，公里数越少越好。检查内饰有没有被磨损。天窗附近有没有漏水迹象。打开天窗摸一下车顶。检查4个车窗附近的座椅和地毯有没有潮湿情况。泡水情况一般不会有。 启动车子，开启电子设备。 空调、音响、座椅加热、等各功能。 车灯、检查漏油。 检查高配的配置是否有。 ☀贴膜 选择大品牌，颜色不要太深。 太阳膜是上牌以后再贴。前挡风玻璃也要贴。前排太阳膜一定要是浅色的。不然晚上倒车会啥也看不清。 威固、龙膜、3M、强生。 不要选透光率太差，太暗的膜。 ☀车漆养护 打蜡 镀膜 镀晶 隐形车衣 ☀行车记录仪 ☀习惯 新车异味大，多开门窗，多通风，晒晒太阳。 研究用户手册。 车子隐藏功能，以及保养知识点。 ☀部件挑选 ☀座椅 织物座椅 以纤维为主要材质，大多是棉纺混纱的纺织产品，优点就是比较个性化，非常透气，所以夏天坐久了也不会太热，冬天坐上去也不会冷冰冰的。而且织物座椅不易损坏、不易老化，摩擦系数还比较大，像是宠物动爪子也不会一下就损坏很严重，而且织物座椅是纤维材质，摩擦力更大，坐着更稳，不容易出现屁股打滑等现象。但是织物座椅的缺点也挺明显的，就是不耐脏、不好清洁打扫卫生，有时候不小心沾上什么东西或者是洒了饮料，清洁起来非常麻烦。还有一个很多人都不喜欢它的原因是视觉上看起来比较廉价，就是不怎么上档次，撑不起面子，所以很多人都不选择织物座椅。 ☀发动机 德系和日系都很耐用。 ☀天窗 ☀全景天窗 夏天比较鸡肋。只有伯伯一层沙，需要加上遮阳帘，不然头顶太晒。 天窗使用时间长了之后就会有异响。天窗使用频率并不高。夏天，寒冬、下雨下雪天，都不可能使用。需要结合自己的使用频率。 ☀轮胎 凯美瑞后期可以换注重舒适和噪音表现的轮胎会有更大的提升。 ☀功能 ☀上坡辅助 原理： 通过行车电脑控制刹车，在脚离开刹车一瞬间，帮你把车子刹住，让他不忘下面溜，然后等你的脚到油门上，把油门踩下去的时候，获得动力之后，上坡辅助自动解除，车子就会往前跑了。 ☀自动驻车 AUTO HOLD 当车子刹住时就会自动驻车，相当于省去了挂N档，拉手刹的步骤。实际切断变速箱输出动力，提高了一点油温。 驾驶员解开安全带，打开车门，车辆熄火操作，自动驻车会自动解除，并且会给车子自动打开电子驻车制动。 堵车、倒车时，自动驻车不好用。用处不多，为了长时间停止时方便让踩刹车的脚休息设计，省去挂空挡，拉手刹的麻烦。 ☀自适应巡航 ☀自动启停 虽然省油，伤电瓶和增加发动机磨损。既不省钱还伤车，不推荐开启。 ☀A/C a/c是空调机(air condition)的缩写。控制空调压缩机制冷用，提供冷风。冬天吹暖风，是通过冷却液传递热量，水暖式供热，冬天开车不需要开启A/C。 开暖空调时，开(A/C)车窗不容易起雾，可以让车子保持干燥，起到除湿的作用。**起雾原理：**车内水蒸汽，遇到冷玻璃凝结成雾。 **A/C除湿原理：**制冷道具吸热，将空气中的水蒸气凝结再制冷道具中，达到除湿的作用。 **冬天玻璃除雾原理：**开启前挡风玻璃加和后挡风玻璃加热，将凝结的雾重新变为水蒸气，开启A/C制冷机利用吸热原理吸收空气中的水蒸气。达到除雾的目的。开启除雾的时候，会自动开启A/C。 偶尔开A/C对空调系统还有一定的养护作用。压缩机除了制冷剂还有冷冻油，偶尔开启，带动有助于各个制冷机部件的润滑。 最好每两周启动一次，每次至少5分钟。 ☀养护 最重要的还是按时保养维护。 冬天不需要热车，点着火直接上路就行。视频 ☀洗车 ☀车漆保护 ☀打蜡(推荐) 时间较短。性价比高。每两个月打一次，方便打理，看起来更靓的效果。 自己动手有乐趣。对车有更多的了解。锻炼身体。 最好的蜡，也就100多元。打蜡，越薄效果越好。 ☀镀膜 选择镀膜品牌：确认主要成分：无机硅，氟高分子材料。 施工时间长：2~6个小时。 保护时间：1年。（实际到不了那个时间） 成本：800~2000. 三天内不能洗车。 ☀镀晶（不推荐） 成本：1500~6000 对环境要求高，看师傅技艺，影响镀晶效果。 镀晶施工会磨损车漆，镀晶前需要抛光车漆，磨砂打磨，一般一辆车可以承受7次左右的抛光。镀晶使用寿命在两年不到，次数太多反而适得其反，上海车漆，停止镀晶后车漆老化更快，缺乏亮度和隔膜支持。 ☀镀膜（不推荐） 成本太高。劣质膜留胶，不便清理。 ☀油液 ☀冷却液 也叫防冻液。 盖子上有温度计标识的壶。液体颜色红、绿、蓝。 使用时间：2年或4万公里，5年或10万公里。 冷却液冰点最好比当地气温低10度以上。 保持在max和min之间。 ☀玻璃水 蓝色盖子。 买的时候注意冰点。 车上常备一瓶。农夫山泉备用。 ☀机油 发动机旁边。 新机油金黄色的粘稠液体，旧的机油黄褐色或者黑色。 矿物油一般5000公里，半合成7500公里，全合成1万左右。 更换一次3到5升。 保持机油尺度最低和最高。油齿要擦干净再量。 根据机油厂标注，厂商意见、车内指示器考虑机油是否更换。 利用发动机运转时间计算机油寿命。 ☀制动液，刹车油 有两个括号的壶 金黄色，比机油颜色更加浅，浓稠度更低。 一般2年或者4万公里换一换。潮湿的地方提前换。 对于品牌有严格的规定，写在盖子上要看清。 ☀变速箱油 自动变速箱油一般为红色。5~8万公里换一换。 手动为黄色。4~6万换一换。 保养手册为准。每一款变速箱都有专用的变速箱油。 ☀空调 车子使用少，滤芯每年3月份换一次。 车子使用多，每年10，11月份，每年3，4换一次。 更换滤芯保护蒸发箱。 可以自己更换。 ☀下雨天 雨水一般呈现酸性，下雨之后如果不及时清理，开车期间随着表面温度升高，漆面上的雨水，它的酸性浓度也会升高，很可能就会影响到漆面，如果再严重些会形成一些擦不掉的雨水痕迹，所以雨后对其面对漆面的清理很重要。 1、干抹布擦：车内时常准备一块干的抹布，鹿皮巾比较好因为吸水性强，可以短时间内把雨水吸走。 2、清水抹布：雨水清理以后用一块清水潮布擦拭汽车表面，尽量一个方向擦不要来回擦。这样可以稀释掉残留的酸性物质。 3、给车打蜡：平时如果有条件的话可以定期给车打打蜡，汽车漆面保养中不可缺少的东西，因为这样可以尽量减少雨水在汽车表面的吸附量。 ☀天窗保养 天窗胶条，7~8年更换。 视频教程1 视频教程2 工具： 强力除尘罐+软管 油污去除剂 高效百里润滑脂 高效矽质润滑剂 车窗润滑剂 步骤： 疏通排水孔。使用除尘罐，叶子板和门板之间能够听到喷气的声音，倒水测试。 清理防尘网和滑轨边缘灰尘和脏东西。或者油污去除剂，喷在所有需要清理的地方，等待30秒，搭配毛刷和毛巾，擦干净。再用水冲去小颗粒物。最后擦干净整个天窗。使用干毛巾吧各个缝隙擦干。 清理滑轨，润滑脂变黑，划归露出金属说明润滑效果已经失去作用。毛巾擦干净润滑脂。 喷新的润滑脂，滑轨里面和周围，防尘网的弹簧。如果导轨是金属材质，使用百锂润滑脂。如果是塑料的，使用高效锡质润滑剂。根据天窗中的不同结构使用。 喷好之后，来回滑动天窗两三次，再喷一边，这样就比较均匀。 天窗橡胶密封胶条，喷上去，等2分钟，等胶条吸收后，再擦干净。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"好习惯","slug":"生活知识/健康/好习惯","date":"2021-02-07T06:42:07.000Z","updated":"2021-02-07T06:42:07.000Z","comments":true,"path":"posts/2021/02/07/7324327824ca/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/7324327824ca/","excerpt":"💪养成好习惯，才能有一个健康的身体。","text":"💪养成好习惯，才能有一个健康的身体。 ☀眼睛： 每天两次眼保健操，有助视力健康。 ☀睡觉： 有午睡习惯不会老。 最佳睡眠时间是晚上10点~清晨6点。 ☀服药： 服用胶囊应以冷水吞服。 睡前30分钟先服药，忌立即躺下。 ☀不良症状引起： 掉发：熬夜、压力、烟酒、香鸡排、麻辣锅、油腻食物。调味过重的料理。 常吃宵夜，会得胃癌，因为胃不到休息。 ☀喝水： 每天2500ml水，预防结石。 喝茶抗癌。 ☀牙齿 每天中午吃完饭，也会刷牙。 口腔中致龋细菌代谢会产生酸性物质，如果平时再频繁进食酸性食物（包括果汁和苏打水）.会加速龋齿的发生。 因此每个人都需要对酸性食物提高警惕，才能更好的维护口腔健康。 强酸性食物包括蛋黄、乳酪、甜点、白糖、金枪鱼、比目鱼、奶酪、西点、柿子、乌鱼子、柴鱼等；动物性食物；甜食；精制加工食品（如白面包等）；油炸食物或奶这几类。 人类的食物可分为酸性食物和碱性食物。判断食物的酸碱性，并非根据人们的味觉、也不是根据食物溶于水中的化学性，而是根据食物进入人体后所生成的最终代谢物的酸碱性而定。酸性食物通常含有丰富的蛋白质、脂肪和糖类。含有钾、钠、钙、镁等元素，在体内代谢后生成碱性物质，能阻止血液向酸性方面变化。从营养的角度看，酸性食物和碱性食物的合理搭配是身体健康的保障。 有了蛀牙怎么办？（超全攻略，必须收藏）","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"}],"tags":[]},{"title":"上班带饭攻略","slug":"生活知识/做饭/上班带饭攻略","date":"2021-02-07T06:21:07.000Z","updated":"2021-02-07T06:21:07.000Z","comments":true,"path":"posts/2021/02/07/f64479e11d50/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/f64479e11d50/","excerpt":"上班带饭一个是健康，方便，还有一个是省钱。但是比较花时间。 干IT的，写代码、研究技术很忙，最后发现还是买着吃这吃节省时间。😝。","text":"上班带饭一个是健康，方便，还有一个是省钱。但是比较花时间。 干IT的，写代码、研究技术很忙，最后发现还是买着吃这吃节省时间。😝。 ☀饭菜建议： 蒸、红烧、炖等，这些方法烹饪的菜肴在微波炉加热后，不易变味和变色。 相对绿色蔬菜，茄果类蔬菜不易变质，微波炉加热后也不易改变菜肴的色和香。 要带的蔬菜在烹调时炒至六七分熟就行。 西红柿炒鸡蛋、烧茄子等经典菜式都比较适合“带饭族”。 不宜带鱼类、海鲜类，一方面鱼和海鲜隔夜后易产生蛋白质降解物，会损伤肝、肾功能。 另一方面，也不宜带凉拌菜，关键是凉拌菜不宜隔夜吃。凉拌菜由于加工的时候就受到了较多污染，即使冷藏，隔夜后也很有可能已经变质，所以不宜将隔夜的凉拌菜放入饭盒内。 特别提示的是不宜带含油脂高的食品。回锅肉、糖醋排骨、肉饼、炒饭等最好别带，因为它们含油脂太高了，相对低油脂食品，这些东西更容易变质不容易保鲜。 多烧点骨头排骨，对骨骼有好处。 早饭：蒸紫薯、蒸玉米。 汤类：紫菜青菜蛋汤。 ☀食用安全: 杀菌隔菌保安全 罐头杀菌隔菌保存的原理就可以用在带饭的事情上，只是需要两三个能耐热又能密封的饭盒，大小要合适，让食物盛装到三分之二或四分之三的满度最好。 具体程序是这样的：先把洗净的饭盒里外用沸水烫一遍，尽量杀死细菌；再把刚出锅的大米饭装进去，然后马上把饭盒盖紧，（可以先不扣严），等温度降到不烫手的程度，确认把盖子扣严，再立刻放到冰箱里。这样，取出来的时候，你会发现塑料饭盒的盖子凹下去，其他密闭饭盒或玻璃罐的盖子很难打开，因为盒内的空气受冷收缩，造成负压，外面的细菌想进去都很难。带着这样的饭去单位，放半天是很安全的。如果发现盖子鼓起来，那可就要小心了，很可能是细菌活动的结果（装菜亦如是）。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"做饭","slug":"生活知识/做饭","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%9A%E9%A5%AD/"}],"tags":[]},{"title":"关注成长","slug":"生活知识/教育/关注成长","date":"2021-02-07T06:03:57.000Z","updated":"2021-02-07T06:03:57.000Z","comments":true,"path":"posts/2021/02/07/d00b7dcc6185/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/d00b7dcc6185/","excerpt":"收藏一些关注小孩成长的文章。","text":"收藏一些关注小孩成长的文章。 不让孩子早熟 身体 一定防范。 🔗女孩子早熟发育一些可能的原因 孩子穿裤子不能露脚踝，容易得风湿。 掌握一门立根的技术。 孩子走失的防范: 配上电话(存自己的手机号) 走失后不要着急，打电话，万一电话有故障(没电或者坏了) 就叫旁边的路人打，旁边路人打电话时悄悄说不让孩子听到（是坏人，立马走） 走失后尽量留在原地，如果走失的地方，太阳很大，找个阴凉点的地方坐好，沉着冷静。 别人问就说走失了，如果别人要求要带到一个地方去找爸妈，拒绝，要求他打电话。 戴着警察帽子不一定是警察，还是先要求打电话联系我，等通完电话，先问孩子是爸妈让他安心，确认后，和警察沟通好，在哪里接。 有路人来问就回答我走失了，希望可以得到电话帮助，但是不会跟他走，就留在原地。 要是别人硬是拉着走，就大声喊救命，跟旁边路人说他是不认识的叔叔，想带走我。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"教育","slug":"生活知识/教育","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E6%95%99%E8%82%B2/"}],"tags":[]},{"title":"学习方法","slug":"生活知识/经验感悟/学习方法","date":"2021-02-07T03:06:27.000Z","updated":"2021-02-07T03:06:27.000Z","comments":true,"path":"posts/2021/02/07/24b1e5b8417d/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/24b1e5b8417d/","excerpt":"📐学习方法超级重要。不光是对于程序员，对于所有在学习的人们。","text":"📐学习方法超级重要。不光是对于程序员，对于所有在学习的人们。 ☀程序员学习 ☀自学 自学缺点： 不知道自己该学什么。确定该做什么，会成为一项非常艰难的选择。需要有自制力，还要有正确的判断。 很容易失去动力。动力的可以来源压力。 自学可能在知识体系上有所欠缺。数据结构、计算机原理、基本算法，基本的科目。 自学优点： 自由，可以根据自己的喜好学习。 自学小技巧： 制定学习计划。凡事预则立，不预则废。制定计划不可能是100%完美，需要去修正。根据自身的时间和紧迫程度，制定出属于自己的完美计划。 设定时间表。让他充分发挥优势，每一天，每一周稳步前进。 找一位老师。指明方向。 至少完成一个完整的项目。 想一下自己的压力，给一点适当的压力，鞭策。 有正确的学习方法，一定能完成自学。 不忘初心，愿你归来仍是少年。 分享是程序员的基本美德。 ☀心得感悟： 今天看了java程序员app，看了些一些大牛的经验，收益匪浅，多看这种经验技术贴。站在巨人的肩膀上。 任何事物都要抓住两重点。1.作用范围。2.如何作用的方法。 官网才是第一手的学习资料。 Github中的readme文件也是第一首学习资料. ☀参考 低起点码农 逆袭黄金三原则 ☀番茄工作法 番茄只有整数个，没有半个或者零点几个番茄； 有条件的话，建议不使用手机 APP 作为番茄时钟，虽然有极少数的人确实能够避免手机的打扰； 没有硬性规定一个番茄必须是 25 分钟，或者必须休息 5 分钟，你可以根据自己的具体条件设定时间长短。但人的注意力是有限的，25~30 分钟对大多数人是比较适宜的时长，过长的时间反而无法达到效果；休息时间也不宜过长，并且休息时间中，一定不要做和当下工作相关的任何事情； 有人把番茄工作法和 GTD 直接做比较，实际上两者是可以互补的。对于已经确定的任务，番茄工作法可以很好地帮助你高效地处理，而对所有的任务管理，GTD 实际上更有帮助。简单来说，GTD 适合用于确定做什么（WHAT），番茄工作法可以帮助保证既定任务的完成质量（HOW）；","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"学习方法","slug":"学习方法","permalink":"http://aner1001.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"}]},{"title":"感悟心得","slug":"生活知识/经验感悟/感悟心得","date":"2021-02-07T03:05:18.000Z","updated":"2021-03-01T03:05:18.000Z","comments":true,"path":"posts/2021/02/07/d34d7e2f1c75/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/d34d7e2f1c75/","excerpt":"","text":"当陷入低谷或者情绪非常低落的时候。 强者的五个心态: 不要太内耗，不要让负面情绪影响一整天。给一个限定时间，能强行抽离就强行抽离，能转移注意力就转移注意力，不要内心戏太多。因为负面情绪非常消耗能量和精力。 不要让别人过度消耗你的能量，远离有压迫感的人，即便对方非常优秀。应为他极有可能pua你，让你觉得自己很土，很low，很渣，很玻璃心，一无是处，保护好自己的朋友圈，保护好自己内心的领土，划定界限，不容得别人随意侵犯。 戒掉虚荣心。完全戒掉虚荣心的人会非常自在潇洒。不因为东西很贵是奢侈品不会买，不会因为这个东西很便宜不去买它，所有的行为都是发自内心，也不会感到苦恼，也不会因为别人的攀比激起自己的虚荣心。 你表达出来的要和内心完全一致，并且相信别人也是如此。不害怕表达真实的自己，你心里想什么就说什么。如果对方的行为和言语没有表 达出来，你没有观察到那就是没有，因为揣测的成本非常之高。如果你实在觉得困惑，那就去问，不要猜不要瞎琢磨。 不害怕表达自己的好感。没有一个人会讨厌喜欢自己的人，赞美自己的人。对身边人，家人朋友同事，领导表达发自内心的关爱。“认真你就输了”，冷漠一些在恋爱的时候，其实不是这样的，正能量才能让人相聚。不害怕被赞美，不害怕表达赞美，更容易拉近彼此的距离。大部分都是普通人，需要自我激励，也需要别人点亮。所以做一个有力量的好人，能激励自己也能激励他人。 做事情冷静一些，不要随随便便答应别人。但是想清楚了，答应了别人，还是尽量要做到。 没有能量做某些事的时候，不要着急，慢慢积攒能量。 床+手机真的可以搞废一个人。最好的办法就是让他们分开。躺床上睡觉的时候，手机放非常远离床的桌面上，躺下去的时候只想着睡觉休息。手机需要用到的时候才用，比如打电话，刷重要信息，但是不能在床上进行。只有让手机和床分开的时候，就能发挥他们好的一面。 生活是需要总结和思考的，但是往往繁杂的工作会让你无从开始。躺床上入门睡觉前，可以总结思考当天的所有，正好也可以代替刷手机。 个人的精力和力气是有限的。一定要合理分配。就和选购CPU或者显卡一个道理，花费的是财力，越往性能好的挑选，需要花费的财力越多，但是性能提升变小了。自己专研Java的时候也需要牢记这一点。思考，把握好度，用力得当，不敷衍但也不钻牛角尖，才能真正学好。 做一个爱学习，知上进，善沟通，重细节，懂感恩的人。 做事不能急啊，很否则会失去理智，陷入恶性循环。 有些事千万不要做一次就确定下来 还是要多尝试几次 多比较 有了足够的认识和理解后再做决定 童虎老师:“史昂，虚幻的生命，虚幻的青春，真的让你那么高兴吗？” 史昂：“什么？” 童虎老师：“你不认为生命只有一次，是不可以重来一遍的吗，正因为如此，生命才显得宝贵，绽放出无比灿烂的光芒啊！”","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[]},{"title":"减肥心得","slug":"生活知识/经验感悟/减肥","date":"2021-02-07T02:14:17.000Z","updated":"2021-02-07T02:14:17.000Z","comments":true,"path":"posts/2021/02/07/bfd2b5f4922c/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/07/bfd2b5f4922c/","excerpt":"博主个人的减肥心得，仅供参考💖。","text":"博主个人的减肥心得，仅供参考💖。 现在个人在减肥方面保持以下习惯： 坚持冷水澡，无论春夏秋冬。洗冷水澡可以消耗很大的热量。 注意事项： 1. 洗完冷水澡后一定要，速度擦干身体，然后进行运动回暖到微微出汗。即可以起到驱寒的效果，又可以再次消耗热量。运动可以是跑步、跳绳等中高强度，快速发热运动。个人选择跳绳，方便，不需要刻意寻找场地。 2. 切不可硬着头皮勉强洗，如果有身体不适，感冒啥的，就用热水洗。 3. 冬天洗冷水澡，需控制时间。天气越冷，速度越快。最多不能超过10分钟。一般5分钟左右。 4. 如果是冬天，事后可以喝上一杯暖暖的红糖姜汤，美翻了。 要动起来，个人选择了游泳运动，每周末都会去湖里游泳锻炼。对身心健康都很好。适量即可。 每天一个苹果是必须的。苹果能够起到减肥效果，也能使你更健康。 吃饭，要控制量。但不能什么都不吃，也要营养均衡。正常吃饭到7分饱即可。个人觉得看到网上说只吃一个苹果，黄瓜啥的，太苦了，而且不是长久之计。正常吃饭就可以了。 控制零食。个人一般只吃三顿饭，不吃零食。实在忍不住了，就稍微来一些，解馋就行了。小技巧：实在想吃的时候在餐后来点零食是最好，既可以解馋，又不会吃太多，有助于消化达到减肥的目的。控制零食也能节省很多钱。哈哈啊哈哈。😅 减肥本来就是一个长久的事情。啥事都要慢慢来，习惯成自然。可能你还没注意到习惯的强大之处。就是即使给我一个很胖很差劲的身体，有一个好的习惯，时间一到，会不知不觉的变成一个好的身体，就是这么自然。懂我意思😎。 现在控制下来效果还不错，从156⤵️137。保持。","categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"减肥","slug":"减肥","permalink":"http://aner1001.gitee.io/tags/%E5%87%8F%E8%82%A5/"}]},{"title":"Chrome使用笔记","slug":"技术知识/工具/Chrome使用笔记","date":"2021-02-04T00:26:43.000Z","updated":"2021-02-04T00:26:43.000Z","comments":true,"path":"posts/2021/02/04/7ee83887e8eb/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/04/7ee83887e8eb/","excerpt":"记录了Chrome的快捷键和设置项!!!∑(ﾟДﾟノ)ノ。","text":"记录了Chrome的快捷键和设置项!!!∑(ﾟДﾟノ)ノ。 ☀快捷键 谷歌浏览器默认快捷键大全： 窗口和标签页快捷方式 Ctrl+N 打开新窗口 按住 Ctrl‎ 键，然后点击链接 在新标签页中打开链接 按住 Shift 键，然后点击链接 在新窗口中打开链接 Alt+F4 关闭chrome浏览器 Ctrl+T 打开新标签页 Ctrl+Shift+T 重新打开上次关闭的标签页。 谷歌浏览器可记住您关闭的最后 10 个标签页。 将链接拖动到标签页内 在指定标签页中打开链接 将链接拖动到两个标签页之间 在新标签页横条上的指定位置打开链接 Ctrl+1 到 Ctrl+8 切换到指定位置编号的标签页。 您按下的数字代表标签页横条上的位置。 Ctrl+9 切换到最后一个标签页 Ctrl+Tab 或 Ctrl+PgDown 切换到下一个标签页 Ctrl+Shift+Tab 或Ctrl+PgUp切换到上一个标签页 Ctrl+W 或 Ctrl+F4 关闭当前标签页或弹出式窗口 打开谷歌浏览器功能的快捷方式 Ctrl+Shift+B 打开和关闭书签栏 Ctrl+H 查看历史记录页 Ctrl+J 查看下载页 Shift+Escape 查看任务管理器 Shift+Alt+T 将键盘焦点设置在谷歌浏览器工具栏上。 使用键盘上的向右和向左箭头，导航至工具栏的不同区域。 网页快捷方式 Ctrl+P 打印当前页 F5 重新加载当前页 Ctrl+F5 或 Shift+F5 重新加载当前页，但忽略缓存内容 F12 开发者窗口 F10设置断点后按此键可以一行一行执行js（会跳过执行的函数），在执行的过程中若遇到了一个js函数就可以按F11键跳到那个函数里面去 Shift+F11跳出当前执行的函数。 Ctrl+Shift+Delete:用于显示“清除浏览数据”界面 按住 Alt 键，然后点击链接 下载链接 Ctrl+F 打开在网页上查找框 Ctrl+G 或 F3 查找与您在在网页上查找框中输入的内容相匹配的下一个匹配项 Ctrl+Shift+G 或 Shift+F3 查找与您在在网页上查找框中输入的内容相匹配的上一个匹配项 Ctrl+U 查看源代码 将链接拖动到书签栏 将链接加入书签 Ctrl+D 将当前网页加入书签 Ctrl++ 放大文字 Ctrl± 缩小文字 Ctrl+0 还原到正常文字大小 Ctrl+PgDn 向→切换tab页 Ctrl+PgUp 向左←切换tab页 PgDn 以一屏，向下翻页。 PgUp 以一屏，向上翻页。 Home 定位到网页最上方。 End 定位到网页最下方。 Ctrl+shift+A 查找已打开的标签页。 文字快捷方式 突出显示内容，然后按 Ctrl+C 将内容复制到剪贴板。 将光标置于文字字段中，然后按 Ctrl+V 从剪贴板粘贴当前内容。 将光标置于文字字段中，然后按 Ctrl+Shift+V 从剪贴板粘贴当前内容的纯文字部分。 突出显示文字字段的内容，然后按 Ctrl+X 删除内容。 附：常见的HTTP状态码 200 客户端请求成功 302 临时跳转，跳转的地址通过Location指定 400 客户端请求语法有错 403 服务器收到请求，但是拒绝提供服务 404 请求资源不存在 500 服务器发生不可预期的错误 ☀设置项 ☀1. 设置语言优先级： 这样访问一些可以支持各国语言的网站能够根据浏览器版本进行转换。 ☀2. ghelper chrome无法访问GitHub设置 原因： 这个插件对不同的域名有默认不同的连接模式。 解决配置： 把三个有关GitHub的域名，全都给他添加为直连。 ☀参考文章 谷歌浏览器快捷键怎么修改设置？ 谷歌浏览器快捷键设置方法详解 ghelper chrome无法访问GitHub","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://aner1001.gitee.io/tags/Chrome/"}]},{"title":"VsCode使用记录","slug":"技术知识/工具/VsCode使用记录","date":"2021-02-04T00:01:42.000Z","updated":"2021-02-04T00:01:42.000Z","comments":true,"path":"posts/2021/02/04/8c0515502fc4/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/04/8c0515502fc4/","excerpt":"接触VsCode工具不久，文章记录一些VsCode的日常使用。快捷键、插件，常用操作等。","text":"接触VsCode工具不久，文章记录一些VsCode的日常使用。快捷键、插件，常用操作等。 ☀快捷键 快捷键 说明 F1`Ctrl+Shift+P` 弹出插件命令行搜索窗口 ☀插件 ❀VsCode扩展商店 ☀Settings Sync 用于同步vscode中的设置和插件。 Settings Sync是vscode中同步设置和安装插件的小工具，在扩展商店中搜索并安装它 登陆Github&gt;Your profile&gt; settings&gt;Developer settings&gt;personal access tokens&gt;generate new token，输入名称，勾选Gist，提交。 保存Github Access Token 打开vscode，Ctrl+Shift+P打开命令框，输入sync，找到update/upload settings，如果未设置token会自动进入设置界面。 输入Token，可能复制上去的结果会重复，删除重复部分。上传成功后会返回Gist ID，保存此Gist ID. ❀输入token❀上传ctrl+shift+u 若需在其他机器上同步插件和设置的话，同样，Ctrl+Shift+P打开命令框，输入sync，找到Download settings，会跳转到Github的Token编辑界面，输入token和gist id，即可同步插件和设置。 ❀alt+shift+D ☀gist ☀Share Code 窗口化gist插件 ❀只需要配置token和用户名即可。 ❀F1或者ctrl+shift+p，弹出插件命令行窗口搜索chare code ☀常用操作 ☀GitHub的Token绑定 从GItHub生成Token 点击状态栏中的Signing in to github.com 复制token到输入栏中。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"VsCode","slug":"VsCode","permalink":"http://aner1001.gitee.io/tags/VsCode/"}]},{"title":"Sql学习笔记","slug":"技术知识/数据库/SQL学习笔记","date":"2021-02-03T12:39:53.000Z","updated":"2021-02-03T12:39:53.000Z","comments":true,"path":"posts/2021/02/03/bb0c1be9ba6b/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/03/bb0c1be9ba6b/","excerpt":"Sql学习笔记","text":"Sql学习笔记 ☀左关联： 语法： left join on 多层左关联运用： 123456789101112131415161718192021222324252627282930select * from Td_Oss_Actionselect * from td_oss_productselect * from td_so_template where prod_id =&#x27;1433&#x27;;select * fromselect t.al 总数, p.prod_name 产品, a.action_name 动作,t.prod_id,t.CHG_SERV_SPEC_ID from (select count(*) al, prod_id, CHG_SERV_SPEC_ID from tf_so group by prod_id, CHG_SERV_SPEC_ID having prod_id in(1433, 1434, 958825, 958826, 1412, 1413, 1419, 1420, 1403, 1409, 1431, 1432, 1435, 1436)) t left join td_oss_product p on t.prod_id = p.prod_id left join td_oss_action a on t.chg_serv_spec_id = a.action_id ☀查询结果拼接 Oracle将不同列的值拼接成一个字符串 – 方法一：推荐 123SELECT S.TEAM ||&#x27;**&#x27;|| S.NAME ||&#x27;**&#x27;|| S.JOB_NUMBER FROM STAFF S WHERE S.PASS =&#x27;123456&#x27; AND S.TEAM =&#x27;南方&#x27;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Sql","slug":"Sql","permalink":"http://aner1001.gitee.io/tags/Sql/"}]},{"title":"Markdown写出漂亮的博客技巧心得","slug":"技术知识/工具/Markdown写出漂亮的博客技巧心得","date":"2021-02-03T11:49:09.000Z","updated":"2021-02-03T11:49:09.000Z","comments":true,"path":"posts/2021/02/03/71f720785963/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/03/71f720785963/","excerpt":"如何写出漂亮的博客，参考网络上好的写法，个人心得的积累。","text":"如何写出漂亮的博客，参考网络上好的写法，个人心得的积累。 ☀1.标题 ☀1.1 标题间隔 大的标题之间使用分隔符 ☀1.2 段落小标题 讨论小标题分类。比如优点、缺点，可以在标题前加❀这样的，美观方便与正文内容区分。 ♦例: ​ ❀优点 ​ 12345 ​ ❀缺点 ​ 67890 ☀2.列举说明 ☀2.1 短列举，短说明 使用table格式 参数 说明 this this指针 public 访问权限修饰符公共 protected 访问权限修饰符保护 ☀2.2 短列举，长说明 使用加粗+代码行的格式 进行列举。 shift+回车段落换行缩进进行描述。 参数之间使用双回车空行或者回车段落间隔。 ♦例： data The object passed from the other window. origin The origin of the window that sent the message at the time postMessage was called. This string is the concatenation of the protocol and “😕/”, the host name if one exists, and “:” followed by a port number if a port is present and differs from the default port for the given protocol. Examples of typical origins are https://example.org (implying port 443), http://example.net (implying port 80), and http://example.com:8080. Note that this origin is not guaranteed to be the current or future origin of that window, which might have been navigated to a different location since postMessage was called. source A reference to the window object that sent the message; you can use this to establish two-way communication between two windows with different origins. ☀2.3 关键列举，长说明 关键列举可以在列举取出列举的关键字，并且将列举标题话。一些命令行的语句。 ♦例: ☀2.4 init 1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 This command is a shortcut that runs the following steps: Git clone hexo-starter including hexo-theme-landscape into the current directory or a target folder if specified. Install dependencies using a package manager: Yarn 1, pnpm or npm, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with Node.js by default. ☀2.5 new 1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 1$ hexo new &quot;post title with whitespace&quot; 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 --path 参数来覆盖上述行为、自行决定文件的目录： 1hexo new page --path about/me &quot;About me&quot; 以上命令会创建一个 source/about/me.md 文件，同时 Front Matter 中的 title 为 &quot;About me&quot;","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://aner1001.gitee.io/tags/MarkDown/"}]},{"title":"什么是域名、主机、服务商、CDN","slug":"技术知识/计算机/什么是域名、主机、服务商、CDN","date":"2021-02-03T01:00:43.000Z","updated":"2021-02-03T01:00:43.000Z","comments":true,"path":"posts/2021/02/03/602d40b55cff/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/03/602d40b55cff/","excerpt":"什么是域名？什么是主机？什么是服务商？什么是CDN？","text":"什么是域名？什么是主机？什么是服务商？什么是CDN？ ☀1.什么是域名 域名(Domain) ☀1.1定义 域名，通俗来讲，是互联网上用来标记网站的名字。 当我们说一个网站的网址时，其实说的是这个网站的www.+域名 域名：baidu.com cctv.com ☀1.2分类 国际域名(以.com，.net，.org结尾的域名；) 国内域名(以.cn结尾的域名) .com用于商业性的机构或公司；个人； .net用于从事Internet相关的网络服务的机构或公司； .org用于非盈利的组织、团体； 甚至一些成人网站用 .xxx 什么是域名解析？和IP地址有什么关系？ 打车去某小区 小区名-域名 出租车司机-域名服务器 IP地址：小区的具体物理地址。 ☀1.3主域名和二级域名 对于一个网站来说，主域名是唯一的。 主域名(一级域名)：baidu.com 主域名的特征： 只有一个. 且.的左侧有内容。 二级域名： www.baidu.com 首页 tieba.baidu.com 贴吧 主域名(一级域名)：chinaz.com 二级域名： tool.chinaz.com 工具 down.chinaz.com 下载 bbs.chinaz.com 论坛 ==www.为什么是二级域名== www服务时万维网服务，只是网络服务中的一种。 域名只有一个：baidu.com 但是二级域名可以扩展N多个 x.baidu.com 形如“abc.com/bbs”的采取目录形式的不能够称为二级域名 域名和网址有什么区别？ 网址：链接地址（URL）网站上的任何一个页面，任何一个文件入图片，都有他的网址。用来定位访问的位置。可以这样说，URL是Internet上的链接地址簿。 URL的结构 服务器标识符+信息资源地址+路径名 ​ http:// ​ ftp:// ​ 服务器标识符 telnet:// ​ … URL ​ 信息资源地址 主机名 ​ 端口号 ​ 路径名(Path) 域名：baidu.com http://www.baodu.com/img/270xxxxxxxx.gif ☀1.4服务器标识符 http:// 用超文本传输协议链接 ftp:// 用文件传输协议链接 telnet:// 用TELNET会话链接 https:// 用超文本传输安全协议链接 s:secure ☀1.5信息资源地址 主机名：www.baidu.com 端口号：80(www服务默认的端口号，通常省略) ☀1.6路径名 资源所在机器上的完整文件名 /表示根目录 ☀2.什么是主机 ☀3.什么是服务商 ☀4.什么是CDN ☀4.1简介 CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 ☀4.2应用 国内外优秀前端 CDN，Google Fonts 国内镜像","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"域名","slug":"域名","permalink":"http://aner1001.gitee.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"CDN","slug":"CDN","permalink":"http://aner1001.gitee.io/tags/CDN/"}]},{"title":"IDEA手册","slug":"技术知识/工具/IDEA手册","date":"2021-02-03T00:22:36.000Z","updated":"2021-02-03T00:22:36.000Z","comments":true,"path":"posts/2021/02/03/1a4c243e0505/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/03/1a4c243e0505/","excerpt":"IDEA 全称IntelliJ IDEA，是用于java语言开发的集成环境IDE(Integrated Development Environment)，也可用于其他语言。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。","text":"IDEA 全称IntelliJ IDEA，是用于java语言开发的集成环境IDE(Integrated Development Environment)，也可用于其他语言。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。 ☀1.概念 ☀1.1 IDE 集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如微软的Visual Studio系列，Borland的C++ Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。例如，许多人在设计网站时使用IDE（如HomeSite、DreamWeaver等），因为很多项任务会自动生成。编程开发软件将编辑、编译、调试等功能集成在一个桌面环境中,这样就大大方便了用户。 ❀优点 节省时间和精力。IDE的目的就是要让开发更加快捷方便，通过提供工具和各种性能来帮助开发者组织资源，减少失误，提供捷径。 建立统一标准。当一组程序员使用同一个开发环境时，就建立了统一的工作标准，当IDE提供预设的模板，或者不同团队分享代码库时，这一效果就更加明显了。 管理开发工作。首先，IDE提供文档工具，可以自动输入开发者评论，或者迫使开发者在不同区域编写评论。其次，IDE可以展示资源，更便于发现应用所处位置，无需在文件系统里面艰难的搜索。 ❀缺点 学习曲线问题。IDE基本上是比较复杂的工具，为了更好的熟练使用，需要一定的时间和耐心。 初学者的困难。对初学者来说，使用IDE来学习开发有相当的难度，不适合学习一种新语言时使用。 无法修复坏代码或设计。开发者不能完全依赖工具的便捷，还是必须保持专业水准和熟练度，开发的成果好坏主要还是看开发员的技术。 ☀1.2 JetBrains公司介绍 IntelliJ IDEA就是Java的IDE。 市场占有率竹节攀升，超过了Eclipse。 官网：https://www.jetbrains.com/ JetBrains公司介绍： JetBrains是一家捷克的软件开发公司，该公司位于捷克的布拉格，并在俄罗斯的圣彼得堡及美国麻州波士顿都设有办公室，该公司最为人所熟知的产品是Java编程语言开发撰写时所用的集成开发环境：IntelliJ IDEA。公司旗下还有其它产品，比如： WebStorm: 用于开发JavaScript、HTML5、 CS3等前端技术; PyCharm: 用于开发python（python语言热度排行榜排名第一，在人工智能大数据领域应用） PhpStorm: 用于开发PHP RubyMine: 用于开发Ruby/Rails AppCode: 用于开发Objective - C/Swift,替换xcode的 CLion: 用于开发C/C++ DataGrip: 用于开发数据库和SQL Rider: 用于开发.NET GoLand: 用于开发Go（区块链主流开发语言就是Go语言） ☀1.3 IntelliJ IDEA介绍 【1】IDEA 全称IntelliJ IDEA，是用于java语言开发的集成环境IDE(Integrated Development Environment)，也可用于其他语言。 IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查、 创新的GUI设计等方面的功能可以说是超常的。 IDEA是JetBrains公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。 【2】IDEA的支持： 【3】IDEA的优势（相对于Eclipse） 强大的整合能力。比如: Git、 Maven、 Spring 等 提示功能的快速、便捷 提示功能的范围广 好用的快捷键和代码模板 精准搜索 ☀2.安装相关 ☀2.1 IntelliJ IDEA的下载和安装的准备 【1】官网：https://www.jetbrains.com/idea/download/#section=windows 【2】安装的准备： 硬件环境： 内存8G以上 CPU i5以上 安装在固态硬盘下 软件环境： 需要安装JDK ☀2.2 IDEA的卸载 对于免安装的idea： （1）删除安装文件 （2）到用户下将idea的缓存，配置的目录删除掉即可 对于安装的idea: 可以用控制面板–》程序。 检查用户下将idea的缓存，配置的目录，如果有删除掉即可 。 ☀2.3 IDEA的安装和破解 ☀方式一：（破解已失效） 【1】将安装包进行解压–》选择固态盘符 【2】发送到桌面快捷方式，生成一个快捷方式 【3】打开： 选择主题： 先进入再说，免费试用： 创建一个项目： 选择JDK： 找到jetbrains-agent.jar 文件，然后放入合适的文件夹内（我一般直接放入idea的安装位置了，你随意，不建议有中文路径） 点击IDEA的菜单，找到： Help—》Edit Custom VM Options 然后在文件中最后一行填入： -javaagent:D:\\soft_setup\\IDEA\\ideaIU-2019.2.3.win\\jetbrains-agent.jar 注意这个jetbrains-agent.jar的路径要是你自己的真实的路径。 关闭IDEA 再次打开IDEA，点击菜单 ，Help—》Register: 填写address地址：https://fls.jetbrains-agent.com。 关闭IDEA 重启IDEA 看到带Licenseed to…字样的 证明激活成功 ☀方式二： 官网下载最新IDEA。 获取Avtivation code注册码获取网站： http://vrg123.com/ 获取注册码后，使用Avtivation code注册码激活即可。 ☀3.IDEA页面展示 项目下内容： 工程下的src类似于Eclipse下的src目录，用于存放代码。。 工程下的.idea 和TestProject.iml文件都是IDEA工程特有的。类似于Eclipse 工程下的settings、.classpath、.project 等。 配置： ☀4.Module的概念和使用 【1】在Eclipse中我们有Workspace (工作空间)和Project (工程)的概念，在IDEA中只有Project (工程)和Module (模块)的概念。 这里的对应关系为: IDEA官网说明: An Eclipse workspace is similar to a project in IntelliJ IDEA An Eclipse project maps to a module in IntelliJ IDEA 翻译: Eclipse中 workspace 相当于 IDEA中的Project Eclipse中 Project 相当于 IDEA中的Module 在IntelliJ IDEA中Project(工程) 是最顶级的级别，次级别是Module(模块)。 一个Project下可以有多个Module。 【2】从Eclipse 转过来的人总是下意识地要在同一个窗口管理n个项目，这在Intellij IDEA是无法做到的。Intellij IDEA提供的解决方案是打开多个项目实例，即打开多个项目窗口。即:一个Project 打开一个Window窗口。 【3】IDEA这样设置的原因： 目前主流的大型项目都是分布式部署的，结构都是类似这种多Module的。 这类项目一般是这样划分的，比如: 积分模块、任务模块、活动模块等等，模块之间彼此可以相互依赖。这些Module之间都是处于同一个项目业务下的模块，彼此之间是有不可分割的业务关系的。 【4】out目录的说明：里面存放的是编译后的字节码文件 【5】删除模块： ☀5.常用设置 ☀5.1进入设置： ☀5.2设置主题： ☀5.3编辑区的字体变大或者变小： 通过ctrl+鼠标滚轮改变编辑区字体大小。 ☀5.4鼠标悬浮在代码上有提示： ☀5.5自动导包和优化多余的包： 手动导包：快捷键：alt+enter 两个选项对应自动导包和优化多余的包： ☀5.6同一个包下的类，超过指定个数的时候，导包合并为* ☀5.7显示行号 ， 方法和方法间的分隔符： ☀5.8忽略大小写，进行提示： ☀5.9多个类不隐藏，多行显示： ☀5.10设置默认的字体，字体大小，字体行间距：(编辑区和控制台都会变化) ☀5.11修改代码中注释的字体颜色： ☀5.12修改类头的文档注释信息：—》注意：对新建的类才有效 123456/*** @Auther: zhaoss* @Date: $&#123;DATE&#125; - $&#123;MONTH&#125; - $&#123;DAY&#125; - $&#123;TIME&#125;* @Description: $&#123;PACKAGE_NAME&#125;* @version: 1.0*/ ☀5.13设置项目文件编码： 文件右下角可以调节编码格式： ☀5.14自动编译： 二、Registry ctrl+alt+shift+’/’ 弹出框选择如下，勾选即可。 ☀5.15省电模式： 代码检查、代码提示没有肯能进入省电模式。 ☀5.16代码显示结构： ☀5.17导入jar包： ☀5.18生成序列化版本号： 凡是一个类实现了Serializable接口，建议给该类提供一个固定不变的序列化版本号。以后这个类即使代码修改了，但是版本号不变，java虚拟机认为是同一个类。（区分类的） IDEA设置自动生成序列化版本号 检查代码时会出现添加seriaID提示。 ☀5.19设置控制台输出日志解码格式 导航Help——&gt;Edit Custom VM Options 添加文本设置：-Dfile.encoding=UTF-8 ☀5.20.开启Lambda表达式显示. settings-&gt;Editor-&gt;Gutter icons-&gt;Lambda 勾选即可. ☀6.常用快捷键 快捷键 功能 double shift 全局搜索(集合下方的一些搜索功能) Ctrl+N 按照文件名称查找java文件 Ctrl+Shift+N 按照文件名称查找所有文件 Ctrl+Shift+F 在所有文件中查找指定内容。 Ctrl+F 在当前文件中查找指定内容。 Ctrl+E 列出最近使用过的文件 Ctrl+Shift+Alt+N 查找类中的方法或变量 Ctrl + Alt + v 自动补全变量名称 Ctrl + Alt + f 自动补全属性名称 Shift + Esc 关闭打开的小窗口 Tab/Enter 将提示内容自动补全 Alt+Enter 代码检查提示，放在类名，对象，变量。 alt+insert 创建内容(项目中，包中，类中，文本中) psvm main方法 sout 输出语句的简写，sout/str.sout ctrl+d 复制行(单行/多行) ctrl+y 删除行 Ctrl + Shift + Up / Down 代码向上/下移动 Ctrl + / 或 Ctrl + Shift + / 单行注释或多行注释 shift+f6 重命名 Ctrl+O 重写父类方法 fori for循环 ctrl+alt+t 代码块包围：try-catch,if,while等 Ctrl+空格 手动显示代码自动补全提示 keymap-&gt;code-&gt;completion-&gt;basic可修改。 ctrl+鼠标滚轮 idea代码字体大小放大和缩小的快捷键 keymap-&gt;搜索font-size alt+方向上/下 类中方法之间跳跃 alt+方向左/右 已打开的类中左右切换 ctrl+方向上/下 光标不动，下拉页面(鼠标滚轮功能) ctrl+方向左/右 光标不在窗口中，将窗口移动到光标范围中。光标在窗口中，则进行字符串之间跳跃。 ctrl+鼠标悬浮在代码上+点进去即可 代码一层一层调用的快捷键：点进源码 ctrl+alt+方向左/右 切换查看代码的导航，前进/后退 keymap-&gt;搜索navigate alt+7 显示代码结构 alt+1 显示project工程结构导航 ctrl+z 撤回 ctrl+shift+z redo(重做) tab 缩进/提示内容自动补全 shift+tab 取消缩进 shift+enter 新建下一行并跳转到下一行。 ctrl+shift+F9 编译当前文件 ctrl+F9 编译工程 ctrl+shift+F10 运行当前文件main方法 shift+F10 运行文件(优先选择之前运行过的/web项目目标为Tomcat，在工具中选择。) shift+F9 debug文件(优先选择之前debug过的)/web项目目标为Tomcat alt+shift+F10 不跳转窗口，选择已打开的文件运行。 alt+shift+F9 不跳转窗口，选择已打开的文件编译。 alt+F8 查看表达式的值。 ctrl+B 查看方法哪里被调用 Ctrl+Shift+回车 语句自动补全添加; Ctrl+Alt+L 代码格式化。 Ctrl+Shift+J 代码去空格。搜压缩。 ☀7.常用操作： ☀7.1多文件并联展示 文件名，右键Split Vertically 垂直展示 文件名，右键Split Horizontally 水平展示 ☀7.2导入jar包 ☀7.3代码模板使用 ☀7.3.1代码模板是什么 它的原理就是配置一些==常用代码字母缩写==，在输入简写时可以出现你预定义的固定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子就是在Java中输入sout会出现System.out.println(); （一）所处位置： （1）Live Templates （2）Postfix Completion （二）区别： 【1】 Live Templates中可以做用户的个性化定制。 Postfix Completion中只能用，不能修改。 【2】使用方式不同 ☀7.3.2常用的代码模板 【1】模板1： main方法： main 或者 psvm 【2】模板2：输出语句： sout 或者 .sout 一些变型： soutp:打印方法的形参 soutm:打印方法的名字 soutv:打印变量 【3】模板3： 循环 普通for循环： fori（正向） 或者 .fori （正向） . forr(逆向) 增强for循环： iter 或者 .for （可以用于数组的遍历，集合的遍历） 【4】模板4： 条件判断 ifn 或者 .null ：判断是否为null （if null） inn 或者 .nn ：判断不等于null (if not null) 【5】模板5： 属性修饰符： prsf : private static final psf :public static final 后缀多用于指定，非后缀多用于就近。 【6】 模板6：生成变量 .var:在调用有返回的方法上，使用，自动生成变量。 ☀7.3.3修改现有模板 【1】案例1：改main方法： psvm 【2】案例2：修饰属性的修饰符： $VAR1$ $VAR2$ 表示占位符，光标会落到占位符上。 ☀7.3.4自定义模板 【1】测试方法： 【2】常用属性：($$中的内容其实就是在定义光标的位置，光标可以切换，用回车切换) 【3】方法注释模板： 1234567/*** 功能描述:* @param: $param$* @return: $return$* @auther: $user$* @date: $date$ $time$*/ /** 回车补全和默认方法注释冲突，设定使用tab补全提示。 ☀7.4 IDEA中的断点调试 ☀7.4.1常用断点调试快捷键 调试在开发中大量应用： 【1】Debug的优化设置：更加节省内存空间： 设置Debug连接方式，默认是Socket。 Shared memory是Windows 特有的一个属性，一般在Windows系统下建议使用此设置， 内存占用相对较少。 【2】常用断点调试快捷键： 一步一步的向下运行代码，不会走入任何方法中。 一步一步的向下运行代码，不会走入系统类库的方法中，但是会走入自定义的方法中。 一步一步的向下运行代码，会走入系统类库的方法中，也会走入自定义的方法中。 跳出方法 结束程序 进入到下一个断点，如果没有下一个断点了，就直接运行到程序结束。 在当前次取消行的断点。 ☀7.4.2条件判断，查看表达式的值 【1】条件判断： 说明: 调试的时候，在循环里增加条件判断，可以极大的提高效率，心情也能惧悦。 具体操作: 在断点处右击调出条件断点。可以在满足某个条件下，实施断点。 【2】查看表达式的值： 选择行，alt+f8。 ☀7.5创建Java Web项目 创建Java Web的模块： ☀7.6在IDEA中添加Tomcat的镜像 启动项目： ☀7.7 ToolBar中显示和隐藏一些插件选项 隐藏：右键-&gt;remove from sidebar 显示：view-&gt;tool window ☀7.8.为新工程添加框架文件支持. 使用Maven自带web模板创建web工程： 使用创建Maven自带的模板创建web工程，没有java，resource资源文件夹。 ⛵️ 解决办法：先创建一个标准的Maven工程，使用idea的Framework support功能 创建出来的工程比较标准： ☀8.插件 插件官网 注意：在网站中所搜的插件需要和idea版本对应上。在idea内部搜索安装不用担心版本问题。 ☀8.1 Gist 插件名 评价说明 Gist Templates idea2019无法使用 Get gist (Beta) idea2019无法使用 Use Gists 目前只有2018可使用与MAGist类似没有搜索功能 Gist Snippet 没有搜索功能，新版支持。 MAGist 没有搜索功能，新版支持。 ☀8.2 JRebel dea热部署插件」 Rebel 当开始开发web项目的时候,需要频繁的修改web页面,此时如果频繁的重启变得很麻烦,因此,可以在idea 中集成Rebe插件,改动代码之后不需要重新启动应用程序。 服务器地址监听服务器地址： http://jrebel.cicoding.cn GUID生成器： http://jrebel.cicoding.cn/guid 监听配置格式： http://jrebel.cicoding.cn/GUID 生成的如下： http://jrebel.cicoding.cn/4B068EB5-0941-4645-1E98-FC077D530A61 打开IDEA中Settings如下： 找到File -&gt; Settings -&gt; JRebel &amp; XRebel 点击Chanage license，填写URL和邮箱地址 点击Chanage license！ 就监听成功激活成功了！鼓掌！ 然后就可以启动使用了！ ☀9.遇到问题解决 ☀1.performing vcs refresh时间过长 解决方案：重建项目 I also found that rebuilding the project (Build --&gt; Rebuild project) did the trick. At the end of that task it says… saving cashes. Immediately thereafter I can commit with no delay. ☀2.Error:java: 无效的源发行版: 11/Error:java: Compilation failed: internal java compiler error 因在于模块的target bytecode version和实际的编译器版本不一致所导致的错误。 不管三七二十一，把所有jdk版本统统改成一样的，首先按下快捷键ctrl+shift+alt+s: 查看项目的jdk File -&gt;Project Structure-&gt;Project Settings -&gt;Project或使用快捷键Ctrl+Alt+shift+S打开项目的jdk配置： 查看工程的jdk 点击上图中Modules查看对应jdk版本： 查看java编译器版本 导入java项目时此处处问题的概率比较多。 针对此问题，重新打开或修改pom文件（maven项目）中的内容很可能导致jdk版本重新变为1.5。如果是maven项目，可在pom文件中指定jdk相关信息： 123456789101112&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ☀3.class类按名称搜索不到 将编译主目录取消Exclusion。Exclusion的思想类似于git中的.gitignore被标记的文件不会被跟踪搜索到。 Exclusion方式一： Exclusion方式二： ☀4.Github登录不上 ☀4.1使用用户名： ❀测试结果： idea2018 和2019版本均无法登录。 ❀测试报错： Invalid authentication data. Operation canceled Incorrect credentials Incorrect credentials. Request response:401 Unautghorized ☀4.2使用token： ❀测试结果： 2019版本可以登录 2018登录报错。 ❀测试报错： Can’t get input stream from URL! Connect to api.github.com:443 [api.github.com/192.30.255.117] faild:Read time out Request response:401 Unauthorized - Bad credentials 尝试解决： 用邮箱账号登录 在地址前面,手动添加 https://github.com 在【Windwos 凭据】删除保存的账号密码 ，重启Android Studio，再次登录就可 如果忘记密码 ，在Github【Settings】-&gt;【Deveployer settings】-&gt;【Personal access token】获取new token ，使用new token登录。 file-&gt;setting-&gt;system settings去掉代理，HTTP Proxy -&gt;No proxy 将github上的token全部删除，再次通过github登录github。 ☀5.使用本地Tomcat，运行时缺少，添加第三方jar。 在工程的配置文件中添加，Artifacts。 ☀6.本地Tomcat解决控制台输出乱码 1、外置Tomcat解决办法： 1）Tomcat控制台启动乱码：Tomcat-&gt;Edit Configurations 2）Tomcat-&gt;-Dfile.encoding=UTF-8 3）重启Tomcat查看控制台 2、若未解决使用以下方法进行idea设置： 1）Help-&gt;Edit Custom VM options 2）增加：-Dfile.encoding=UTF-8 3、若还是有乱码继续设置： 1）Settins-&gt;Editor-&gt;File Encodings 2）Build,Execution,Deployment-&gt;java compiler 4、get请求查询mysql数据控制台显示乱码： 解决办法：设置字符格式为utf-8 -&gt; VM options: -Dfile.encoding=UTF-8 ☀7.本地Tomcat，静态资源未实时部署。 使用rebuild。 使用update项目：Ctrl+F10或者Shift+F10 ☀参考文献 idea有没有eclipse下的workspace的功能？","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://aner1001.gitee.io/tags/IDEA/"}]},{"title":"GitHub使用手册","slug":"技术知识/工具/GitHub使用手册","date":"2021-02-02T23:29:09.000Z","updated":"2021-02-02T23:29:09.000Z","comments":true,"path":"posts/2021/02/02/acf16ba36ec8/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/02/acf16ba36ec8/","excerpt":"本文简要介绍GitHub的相关功能和基本操作。","text":"本文简要介绍GitHub的相关功能和基本操作。 ☀1.概念总览 Repository 仓库 仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目则有多个仓库。 Star 收藏 仓库主页Star按钮，显示仓库被收藏的人数，收藏项目。下次方便查找。100个收藏已经很优秀了。 Fork 复制克隆项目 Pull Request 发起请求 Watch 关注 最好的理解就是观察，如果Watch了某个项目，那么以后这个项目有任何更新，你都会收到这个项目的通知提醒。 Issue 提问 发现项目有BUG，可以发起Issue一起来讨论。 GitHub主页 显示用户动态以及关注用户或关注仓库的动态；右侧显示所有的Git库。 仓库主页 项目代码，版本，收藏/关注/fork情况等。 个人主页 个人信息：头像，简介，关注我的人，我关注的人，我关注的git库，我的开源项目，我贡献的开源项目等信息。 ☀1.1使用限制 目前GITHUB仓库容量是没有上限的！不过官方推荐在1G以内！ 仓库单个文件50M会收到警告，大于100M会被拒绝！ ☀2.与Github相关站点 ☀2.1raw.githubusercontent.com ☀2.1.1简介： http://raw.githubusercontent.com是github用来存储用户上传文件（不是项目仓库的文件，而是issue里的图片之类的）的服务地址。 github 的素材服务器 (assets server),放在亚马逊s3上， 避免跟主服务抢占负载。 现在github仓库中的文件可以通过该网站来直接访问下载。 **个人理解： **github.com 用来管理用户的仓库和仓库中的文件。raw.githubusercontent.com 用来访问和下载用户仓库中的文件，将功能划分出减少了主服务器的负载。 ☀2.1.2使用： 图片文件点击guthub页面中的download即可打开raw.githubusercontent.com连接。 github网站中的图片路径： https://github.com/aner1001/picBed/blob/master/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png?raw=true 最终跳转到raw路径上： https://raw.githubusercontent.com/aner1001/picBed/master/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png 文本的文件点击github中的Raw按钮。 两者除了最开始的位置，后面的文件夹路径都一样。 ☀3.Github Pages 搭建静态网站 ☀3.1个人站点 ☀3.1.1访问 https://用户名.github.io ☀3.1.2搭建步骤 创建个人站点 -&gt; 新建仓库(注：仓库名必须是【用户名.github.io】) 在仓库下新建index.html的文件即可。 **注意：**github pages 仅支持静态网页。仓库里面只能是html文件。 ☀3.2 Project Pages 项目站点 ☀3.2.1访问 https://用户名.github.io/仓库名 ☀3.3.2搭建步骤 进入仓库主页，点击settings. 选择source barnch 分支 docs为使用github自带的主题。root为在仓库根路径下自定义的index.html. 点击change theme 为docs选择使用的主题页面。 ☀4.日常操作 ☀4.2将仓库变为private或者public ==settings——&gt;Danger Zone——&gt;Make public/private== ☀5.使用注意： GitHub是国外网站，使用需要翻墙。(Shadowsocks) 私有仓库只能自己或者指定的人能操作。token 可能收不到GitHub邮件，设置反垃圾github.com ☀6.参考资料 bilibili视频连接","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://aner1001.gitee.io/tags/GitHub/"}]},{"title":"Gist","slug":"技术知识/工具/Gist","date":"2021-02-02T23:05:19.000Z","updated":"2021-02-02T23:05:19.000Z","comments":true,"path":"posts/2021/02/02/9dc26bcc0a3f/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/02/9dc26bcc0a3f/","excerpt":"Github Gist 是一个有趣的服务。- 最普遍的功能是记录和分享代码片段。 - gist提供了包括markdown语法在内的大多数“写作风格”。- gist具有版本管理功能。- gist还可以无限制的创建私有的代码片段。- …","text":"Github Gist 是一个有趣的服务。- 最普遍的功能是记录和分享代码片段。 - gist提供了包括markdown语法在内的大多数“写作风格”。- gist具有版本管理功能。- gist还可以无限制的创建私有的代码片段。- … ☀1.Gist ☀1.1概要 Github Gist 是一个有趣的服务。 最普遍的功能是记录和分享代码片段 gist提供了包括markdown语法在内的大多数“写作风格” gist具有版本管理功能 gist还可以无限制的创建私有的代码片段 … ☀1.2使用 ☀1.2.1 匿名张贴 您不需要拥有Github账号就可以使用Gist。用浏览器打开http://gist.github.com，在窗口中写下你想说的就可以创建一个Gist。您可以发布一个私密的Gist，也就是说这个Gist将不能被他人搜索到而只对直接在浏览器中输入其URL的人可见。 ☀1.2.2 能像wiki一样记录历史 如果您修改了已经发布了的Gist的话，之前的所有版本都将被保存。您可以点击Revisions按钮按时间浏览，而且您可以通过内置的diff引擎查看任意两个版本间的差异。 这也可以用于比较文本文件。 ☀1.2.3 发布富文本内容 虽然Gist只能用纯文本来写，但是您可以用markdown来发布html格式的Gist。您可以添加列表、图片（已有图床上的）和表格。当您用markdown的时候不要忘了文件名要以.md为后缀。Gist会自动渲染markdown文件。其他格式的文件都以纯文本形式显示。 ☀1.2.4 把Gist当作一个写作平台 虽然现在有很多写作引擎，比如Blogger、Medium、Tumblr，但您还可以用Gist来快速发布您的作品。您可以用纯文本或者markdown等文档标记语言写一个Gist然后用~~http://roughdraft.io来把它作为一个独立的网页发布。 ，markdown文本会自动渲染，经过尝试roughdraft.io~~已经打不开了。使用Cacher工具自带的snippets.cacher.io功能发布和分享😄。 ☀1.2.5 托管gist上的单个页面 Bl.ocks 是一个非常有趣的专为Gist开发的应用。 您可以用纯文本把HTML、CSS、JavaScript代码写下来以index.html为文件名保存为Gist，然后用~~http://bl.ocks.org~~把渲染好的结果在浏览器中展示出来。比如，这个gist展示出来就是这样。 显然宽带限制是一个问题，但是~~http://bl.ock.org作为一个通过Gist托管HTML的工具仍然是相当不错的。 当然您也可以用Google Drive~~。 Google Drive在2016 年 8 月 31 日完全关闭这一服务。值得注意的是， GitHub 等公司长期提供类似服务。另外，用户也可以使用亚马逊的S3 云存储服务、 Dropbox 以及其他服务来托管静态网站。 ☀1.2.6 制作任务列表 您可以用Gist跟踪待处理任务。这是用纯文本的特殊语法写的但是你可以任意勾选。使用的是MarkDown语法。 - [x] Pick the flowers - [ ] Call John 9303032332 - [x] Cancel cable subscription - [ ] Book the flight tickets 发布gist之后，您可以勾选或者勾去任意选项，源文本将会自动变更。如果您的Gist是公有的的话，任何人都可以看到您的列表，但是只有您（拥有者）可以改变其勾选状态。 备注：其实任务列表也可以在issue中建立，所有拥有写权限的人都可以uncheck/check。 ☀1.2.7 把Gist作为一个网页内容收藏夹 在Chrome浏览器您可以找到一个叫GistBoxCacher的插件，通过这个插件您可以在浏览网页时选择保存网页内容为Gist。您甚至可以添加标注或者话题标签以易于以后更容易找到它们。 ☀1.2.8 把Gist嵌入网页中 您用一行js代码就可以把任何一条Gist嵌入到网页中。嵌入的Gist格式不发生任何变化，而且访问者可以非常方便的把它们fork到他们的Github中。一些博客的静态页面可以嵌入。 ☀1.2.9 测量访问量 您可以使用Google Analytics查看您的Gist的访问量。因为Gist纯文本中不允许运行js代码，所以我们可以用GA Beacon来记录实时访问Gist的情况。 把如下代码添加到Gist中，用markdown格式保存，这样就在这个Gist中添加了一个透明追踪图像了。 ![Analytics](https://ga-beacon.appspot.com/UA-XXXXX-X/gist-id?pixel) GA Beacon使用说明：作者github 论坛帖 ☀1.2.10 在桌面端管理Gist {Gisto} ——网络延迟太高，体验太差，不支持markdown渲染。标题和描述没区分开。标签在标题上添加# &lt;/&gt;CACHER ——延迟一版，体验还行，支持markdown渲染。标签为内置标签，存在软件中，跨平台性就不好了。支持浏览器插件很nice。支持内置连接分享。 Lepton ——标题，描述，标签统一写在标题描述上用不同编辑偶记区分 设计很棒，跨平台也不会丢失标签。支持markdown渲染。界面简洁，快捷键操作。作者心得 Lepton使用代理 ☀1.2.11 备份Gist 只支持在mac系统linux系统使用。 安装开源软件gister，该软件依赖gist，按照REAMDE安装这两个，此外还依赖curl、git、jq。下面列举一些要注意的东西： 要先初始化好Git，然后上传公钥，要确保能通过ssh访问GitHub 若Gist无法访问，可以安装proxychains-ng，使用代理执行命令 ☀1.2.12 在github gist上添加图片 ❀第一步：创建gist, 记住ID ❀第二部：clone ssh或者http 注意： 确保ping gist.github.com是通的。否则会拉取失败。 ​ 解决：添加本机host：192.30.255.113 gist.github.com ​ ❀第三步：在gistid名的仓库中，添加图片，git add-&gt;git commit-&gt;git push= ☀2.参考文献 Gist使用经验 在github gist上添加图片 Cacher Lepton","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Gist","slug":"Gist","permalink":"http://aner1001.gitee.io/tags/Gist/"}]},{"title":"URI","slug":"技术知识/计算机/URI","date":"2021-02-02T13:23:13.000Z","updated":"2021-02-02T13:23:13.000Z","comments":true,"path":"posts/2021/02/02/b3a654486dc9/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/02/b3a654486dc9/","excerpt":"1.什么是URI、什么是URL? 2.encodeURI和URLDecode的原理. 3.使用两次encodeURI解决实际应用场景.","text":"1.什么是URI、什么是URL? 2.encodeURI和URLDecode的原理. 3.使用两次encodeURI解决实际应用场景. ☀1.什么是URI、什么是URL ☀1.1 URI ☀1.1.1什么是URI URI，统一资源标志符(Uniform Resource Identifier， URI)，表示的是web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个URI进行标识的。 ☀1.1.2URI的结构组成 URI通常由三部分组成： ①资源的命名机制； ②存放资源的主机名； ③资源自身的名称。 （注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件） ☀1.2.3URI举例 如：https://blog.csdn.net/qq_32595453/article/details/79516787 我们可以这样解释它： ①这是一个可以通过https协议访问的资源， ②位于主机 blog.csdn.net上， ③通过“/qq_32595453/article/details/79516787”可以对该资源进行唯一标识（注意，这个不一定是完整的路径） 注意：以上三点只不过是对实例的解释，以上三点并不是URI的必要条件，URI只是一种概念，怎样实现无所谓，只要它唯一标识一个资源就可以了。 ☀1.2 URL ☀1.2.1什么是URL URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位 符”。 通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。 ☀1.2.2URL的结构组成 URL的格式由三部分组成： aa ①第一部分是协议(或称为服务方式)。 ②第二部分是存有该资源的主机IP地址(有时也包括端口号)。 ③第三部分是主机资源的具体地址，如目录和文件名等。 第一部分和第二部分用“😕/”符号隔开， 第二部分和第三部分用“/”符号隔开。 第一部分和第二部分是不可缺少的，第三部分有时可以省略。 ☀1.2.3URL举例 URL的一般格式为(带方括号[]的为可选项)： protocol 😕/ hostname[:port] / path / [;parameters]?query#fragment ☀1.2.4端口 何为端口？端口(Port)，相当于一种数据的传输通道。用于接受某些数据，然后传输给相应的服务，而电脑将这些数据处理后，再将相应的回复通过开启的端口传给对方。 端口的作用：因为 IP 地址与网络服务的关系是一对多的关系。所以实际上因特网上是通过 IP 地址加上端口号来区分不同的服务的。 端口是通过端口号来标记的，端口号只有整数，范围是从 0 到 65535。 ☀2.URI和URL之间的区别 从上面的例子来看，你可能觉得URI和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。 uri可以认为只是唯一识别的编号,类似于大家的身份证号,而url就是身份证住址+姓名。 URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（http://）。 转载自：https://blog.csdn.net/qq_32595453/article/details/80563142 ☀3.encodeURI和URLDecode的原理 ☀3.1URI二次编码出现的背景： 通常如果一样东西需要编码。最根本的说明这样东西并不适合传输或者存储。原因多种多样： 1. 从最基础的字符串，必须通过编码为0 1类型，才能传输存储到计算机中。 2. 随着应用场景的变化和逐渐复杂。如Size过大，包含隐私数据，都要使用编码解决。 3. 对于Url来说，本身的字符串已经被编码，之所以要进行二次编码(URLEncode)，是因为Url中有些字符会引起歧义。 + 例如，Url参数字符串中使用key=value键值对这样的形式来传参，键值对之间以&amp;符号分隔，如/s?q=abc&amp;ie=utf-8。如果你的value字符串中包含了=或者&amp;，那么势必会造成接收Url的服务器解析错误，因此必须将引起歧义的&amp;和=符号进行转义，也就是对其进行编码。 + 例如中文。否则如果客户端浏览器和服务端浏览器支持的字符集不同的情况下，中文可能会造成问题。 Url编码的原则：就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。 所以URL会采用ASCII字符。 ☀3.2哪些字符需要二次编码： RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。即合法字符。 保留字符：Url可以划分成若干个组件，协议、主机、路径等。有一些字符（😕?#[]@）是用作分隔不同组件的。例如：冒号用于分隔协议和主机，/用于分隔主机和路径，?用于分隔路径和查询参数，等等。还有一些字符（!$&amp;'()*+,;=）用于在每个组件中起到分隔作用的，如=用于表示查询参数中的键值对，&amp;符号用于分隔查询多个键值对。当组件中的普通数据包含这些特殊字符时，需要对其进行二次URI编码。 RFC3986中指定了以下字符为保留字符：! * ’ ( ) ; : @ &amp; = + $ , / ? # [ ] 不安全字符：还有一些字符，当他们直接放在Url中的时候，可能会引起解析程序的歧义。这些字符被视为不安全字符，原因有很多。 空格：Url在传输的过程，或者用户在排版的过程，或者文本处理程序在处理Url的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。 引号以及&lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔Url的作用 #：通常用于表示书签或者锚点 %：百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码 {}|^[]`~：某一些网关或者传输代理会篡改这些字符 所以对于URL中的非合法字符，可能会引起程序歧义的不安全字符，都需要进行URI二次编码。 ☀3.3URL二次编码原理： 编码格式： 使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。 对于ASCII字符： URL编码的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，我们在地址栏上输入http://g.cn/search?q=%61%62%63，实际上就等同于在google上搜索abc了。又如@符号在ASCII字符集中对应的字节为0x40，经过Url编码之后得到的是%40。 对于非ASCII字符： 需要使用ASCII字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码。对于Unicode字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。 ​ 如&quot;中文&quot;使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到&quot;%E4%B8%AD%E6%96%87&quot;。 ​ 如果某个字节对应着ASCII字符集中的某个字符，是安全字符，则此字节无需使用百分号表示。例如&quot;Url编码&quot;，使用UTF-8编码得到的字节是0x55 0x72 0x6C 0xE7 0xBC 0x96 0xE7 0xA0 0x81，由于前三个字节对应着ASCII中的非保留字符&quot;Url&quot;，因此这三个字节可以用非保留字符&quot;Url&quot;表示。最终的Url编码可以简化成&quot;Url%E7%BC%96%E7%A0%81&quot; ，当然，如果你用&quot;%55%72%6C%E7%BC%96%E7%A0%81&quot;也是可以的。 ☀3.4Javascript中的escape, encodeURI和encodeURIComponent的区别 Javascript中提供了3对函数用来对Url编码以得到合法的Url，它们分别是escape / unescape, encodeURI / decodeURI和encodeURIComponent / decodeURIComponent。由于解码和编码的过程是可逆的，因此这里只解释编码的过程。 这三个编码的函数——escape，encodeURI，encodeURIComponent——都是用于将不安全不合法的Url字符转换为合法的Url字符表示，它们有以下几个不同点。 安全字符不同： 下面列出了这三个函数的安全字符（即函数不会对这些字符进行编码） escape（69个）：*/@±._0-9a-zA-Z encodeURI（82个）：!#$&amp;'()*+,/:;=?@-._~0-9a-zA-Z encodeURIComponent（71个）：!'()*-._~0-9a-zA-Z **兼容性不同：**escape函数是从Javascript 1.0的时候就存在了，其他两个函数是在Javascript 1.5才引入的。但是由于Javascript 1.5已经非常普及了，所以实际上使用encodeURI和encodeURIComponent并不会有什么兼容性问题。 对Unicode字符的编码方式不同：这三个函数对于ASCII字符的编码方式相同，均是使用百分号+两位十六进制字符来表示。但是对于Unicode字符，escape的编码方式是%uxxxx，其中的xxxx是用来表示unicode字符的4位十六进制字符。这种方式已经被W3C废弃了。但是在ECMA-262标准中仍然保留着escape的这种编码语法。encodeURI和encodeURIComponent则使用UTF-8对非ASCII字符进行编码，然后再进行百分号编码。这是RFC推荐的。因此建议尽可能的使用这两个函数替代escape进行编码。 **适用场合不同：**encodeURI被用作对一个完整的URI进行编码，而encodeURIComponent被用作对URI的一个组件进行编码。从上面提到的安全字符范围表格来看，我们会发现，encodeURIComponent编码的字符范围要比encodeURI的大。我们上面提到过，保留字符一般是用来分隔URI组件（一个URI可以被切割成多个组件，参考预备知识一节）或者子组件（如URI中查询参数的分隔符），如：号用于分隔scheme和主机，?号用于分隔主机和路径。由于encodeURI操纵的对象是一个完整的的URI，这些字符在URI中本来就有特殊用途，因此这些保留字符不会被encodeURI编码，否则意义就变了。 组件内部有自己的数据表示格式，但是这些数据内部不能包含有分隔组件的保留字符，否则就会导致整个URI中组件的分隔混乱。因此对于单个组件使用encodeURIComponent，需要编码的字符就更多了。 ☀3.4.1Javascript函数：escape() 好了，到此为止，四种情况都说完了。 假定前面你都看懂了，那么此时你应该会感到很头痛。因为，实在太混乱了。不同的操作系统、不同的浏览器、不同的网页字符集，将导致完全不同的编码结果。如果程序员要把每一种结果都考虑进去，是不是太恐怖了？有没有办法，能够保证客户端只用一种编码方法向服务器发出请求？ 回答是有的，就是使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。 Javascript语言用于编码的函数，一共有三个，最古老的一个就是escape()。虽然这个函数现在已经不提倡使用了，但是由于历史原因，很多地方还在使用它，所以有必要先从它讲起。 实际上，escape()不能直接用于URL编码，它的真正作用是返回一个字符的Unicode编码值。比如“春节”的返回结果是%u6625%u8282，也就是说在Unicode字符集中，“春”是第6625个（十六进制）字符，“节”是第8282个（十六进制）字符。 它的具体规则是，除了ASCII字母、数字、标点符号“@ * _ + - . /”以外，对其他所有字符进行编码。在\\u0000到\\u00ff之间的符号被转成%xx的形式，其余符号被转成%uxxxx的形式。对应的解码函数是unescape()。 所以，“Hello World”的escape()编码就是“Hello%20World”。因为空格的Unicode值是20（十六进制）。 还有两个地方需要注意。 首先，无论网页的原始编码是什么，一旦被Javascript编码，就都变为unicode字符。也就是说，Javascipt函数的输入和输出，默认都是Unicode字符。这一点对下面两个函数也适用。 其次，escape()不对“+”编码。但是我们知道，网页在提交表单的时候，如果有空格，则会被转化为+字符。服务器处理数据的时候，会把+号处理成空格。所以，使用的时候要小心。 ☀3.4.2Javascript函数：encodeURI() encodeURI()是Javascript中真正用来对URL编码的函数。 它着眼于对整个URL进行编码，因此除了常见的符号以外，对其他一些在网址中有特殊含义的符号“; / ? : @ &amp; = + $ , #”，也不进行编码。编码后，它输出符号的utf-8形式，并且在每个字节前加上%。 它对应的解码函数是decodeURI()。 需要注意的是，它不对单引号’编码。 ☀3.4.3Javascript函数：encodeURIComponent() 最后一个Javascript编码函数是encodeURIComponent()。与encodeURI()的区别是，它用于对URL的组成部分进行个别编码，而不用于对整个URL进行编码。 因此，“; / ? : @ &amp; = + $ , #”，这些在encodeURI()中不被编码的符号，在encodeURIComponent()中统统会被编码。至于具体的编码方法，两者是一样。 它对应的解码函数是decodeURIComponent()。 ​ 经过测试，与java中的URLEncoder.encode(str,&quot;UTF-8&quot;);效果基本一致。会将=号这些字符也进项编码。 ☀3.5URL编码应用场景 ☀3.5.1表单提交 当Html的表单被提交时，每个表单域都会被Url编码之后才在被发送。由于历史的原因，表单使用的Url编码实现并不符合最新的标准。例如对于空格使用的编码并不是%20，而是+号，如果表单使用的是Post方法提交的，我们可以在HTTP头中看到有一个Content-Type的header，值为application/x-www-form-urlencoded。大部分应用程序均能处理这种非标准实现的Url编码，但是在客户端Javascript中，并没有一个函数能够将+号解码成空格，只能自己写转换函数。还有，对于非ASCII字符，使用的编码字符集取决于当前文档使用的字符集。例如我们在Html头部加上 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; 这样浏览器就会使用gb2312去渲染此文档（注意，当HTML文档中没有设置此meta标签，则浏览器会根据当前用户喜好去自动选择字符集，用户也可以强制当前网站使用某个指定的字符集）。当提交表单时，Url编码使用的字符集就是gb2312。 ☀3.6.encodeURI使用建议 ☀3.6.1页面文件存储使用的字符集和Meta标签中指定的字符集需一致。 123456789101112&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot;&gt; document.write(encodeURI(&quot;中文&quot;)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果输出%E6%B6%93%EE%85%9F%E6%9E%83。显然这并不是使用UTF-8字符集进行Url编码得到的结果（在Google上搜索&quot;中文&quot;，Url中显示的是%E4%B8%AD%E6%96%87）。 所以我当时就很质疑，难道encodeURI还跟页面编码有关，但是我发现，正常情况下，如果你使用gb2312进行Url编码也不会得到这个结果的才是。后来终于被我发现，原来是页面文件存储使用的字符集和Meta标签中指定的字符集不一致导致的问题。Aptana的编辑器默认情况下使用UTF-8字符集。也就是说这个文件实际存储的时候使用的是UTF-8字符集。但是由于Meta标签中指定了gb2312，这个时候，浏览器就会按照gb2312去解析这个文档，那么自然在&quot;中文&quot;这个字符串这里就会出错，因为&quot;中文&quot;字符串用UTF-8编码过后得到的字节是0xE4 0xB8 0xAD 0xE6 0x96 0x87，这6个字节又被浏览器拿gb2312去解码，那么就会得到另外三个汉字&quot;涓枃&quot;（GBK中一个汉字占两个字节），这三个汉字在传入encodeURI函数之后得到的结果就是%E6%B6%93%EE%85%9F%E6%9E%83。因此，encodeURI使用的还是UTF-8，并不会受到页面字符集的影响。 ☀3.6.2Url中的存在歧义的组件全部显式指定某个字符集进行Url编码 对于包含中文的Url的处理问题，不同浏览器有不同的表现。例如对于IE，如果你勾选了高级设置&quot;总是以UTF-8发送Url&quot;，那么Url中的路径部分的中文会使用UTF-8进行Url编码之后发送给服务端，而查询参数中的中文部分使用系统默认字符集进行Url编码。为了保证最大互操作性，建议所有放到Url中的组件全部显式指定某个字符集进行Url编码，而不依赖于浏览器的默认实现。 就是使用Javascript先对URL编码，然后再向服务器提交，不要给浏览器或者其他组件插手的机会。因为Javascript的输出总是一致的，所以就保证了服务器得到的数据是格式统一的。 ☀3.7浏览器地址栏URI出现中文的原因 很多HTTP监视工具或者浏览器地址栏等在显示Url的时候会自动将Url进行一次解码（使用UTF-8字符集），这就是为什么当你在Firefox中访问Google搜索中文的时候，地址栏显示的Url包含中文的缘故。但实际上发送给服务端的原始Url还是经过编码的。你可以在地址栏上使用Javascript访问location.href就可以看出来了。在研究Url编解码的时候千万别被这些假象给迷惑了。 ☀4.实际应用场景问题解决 ☀4.1两次encodeURI解决服务器配置的解码字符集未知问题 ☀4.1.1场景说明： 当使用地址栏提交查询参数时，如果不编码，非英文字符会按照操作系统的字符集进行编码提交到服务器，服务器会按照配置的字符集进行解码，所以如果两者不一致就会导致乱码。如果只进行一次encodeURI，因为encodeURI函数采用UTF-8对URL进行编码，所以如果服务器在进行解码时使用的是其他的编码方式就会出现乱码，默认的服务器配置的解码字符集都不是UTF-8，所以大部分情况下地址栏提交中文查询参数时会产生乱码；针对这种情况，可以连续使用两次encodeURI在客户端(主要指浏览器)对非英文字符进行编码，然后在服务端使用java.net.URLDecoder(String.“UTF-8”)解码，即可得到正确的中文。 ☀4.1.2原理： .encodeURL函数主要是来对URI来做转码，它默认是采用的UTF-8的编码. . UTF-8编码的格式:一个汉字来三个字节构成，每一个字节会转换成16进制的编码，同时添加上%号. 假设页面端输入的中文是一个“中”，按照下面步骤进行解码 1.第一次encodeURI，按照utf-8方式获取字节数组变成[-28,-72-83]，对字节码数组进行遍历，把每个字节转化成对应的16进制数，这样就变成了[E4,B8,AD],最后变成[%E4,%B8,%AD] 此时已经没有了多字节字符，全部是单字节字符。 2、第二次encodeURI，进行编码，会把%看成一个转义字符，并不编码%以后字符，会把%编码成%25.把数组最后变成[%25E4,%25B8,%25AD]然后就把处理后的数据[%25E4,%25B8,%25AD]发往服务器端， 当应用服务器调用getParameter方法，getParameter方法会去向应用服务器请求参数 应用服务器最初获得的就是发送来的[%25E4,%25B8,%25AD]，应用服务器会对这个数据进行URLdecode操作，应用服务器进行解码的这一次，不管是按照UTF-8，还是GBK，还是ISO-8859，,都能得到[%E4,%B8,%AD]，因为都会把%25解析成%.并把这个值返回给getParameter方法 3\\、再用UTF-8解码一次，就得到&quot;中&quot;了。 转载自：https://blog.csdn.net/zengshaotao/article/details/84907582","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"URI","slug":"URI","permalink":"http://aner1001.gitee.io/tags/URI/"},{"name":"URL","slug":"URL","permalink":"http://aner1001.gitee.io/tags/URL/"},{"name":"encodeURI","slug":"encodeURI","permalink":"http://aner1001.gitee.io/tags/encodeURI/"}]},{"title":"windows-cmd","slug":"技术知识/计算机/Windows/windows-cmd","date":"2021-02-02T11:49:43.000Z","updated":"2021-02-02T11:49:43.000Z","comments":true,"path":"posts/2021/02/02/44b283593c52/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/02/44b283593c52/","excerpt":"windows系统，cmd命令使用记录。","text":"windows系统，cmd命令使用记录。 ☀进程相关 查看端口占用的进程pid： 1netstat -aon|findstr &quot;4000&quot; 查看pid所对应的软件： 1tasklist|findstr &quot;2100&quot; 杀死进程： 12tskill 2100taskkill -f -pid 2100 ☀环境变量 查看环境变量的值： 1echo %PATH% ☀修复 扫描修复系统 1sfc /scannow","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://aner1001.gitee.io/tags/windows/"},{"name":"cmd","slug":"cmd","permalink":"http://aner1001.gitee.io/tags/cmd/"}]},{"title":"编码的由来","slug":"技术知识/计算机/编码的由来","date":"2021-02-02T11:28:06.000Z","updated":"2021-02-02T11:28:06.000Z","comments":true,"path":"posts/2021/02/02/853166c12e60/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/02/853166c12e60/","excerpt":"在计算机中，所有的数据在存储和运算时都要使用二进制数表示，而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了，ASCII统一规定了上述常用符号用哪些二进制数来表示。","text":"在计算机中，所有的数据在存储和运算时都要使用二进制数表示，而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了，ASCII统一规定了上述常用符号用哪些二进制数来表示。 ☀1.ASCII ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是最通用的信息交换标准，并等同于国际标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符 [1] 。 ☀1.1产生原因： 在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示1和0），例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）在计算机中存储时也要使用二进制数来表示，而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套（这就叫编码），而大家如果要想互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了ASCII编码，统一规定了上述常用符号用哪些二进制数来表示 [2] 。 美国信息交换标准代码是由美国国家标准学会(American National Standard Institute , ANSI )制定的，是一种标准的单字节字符编码方案，用于基于文本的数据。它最初是美国国家标准，供不同计算机在相互通信时用作共同遵守的西文字符编码标准，后来它被国际标准化组织（International Organization for Standardization, ISO）定为国际标准，称为ISO 646标准。适用于所有拉丁文字字母 [3] 。 ☀2.编码和解码 ☀2.1编码 将字符串按照某个字符集，转换为01类型的数据进行存储。 通常如果一样东西需要编码。最根本的说明这样东西并不适合传输或者存储。原因多种多样： 1. 从最基础的字符串，必须通过编码为0 1类型，才能传输存储到计算机中。 2. 随着应用场景的变化和逐渐复杂。如Size过大，包含隐私数据，都要使用编码解决。 3. 对于Url来说，本身的字符串已经被编码，之所以要进行二次编码(URLEncode)，是因为Url中有些字符会引起歧义。 ☀2.2解码 将01类型的数据按照某个字符集转换为字符串。 有编码就会有解码，重新恢复原状。","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"tags":[{"name":"ASCII","slug":"ASCII","permalink":"http://aner1001.gitee.io/tags/ASCII/"},{"name":"编码","slug":"编码","permalink":"http://aner1001.gitee.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"Atom使用手册","slug":"技术知识/工具/Atom使用手册","date":"2021-02-02T07:55:46.000Z","updated":"2021-02-02T07:55:46.000Z","comments":true,"path":"posts/2021/02/02/4cf514f56a73/","link":"","permalink":"http://aner1001.gitee.io/posts/2021/02/02/4cf514f56a73/","excerpt":"Atom 是github专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。","text":"Atom 是github专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。 ☀1.简介 Atom 是github专门为程序员推出的一个跨平台文本编辑器。具有简洁和直观的图形用户界面，并有很多有趣的特点：支持CSS，HTML，JavaScript等网页编程语言。 ❀主要功能 ​ 支持CSS，HTML，JavaScript等网页编程语言。它支持宏，自动完成分屏功能，集成了文件管理器。 通过丰富的插件机制可以完成各种语言开发, 常用于web 开发, 也可用于 php 等后端开发. ❀优点： 小清新界面让人耳目一新.颜控必备 丰富的插件几乎能够满足所有 web 开发需求 git 原生支持 简单的插件编写 自定义界面[如右图可以更改展示和背景,ui 等等] ❀缺点： 打开大文件卡死。 svn 支持较差。 ☀1.1下载 github地址：https://github.com/atom/atom/releases ☀2.快捷键 快捷键 解释 Crtl+Shift+M 开启Markdown实时预览 Command+Shift+P 打开命令窗口，可以运行各种菜单功能 Command + T 快速多文件切换 Command + F 文件内查找和替换 Command + Shift + F 多文件查找和替换 Command + [ 对选中内容向左缩进 Command + ] 对选中内容向右缩进 Command + \\ 显示或隐藏目录树 Crtl + m 相应括号之间，html tag之间等跳转 Crtl + Alt + B 格式化代码（需要安装atom-beautify） Crtl + ` 调起CLI命令行界面（需要安装terminal-panel） Alt+Shift+T 另外调起CMD命令界面。(需要安装atom-terminal)插件 ☀3.插件的使用 Settings中的Install和Package功能。 ☀3.1 gist 插件名称：gist 能够创建和插入gist内容。 命令：gist Gist:list中选中一条gist，按住tab，可选择修改，插入当前文本，或者删除gist。 ☀3.2 sync-settings ☀3.2.1安装sync-settings 选择Install a Package 输入sync-settings, 然后点击Packages 找到后，点击&quot;Install&quot; ☀3.2.2生成token 登录github, 右上角帐户下Personal setting 从左侧选择&quot;Personal access tokens&quot;, 随便写一个名字做为token描述， 勾选gist, 然后点击&quot;Generate token&quot; 下面那串e6a开始的就是token 因为这个是一次性的，所以最好把它拷贝下来，贴到记事本 ☀3.2.3生成gist id 在github最上面有一个gist 点击它就会进入下面界面 随便写点东西，然后点&quot;Greate secret gist&quot; 上图中被涂抹的总体就是gist id ☀3.2.4配置sync-setting 回到atom, 进入sync-setting, 填上刚才的token和gist id 然后用Ctrl-Shift-P打开命令行窗口 输入sync backup 如果成功就会出现 ☀3.2.5检查gist 在gist里也能看到多了一些东西 这些文件就是你的配置文件 ☀3.3 platformio-ide-terminal 终端工具-win7上的atom还没安装成功。 ☀3.4 atom-terminal 快速打开原生的cmd窗口，基于当前项目的根目录。非常好用。 打开快捷键:alt+shift+T ☀4.参考文章 使用gist来备份atom的配置","categories":[{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://aner1001.gitee.io/tags/IDE/"},{"name":"Atom","slug":"Atom","permalink":"http://aner1001.gitee.io/tags/Atom/"}]}],"categories":[{"name":"生活知识","slug":"生活知识","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/"},{"name":"经验感悟","slug":"生活知识/经验感悟","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E7%BB%8F%E9%AA%8C%E6%84%9F%E6%82%9F/"},{"name":"宠物","slug":"生活知识/宠物","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%AE%A0%E7%89%A9/"},{"name":"读书笔记","slug":"生活知识/读书笔记","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术知识","slug":"技术知识","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/"},{"name":"数据库","slug":"技术知识/数据库","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"做饭","slug":"生活知识/做饭","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%9A%E9%A5%AD/"},{"name":"工具","slug":"技术知识/工具","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E5%B7%A5%E5%85%B7/"},{"name":"脚本","slug":"技术知识/脚本","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%84%9A%E6%9C%AC/"},{"name":"中间件","slug":"技术知识/中间件","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"Web","slug":"技术知识/Web","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Web/"},{"name":"Java","slug":"技术知识/Java","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/Java/"},{"name":"算法","slug":"技术知识/算法","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95/"},{"name":"计算机","slug":"技术知识/计算机","permalink":"http://aner1001.gitee.io/categories/%E6%8A%80%E6%9C%AF%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"健康","slug":"生活知识/健康","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E5%81%A5%E5%BA%B7/"},{"name":"教育","slug":"生活知识/教育","permalink":"http://aner1001.gitee.io/categories/%E7%94%9F%E6%B4%BB%E7%9F%A5%E8%AF%86/%E6%95%99%E8%82%B2/"}],"tags":[{"name":"车","slug":"车","permalink":"http://aner1001.gitee.io/tags/%E8%BD%A6/"},{"name":"SQLServer","slug":"SQLServer","permalink":"http://aner1001.gitee.io/tags/SQLServer/"},{"name":"eclipse","slug":"eclipse","permalink":"http://aner1001.gitee.io/tags/eclipse/"},{"name":"windows","slug":"windows","permalink":"http://aner1001.gitee.io/tags/windows/"},{"name":"Redis","slug":"Redis","permalink":"http://aner1001.gitee.io/tags/Redis/"},{"name":"Hexo","slug":"Hexo","permalink":"http://aner1001.gitee.io/tags/Hexo/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://aner1001.gitee.io/tags/Nodejs/"},{"name":"Ruby","slug":"Ruby","permalink":"http://aner1001.gitee.io/tags/Ruby/"},{"name":"Jekyll","slug":"Jekyll","permalink":"http://aner1001.gitee.io/tags/Jekyll/"},{"name":"nvm","slug":"nvm","permalink":"http://aner1001.gitee.io/tags/nvm/"},{"name":"npm","slug":"npm","permalink":"http://aner1001.gitee.io/tags/npm/"},{"name":"Nginx","slug":"Nginx","permalink":"http://aner1001.gitee.io/tags/Nginx/"},{"name":"Google","slug":"Google","permalink":"http://aner1001.gitee.io/tags/Google/"},{"name":"GoogleAnalytics","slug":"GoogleAnalytics","permalink":"http://aner1001.gitee.io/tags/GoogleAnalytics/"},{"name":"GitHub","slug":"GitHub","permalink":"http://aner1001.gitee.io/tags/GitHub/"},{"name":"PicGo","slug":"PicGo","permalink":"http://aner1001.gitee.io/tags/PicGo/"},{"name":"jsDelivr","slug":"jsDelivr","permalink":"http://aner1001.gitee.io/tags/jsDelivr/"},{"name":"GitHubPages","slug":"GitHubPages","permalink":"http://aner1001.gitee.io/tags/GitHubPages/"},{"name":"跨域","slug":"跨域","permalink":"http://aner1001.gitee.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"基础","slug":"基础","permalink":"http://aner1001.gitee.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://aner1001.gitee.io/tags/MarkDown/"},{"name":"Typroa","slug":"Typroa","permalink":"http://aner1001.gitee.io/tags/Typroa/"},{"name":"Html","slug":"Html","permalink":"http://aner1001.gitee.io/tags/Html/"},{"name":"Ajax","slug":"Ajax","permalink":"http://aner1001.gitee.io/tags/Ajax/"},{"name":"SPI","slug":"SPI","permalink":"http://aner1001.gitee.io/tags/SPI/"},{"name":"算法","slug":"算法","permalink":"http://aner1001.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"HashTable","slug":"HashTable","permalink":"http://aner1001.gitee.io/tags/HashTable/"},{"name":"家具","slug":"家具","permalink":"http://aner1001.gitee.io/tags/%E5%AE%B6%E5%85%B7/"},{"name":"Linux","slug":"Linux","permalink":"http://aner1001.gitee.io/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"http://aner1001.gitee.io/tags/Git/"},{"name":"Springboot","slug":"Springboot","permalink":"http://aner1001.gitee.io/tags/Springboot/"},{"name":"税收","slug":"税收","permalink":"http://aner1001.gitee.io/tags/%E7%A8%8E%E6%94%B6/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://aner1001.gitee.io/tags/Mybatis/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://aner1001.gitee.io/tags/SpringMVC/"},{"name":"Spring","slug":"Spring","permalink":"http://aner1001.gitee.io/tags/Spring/"},{"name":"Mysql","slug":"Mysql","permalink":"http://aner1001.gitee.io/tags/Mysql/"},{"name":"Serializable","slug":"Serializable","permalink":"http://aner1001.gitee.io/tags/Serializable/"},{"name":"Maven","slug":"Maven","permalink":"http://aner1001.gitee.io/tags/Maven/"},{"name":"linux","slug":"linux","permalink":"http://aner1001.gitee.io/tags/linux/"},{"name":"vi","slug":"vi","permalink":"http://aner1001.gitee.io/tags/vi/"},{"name":"学习方法","slug":"学习方法","permalink":"http://aner1001.gitee.io/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"},{"name":"减肥","slug":"减肥","permalink":"http://aner1001.gitee.io/tags/%E5%87%8F%E8%82%A5/"},{"name":"Chrome","slug":"Chrome","permalink":"http://aner1001.gitee.io/tags/Chrome/"},{"name":"VsCode","slug":"VsCode","permalink":"http://aner1001.gitee.io/tags/VsCode/"},{"name":"Sql","slug":"Sql","permalink":"http://aner1001.gitee.io/tags/Sql/"},{"name":"域名","slug":"域名","permalink":"http://aner1001.gitee.io/tags/%E5%9F%9F%E5%90%8D/"},{"name":"CDN","slug":"CDN","permalink":"http://aner1001.gitee.io/tags/CDN/"},{"name":"IDEA","slug":"IDEA","permalink":"http://aner1001.gitee.io/tags/IDEA/"},{"name":"Gist","slug":"Gist","permalink":"http://aner1001.gitee.io/tags/Gist/"},{"name":"URI","slug":"URI","permalink":"http://aner1001.gitee.io/tags/URI/"},{"name":"URL","slug":"URL","permalink":"http://aner1001.gitee.io/tags/URL/"},{"name":"encodeURI","slug":"encodeURI","permalink":"http://aner1001.gitee.io/tags/encodeURI/"},{"name":"cmd","slug":"cmd","permalink":"http://aner1001.gitee.io/tags/cmd/"},{"name":"ASCII","slug":"ASCII","permalink":"http://aner1001.gitee.io/tags/ASCII/"},{"name":"编码","slug":"编码","permalink":"http://aner1001.gitee.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"IDE","slug":"IDE","permalink":"http://aner1001.gitee.io/tags/IDE/"},{"name":"Atom","slug":"Atom","permalink":"http://aner1001.gitee.io/tags/Atom/"}]}